---
id : A2.概述
title : A2.概述
typora-root-url : ../
---

### 系统调用

用户空间的程序默认是通过栈来传递参数的。对于系统调用来说，内核态和用户态使用的是不同的栈，这使得系统调用的参数只能通过寄存器的方式进行传递。

在写代码的时候，程序员根本不用关心参数是如何传递的，编译器已经默默地为我们做了一切——压栈、出栈、保存返回地址等操作，但是编译器如何知道调用的函数是普通函数，还是系统调用呢？如果是后者，编译器就不能简单地使用栈来传递参数了。

### c库函数

Linux环境下，使用的C库一般都是glibc，它封装了几乎所有的系统调用，代码中使用的“系统调用”，实际上就是调用C库中的函数。C库函数同样位于用户态，所以编译器可以统一处理所有的函数调用，而不用区分该函数到底是不是系统调用。

在Linux平台下，系统调用的约定是使用寄存器eax来传递系统调用号的。

### 线程安全

为了实现线程安全，该代码要么只能使用局部变量或资源，要么就是利用锁等同步机制，来实现全局变量或资源的串行访问。

++counter的汇编代码，其逻辑如下 

1. 将counter的值赋给寄存器EAX；
2. 对寄存器EAX的值加1；
3. 将EAX的值赋给counter。

 i++ 是：先复制，再自增，再返回复制结果；++i 是只自增。

`++counter`并非原子操作

### 原子性

以前原子被认为是物理组成的最小单元，所以在计算机领域，就借其不可分割的这层含义作为隐喻。

对于计算机科学来说，如果变量是原子的，那么对这个变量的任何访问和更改都是原子的。如果操作是原子的，那么这个操作将是不可分割的，要么成功，要么失败，不会有任何的中间状态。

原子性是事务的一个特性之一。

### 可重入函数

可重入是指当前进程已经处于该函数中，这时程序会允许当前进程的某个执行流程再次进入该函数，而不会引发问题。这里的执行流程不仅仅包括多线程，还包括信号处理、longjump等执行流程。所以，可重入函数一定是线程安全的，而线程安全函数则不一定是可重入函数。

当函数使用锁的时候，尤其是互斥锁的时候，该函数是不可重入的，否则会造成死锁。若函数使用了静态变量，并且其工作依赖于这个静态变量时，该函数也是不可重入的，否则会造成该函数工作不正常。

### 阻塞与非阻塞

阻塞的系统调用是指，当进行系统调用时，除非出错（被信号打断也视为出错），进程将会一直陷入内核态直到调用完成。非阻塞的系统调用是指无论I/O操作成功与否，调用都会立刻返回。

### 同步与非同步

同步和非同步，是指I/O数据的复制工作是否同步执行。

以系统调用read为例。阻塞的read会一直陷入内核态直到read返回；而非阻塞的read在数据未准备好的情况下，会直接返回错误，而当有数据时，非阻塞的read同样会一直陷入内核态，直到read完成。这个read就是同步的操作，即I/O的完成是在当前执行流程下同步完成的。

如果是非同步即异步，则I/O操作不是随系统调用同步完成的。调用返回后，I/O操作并没有完成，而是由操作系统或者某个线程负责真正的I/O操作，等完成后通知原来的线程。