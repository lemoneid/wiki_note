---
id : D4.进程间通信
title : D4.进程间通信
typora-root-url : ../
---



# IPC：进程间通信

## 1.共享内存

共享内存有两种shm和mmap

* IPC通信System V版本的共享内存shm
* 存储映射I/O（mmap函数） 

### shm

* 原理
  * 多个进程的地址空间映射到同一个物理内存，不同进程可以将同一段共享的内存连接到自己的地址空间中，从而所有进程都可以访问共享内存中的地址
* API
  * `int shmget(key_t key, size_t size, int shmflg);`
    * 在物理内存创建一个共享内存，返回共享内存的编号
    * key是一个非0整数，命名共享内存段，运行成功返回一个与key相关的共享内存标识符
    * size表示以字节为单位指定需要的共享内存的容量
    * shmflag是权限标志位，与open的mode参数一致，若key标识的共享内存不存在，通过0666|IPC_CREAT来创建，并设置权限

  * `void *shmat(int shmid, const void shmaddr,int shmflg);`
    * 连接成功后把共享内存区对象映射到调用进程的地址空间，函数返回各个进程挂接的虚拟的地址空间
    * shmid是挂接的进程号，
    * shmaddr置为NULL，让系统选择一个合适的地址空间进行挂接
    * shmflg表示什么方式进行挂接，一般都是取0.

  * `void *shmdt(const void* shmaddr);`
    * 将共享内存从当前进程中分离，断开用户级页表到共享内存的那根箭头。

  * `int shmctl(int shmid, int cmd, struct shmid_ds* buf);`
    * 释放物理内存中的那块共享内存
    * cmd取IPC_RMID表示删除这块共享内存

### mmap

* 原理
  * mmap是映射磁盘上的一个文件，每个进程在自己的逻辑地址空间中开辟一块空间对磁盘上的文件进行映射
  * 内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存
  * mmap返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址，建立内存映射并没有实际拷贝数据，这时，将产生一个缺页中断，会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中

* 效率
  * read()是系统调用，其中进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中，实际上完成了两次数据拷贝
  * mmap()也是系统调用，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝

* 映射文件
  * 普通文件
    * open系统调用打开一个文件，然后进行mmap操作，得到共享内存，这种方式适用于任何进程之间。 
  * 匿名映射
    * 调用 mmap 时，在参数 flags 中指定 MAP_ANONYMOUS 标志位，并且将参数 fd 指定为 -1 ,用于父子进程之间

### 不同进程访问共享内存

* shm
  * 不同进程通过shmget->shmat函数，将共享内存连接到自己的虚拟内存地址
* mmap
  * 不同进程通过mmap函数创建映射区，将自己的内存虚拟地址映射到磁盘的文件上

### 程序异常退出，共享内存会释放吗？

* 不会
  * Linux中通过API函数shmget创建的共享内存一般都是在程序中使用shmctl来释放的，但是有时为了调试程序，开发人员可能通过Ctrl + C等方式发送中断信号来结束程序，此时程序申请的共享内存就不能得到释放，当然如果程序没有改动的话，重新运行程序时仍然会使用上次申请的共享内存，但是如果我们修改了程序，由于共享内存的大小不一致等原因会导致程序申请共享内存错误。
* 如何释放
  * 如果总是通过Crtl+C来结束的话，可以做一个信号处理器，当接收到这个信号的时候，先释放共享内存，然后退出程序。
  * 不管你以什么方式结束程序，如果共享内存还是得不到释放，那么可以通过linux命令ipcrm shm shmid来释放，在使用该命令之前可以通过ipcs -m命令来查看共享内存。 

### 两者的区别

* 作用
  * mmap系统调用并不完全是为了共享内存来设计的，它本身提供了不同于一般对普通文件的访问的方式，进程可以像读写内存一样对普通文件进行操作
  * IPC的共享内存shm是纯粹为了共享。
* 映射位置
  * mmap是在磁盘上建立一个文件，每个进程地址空间中开辟出一块空间对磁盘上的文件进行映射。
  * shm每个进程映射到同一块物理内存，shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大
* 内容丢失
  * 进程挂了重启不丢失内容，二者都可以做到 
  * 机器挂了重启，mmap把文件存在磁盘上，可以不丢失内容（文件内保存了OS同步过的映像），而 shmget 会丢失 



#### synopsis



```c
       key_t ftok(const char *pathname, int proj_id);
		//项目自定义的约定id
       int shmget(key_t key, size_t size, int shmflg);
		//验证共享内存段是否存在,获取内存段，返回shmid
       void *shmat(int shmid, const void *shmaddr, int shmflg);
		//根据shmid捕获内存段
       int shmdt(const void *shmaddr);

```





#### example

```c
struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory;

	key_t key = ftok(".", 2009);
	//0666所有人可读可写
    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

```



```cpp
#include "head.h"

struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory;
void do_add(int max, int x) {
    while(1) {
        //先判断,加解锁
        //lock
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\n", x, share_memory->now, share_memory->sum);

        if (share_memory->now > max) {
            //unlock
            pthread_mutex_unlock(&share_memory->mutex);
            break;
        }
        share_memory->sum += share_memory->now;
        share_memory->now++;

        //unlock
        pthread_mutex_unlock(&share_memory->mutex);
    }
}


int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ints\n", argv[0]);
    }
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2009);
    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    
    memset(share_memory, 0, sizeof(struct Num));
    //锁属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    
    //对锁属性更改,让线程锁可以在进程间共享
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

    //初始化锁
    pthread_mutex_init(&share_memory->mutex, &attr);
    
    int x = 0;
    for (int i = 0; i < ins; ++i) {
        if (pid = fork() < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
    if (pid == 0) {
        do_add(max, x);
        exit(0);
    }
    
    while (ins--) {
        wait(NULL);
    }

    return 0;
}

```





## 2.线程锁



#### synopsis

```c

   int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
                                        int pshared);
			pthread_mutex_init();
             pthread_mutex_lock();
             pthread_mutex_unlock();
```





#### example

```c
struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory;
		

//lock
		pthread_mutex_lock(&share_memory->mutex);

        //unlock
        pthread_mutex_unlock(&share_memory->mutex);


//锁属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    
    //对锁属性更改,让线程锁可以在进程间共享
    pthread_mutexattr_setpshared(&attr, 	PTHREAD_PROCESS_SHARED);

    //初始化锁
    pthread_mutex_init(&share_memory->mutex, &attr);

```



### 共享内存：累加

```c
#include "head.h"

struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory;


void do_add(int max, int x) {
    while(1) {
        //先判断,加解锁
        //lock
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\n", x, share_memory->now, share_memory->sum);

        if (share_memory->now > max) {
            //unlock
            pthread_mutex_unlock(&share_memory->mutex);
            break;
        }
        share_memory->sum += share_memory->now;
        share_memory->now++;

        //unlock
        pthread_mutex_unlock(&share_memory->mutex);
    }
}


int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ints\n", argv[0]);
    }
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2009);
    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    
    memset(share_memory, 0, sizeof(struct Num));
    //锁属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    
    //对锁属性更改,让线程锁可以在进程间共享
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

    //初始化锁
    pthread_mutex_init(&share_memory->mutex, &attr);
    
    int x = 0;
    for (int i = 0; i < ins; ++i) {
        if (pid = fork() < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
    
    if (pid == 0) {
        
        do_add(max, x);
        exit(0);
    }
    
    while (ins--) {
        wait(NULL);
    }

    return 0;
}

```





### 共享内存：子进程输入，父进程输出

```c
#include "head.h"

struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory;


void do_add(int max, int x) {
    while(1) {
        //先判断,加解锁
        //lock
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\n", x, share_memory->now, share_memory->sum);

        if (share_memory->now > max) {
            //unlock
            pthread_mutex_unlock(&share_memory->mutex);
            break;
        }
        share_memory->sum += share_memory->now;
        share_memory->now++;

        //unlock
        pthread_mutex_unlock(&share_memory->mutex);
    }
}


int main(int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ints\n", argv[0]);
    }
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2009);
    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    
    memset(share_memory, 0, sizeof(struct Num));
    //锁属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    
    //对锁属性更改,让线程锁可以在进程间共享
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

    //初始化锁
    pthread_mutex_init(&share_memory->mutex, &attr);
    
    int x = 0;
    for (int i = 0; i < ins; ++i) {
        if (pid = fork() < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
    
    if (pid == 0) {
        
        do_add(max, x);
        exit(0);
    }
    
    while (ins--) {
        wait(NULL);
    }

    return 0;
}

```



## 3.[信号通知进程](http://www.360doc.com/content/16/0804/10/30953065_580685165.shtml)

### 信号的使用

用kill函数发送信号，在接收进程里，通过signal或者signalaction函数调用sighandler，来启动对应的函数处理信号消息。

* 发送信号
  * raise，向本身发送信号
  * kill，向指定进程发送信号
    * pid > 0 ：向进程号为pid的进程发送信号
    * pid = 0 ：向当前进程所在的进程组发送信号
    * pid = -1 ：向所有进程(除PID=1外)发送信号(权限范围内)
    * pid < -1 ：向进程组号为-pid的所有进程发送信号 
* 自定义信号动作/注册捕捉函数
  * signal
    * `typedef void (*sighandler_t)(int);`
    * `sighandler_t signal(int signum, sighandler_t handler);` 
    * signal里面需要设置捕捉的信号signum、自定义回调函数handler
  * sigaction
    * 同样需要设置捕捉信号和回调处理函数 

### 信号处理机制

每个进程之中，都有存着一个表，里面存着每种信号所代表的含义，内核通过设置表项中每一个位来

* 信号的接收
  * 接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。

* 信号的检测
  * 进程陷入内核态后，有两种场景会对信号进行检测：
    * 进程从内核态返回到用户态前进行信号检测
    * 进程在内核态中，从睡眠状态被唤醒的时候进行信号检测
  * 当发现有新信号时，便会进入下一步，信号的处理。

* 信号的处理
  * ( **内核** )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。
  * ( **用户** )接下来进程返回到用户态中，执行相应的信号处理函数。
  * ( **内核** )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。
  * ( **用户** )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。

至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。

### 信号通知进程，为什么通过内核转发？

* 之所以要通过内核来转发，这样做的目的应该也是为了对进程的管理和安全因素考虑。
* 因为在这些信号当中，SIGSTOP和SIGKILL这两个信号是可以将接收此信号的进程停掉的，而这类信号，肯定是需要有权限才可以发出的，不能够随便哪个程序都可以随便停掉别的进程。

### 信号处理示例

* A，B两个进程，A进程发送信号给B进程，信号并不是直接从进程A发送给进程B，而是要通过内核来进行转发。
* A进程发送的信号消息，由内核对B进程相应的表项进行设置。
  * 内核接受到这个信号消息后，会先检查A进程是否有权限对B进程的信号表对应的项进行设置
    * 如果可以，就会对B进程的信号表进行设置
    * 如果不可以，就忽略
    * 信号处理有个特点，就是没有排队的机制，也就是说某个信号被设置之后，如果B进程还没有来及进行响应，那么如果后续第二个同样的信号消息过来，就会被阻塞掉，也就是丢弃。
  * 内核对B进程信号设置完成后，就会发送中断请求给B进程，这样B进程就进入到内核态
  * 进程B根据那个信号表，查找对应的此信号的处理函数，保护现场，跳回到用户态执行信号处理函数，处理完成后，再次返回到内核态，再次保护现场，然后再次返回用户态，从中断位置开始继续执行。
  * 保护现场是在用户态和内核态之间跳转的时候，对堆栈现场的压栈保存。

#### synopsis

```c
		//接收信号       

		sighandler_t signal(int signum, sighandler_t handler);
		//handler ：typedef void (*sighandler_t)(int);
		//例如void *func(int signum)类型，表明是信号处理函数

		//pause()会令目前的进程暂停(进入睡眠状态), 直到被信号(signal)所中断。
         pause();


		//发信号
		int kill(pid_t pid, int sig);
		
```



#### example

```c
   if (pid == 0) {
       while (1) {
            DBG(GREEN"<Debug>"NONE " : locked in child\n");
            scanf("%[^\n]s", share_memory->str);
            getchar(); 
            printf(YELLOW"<child>"NONE " : %s\n ", share_memory->str);
            kill(getppid(), SIGUSR1);

       }
   }  else {
       signal(SIGUSR1, (void *)do_print);
       wait(NULL);
   }

```

```c
#include "head.h"
struct Data {
    char str[1000];
    pthread_mutex_t mutex;
};

struct Data *share_memory;

void *do_print(int signum) {
    printf(RED"<Parent>"NONE " : %s\n ", share_memory->str);
    memset(share_memory->str, 0, sizeof(share_memory->str));
    return NULL;
}

int main(int argc, char **argv) {
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 209);
    if ((shmid =shmget(key, sizeof(struct Data), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Data *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    memset(share_memory->str, 0, sizeof(share_memory->str));
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }

   if (pid == 0) {
       while (1) {
            DBG(GREEN"<Debug>"NONE " : locked in child\n");
            scanf("%[^\n]s", share_memory->str);
            getchar(); 
            printf(YELLOW"<child>"NONE " : %s\n ", share_memory->str);
            kill(getppid(), SIGUSR1);

       }
   }  else {
       signal(SIGUSR1, (void *)do_print);
       wait(NULL);
   }  
    return 0;
}
```







### 聊天室的实现

```c
// File Name: chat.h

#ifndef _CHAT_H
#define _CHAT_H

struct Message {
    char name[20];
    char msg[1024];
    pid_t pid;
    pthread_mutex_t mutex;
};

#endif

```



```c
//file Name: 1.server.c

#include "head.h"
#include "chat.h"

struct Message *share_memory = NULL;

void *print(int signum) {
    pthread_mutex_lock(&share_memory->mutex);
    printf(RED"<%s>"NONE " : %s\n", share_memory->name, share_memory->msg);
    memset(share_memory->name, 0, sizeof(share_memory->name));
    memset(share_memory->msg, 0, sizeof(share_memory->msg));
    pthread_mutex_unlock(&share_memory->mutex);
}

int main() {
    int shmid;
    key_t key = ftok(".", 2011);

    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    memset(share_memory, 0, sizeof(struct Message));
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&share_memory->mutex, &attr);
    
    share_memory->pid = getpid();
    while (1) {
        signal(SIGUSR2, (void *)print);
        //pause()会令目前的进程暂停(进入睡眠状态), 直到被信号(signal)所中断。
        pause();
    }
    return 0;
}

```

```c
//file Name: 2.client.c

#include "head.h"
#include "chat.h"

struct Message *share_memory = NULL;

int main(int argc, char **argv) {
    struct Message tmp;
    int opt;
    //"n:" 代表有参
    //optarg是getopt的三个全局变量之一,代表紧跟参数
    while ((opt = getopt(argc, argv, "n:")) != -1) {
        switch (opt) {
            case 'n' :
                strcpy(tmp.name, optarg);
                break;
            default :
                fprintf(stderr, "Usage : %s -n name!\n", argv[0]);
                exit(1);
                break;
        }
    }
    
    if (argc < 3) {
        fprintf(stderr, "Usage : %s -n name!\n", argv[0]);
        exit(1);
    }

    int shmid;
    key_t key = ftok(".", 2011);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    
    //脏数据,pid <= 0一定没起来
    if (share_memory->pid <= 0) {
        fprintf(stderr, "Please run server first!\n");    
        exit(1);
    }
    
    while(1) {
        scanf("%[^\n]s", tmp.msg);
        getchar();
        if (!strlen(tmp.msg)) continue;
        while (1) {
            //隐性bug msg为空,多个client端同时上锁
            if (!strlen(share_memory->msg)) {
                //持有锁可能阻塞
                pthread_mutex_lock(&share_memory->mutex);
                break;
            }
        }
        strcpy(share_memory->name, tmp.name);
        strcpy(share_memory->msg, tmp.msg);
        pthread_mutex_unlock(&share_memory->mutex);
        kill(share_memory->pid, SIGUSR2);
        memset(tmp.msg, 0, sizeof(tmp.msg));
    }

}


```



## 4.条件变量

#### synopsis

```c
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
			      const pthread_condattr_t *__restrict __cond_attr)
     __THROW __nonnull ((1));

/* Destroy condition variable COND.  */
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __THROW __nonnull ((1));

/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)
     __THROWNL __nonnull ((1));


/* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
			      pthread_mutex_t *__restrict __mutex)
     __nonnull ((1, 2))
```





#### example

```c
	//初始化条件变量
	pthread_condattr_t cond_attr;
    pthread_condattr_init(&cond_attr);
    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&share_memory->cond, &cond_attr);
	
	//等待信号
	pthread_cond_wait(&share_memory->cond, &share_memory->mutex);

	//发送信号
	pthread_cond_signal(&share_memory->cond);


pthread_cond_wait必须放在pthread_mutex_lock和pthread_mutex_unlock之间，
    因为他要根据共享变量的状态来决定是否要等待，而为了不永远等待下去所以必须要在lock/unlock队中
共享变量的状态改变必须遵守lock/unlock的规则
pthread_cond_signal即可以放在pthread_mutex_lock和pthread_mutex_unlock之间，也可以放在pthread_mutex_lock和pthread_mutex_unlock之后，但是各有优缺点。
```





### 聊天室2



```c
#include "head.h"
#include "chat.h"

struct Message *share_memory = NULL;

void *print(int signum) {
    pthread_mutex_lock(&share_memory->mutex);
    printf(RED"<%s>"NONE " : %s\n", share_memory->name, share_memory->msg);
    memset(share_memory->name, 0, sizeof(share_memory->name));
    memset(share_memory->msg, 0, sizeof(share_memory->msg));
    pthread_mutex_unlock(&share_memory->mutex);
}

int main() {
    int shmid;
    key_t key = ftok(".", 2011);

    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    memset(share_memory, 0, sizeof(struct Message));
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&share_memory->mutex, &attr);
    
    pthread_condattr_t cond_attr;
    pthread_condattr_init(&cond_attr);
    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&share_memory->cond, &cond_attr);

    //share_memory->pid = getpid();
    while (1) {
        //signal(SIGUSR2, (void *)print);
        //pause()会令目前的进程暂停(进入睡眠状态), 直到被信号(signal)所中断。
       // pause();
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Debug>"NONE " : wait before\n");
        pthread_cond_wait(&share_memory->cond, &share_memory->mutex);
        DBG(GREEN"<Debug>"NONE " : wait after\n");
        printf(RED"<%s>"NONE " : %s\n", share_memory->name, share_memory->msg);
        memset(share_memory->name, 0, sizeof(share_memory->name));
        memset(share_memory->msg, 0, sizeof(share_memory->msg));
        pthread_mutex_unlock(&share_memory->mutex);
    }
    return 0;
}

```





```c
#include "head.h"
#include "chat.h"

struct Message *share_memory = NULL;

int main(int argc, char **argv) {
    struct Message tmp;
    int opt;
    //"n:" 代表有参
    //optarg是getopt的三个全局变量之一,代表紧跟参数
    while ((opt = getopt(argc, argv, "n:")) != -1) {
        switch (opt) {
            case 'n' :
                strcpy(tmp.name, optarg);
                break;
            default :
                fprintf(stderr, "Usage : %s -n name!\n", argv[0]);
                exit(1);
                break;
        }
    }
    
    if (argc < 3) {
        fprintf(stderr, "Usage : %s -n name!\n", argv[0]);
        exit(1);
    }

    int shmid;
    key_t key = ftok(".", 2011);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    
    while(1) {
        scanf("%[^\n]s", tmp.msg);
        getchar();
        if (!strlen(tmp.msg)) continue;
        while (1) {
            //隐性bug msg为空,多个client端同时上锁
            if (!strlen(share_memory->msg)) {
                pthread_mutex_lock(&share_memory->mutex);
                break;
            }
        }
        strcpy(share_memory->name, tmp.name);
        strcpy(share_memory->msg, tmp.msg);
        pthread_mutex_unlock(&share_memory->mutex);
        //kill(share_memory->pid, SIGUSR2);
        pthread_cond_signal(&share_memory->cond);
        DBG(GREEN"<Debug>"NONE" : AFTER signal\n");
        memset(tmp.msg, 0, sizeof(tmp.msg));
    }

}


```





## 5.管道

#### synopsis



```c
int pipe(int pipefd[2]);
FILE *popen(const char *command, const char *type);
  int pclose(FILE *stream);
pipefd[0] refers to the read end of the pipe.  
 pipefd[1] refers to the write end of the pipe.
```

#### example

```c
			int pipefd[2];
			if (cpid == 0) {    /* Child reads from pipe */
               close(pipefd[1]);          /* Close unused write end */

               while (read(pipefd[0], &buf, 1) > 0)
                   write(STDOUT_FILENO, &buf, 1);

               write(STDOUT_FILENO, "\n", 1);
               close(pipefd[0]);
               _exit(EXIT_SUCCESS);

           } else {            /* Parent writes argv[1] to pipe */
               close(pipefd[0]);          /* Close unused read end */
               write(pipefd[1], argv[1], strlen(argv[1]));
               close(pipefd[1]);          /* Reader will see EOF */
               wait(NULL);                /* Wait for child */
               exit(EXIT_SUCCESS);
           }

```





```c
pid_t pid;
    int pipefd[2];
    char buffer[1024];
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }
    
    if (pid == 0) {
        close(pipefd[0]);
        while (1) {
            memset(buffer, 0, sizeof(buffer));
            scanf("%s", buffer);
            write(pipefd[1], buffer, strlen(buffer));
        }
    } else {
        close(pipefd[1]);
        while (1) {
            read(pipefd[0], buffer, sizeof(buffer));
            printf("%s\n", buffer);
            memset(buffer, 0, sizeof(buffer));
        }
    }
    


	FILE *fp;
    char buff[1024] = {0};
    //报错512 和 2的关系 
    if ((fp = popen("ls /etc", "r")) == NULL) {
        perror("m_open()");
        exit(1);
    }

    while (fgets(buff, sizeof(buff), fp) != NULL) {
        printf("%s", buff);
        bzero(buff, sizeof(buff));
    } 
    
    int status = pclose(fp);

```





### my_popen的实现



````c
#include "head.h"
static pid_t *childpid = NULL;
static int max;

FILE *m_popen(const char *cmd, const char *type) {
    int pfd[2];
    FILE *fp;
    pid_t pid;
    if ((type[0] != 'r' || type[0] != 'w') && type[1] != '\0') {
        errno = EINVAL;
        return NULL;
    }
    if (childpid == NULL) {
        max = sysconf(_SC_OPEN_MAX);
        if ((childpid = (pid_t *)calloc(max, sizeof(pid_t))) == NULL)
            return NULL;
    }

    if (pipe(pfd) < 0) {
        return NULL;
    }

    if ((pid = fork()) < 0) {
        return NULL;
    }

    if (pid == 0) {
        if (type[0] == 'r'){
            close(pfd[0]);
            if (pfd[1] != STDOUT_FILENO) {
                dup2(pfd[1], STDOUT_FILENO);
                close(pfd[1]);
            }
        } else {
            close(pfd[1]);
            if (pfd[0] != STDIN_FILENO) {
                dup2(pfd[0], STDIN_FILENO);
                close(pfd[0]);
            }
        }
        for (int i = 0; i < max; i++) {
            if (childpid[i] > 0)
                close(i);
        }

        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(0);
    }

    if (type[0] == 'r') {
        close(pfd[1]);
        if ((fp = fdopen(pfd[0], type)) == NULL)
            return NULL;
    } else {
        close(pfd[0]);
        if ((fp = fdopen(pfd[1], type)) == NULL)
            return NULL;
    }
    childpid[fileno(fp)] = pid;
    return fp;
}

int m_pclose(FILE *fp) {
    int status, fd, pid;
    if (childpid == NULL) {
        errno = EINVAL;
        return -1;
    }
    fd = fileno(fp);
    pid = childpid[fd];
    if (pid == 0) {
        errno = EINVAL;
        return -1;
    }
    childpid[fd] = 0;
    close(fd);
    waitpid(pid, &status, 0);
    return status;
}
````





## 线程池

### 测试文件

```c
#include "head.h"
#include "thread_pool.h"

#define SIZE 5 
#define THREADNUM 5 
#define BUFFSIZE 512

int main() {
    pthread_t tid[THREADNUM];
    struct task_queue taskQueue;
    taskQueue = *task_queue_init(&taskQueue, SIZE);
    DBG(GREEN"<Debug>"NONE " :head = %d. tail = %d, cnt = %d, size = %d\n", taskQueue.head, taskQueue.tail ,taskQueue.cnt, taskQueue.size);
    
    for (int i = 0; i < THREADNUM; ++i) {
         int id =  pthread_create(&tid[i], NULL, thread_run, (void *)&taskQueue);
        //DBG(GREEN"<Debug>"NONE " : Created = %d\n", id);
    }
        DBG(GREEN"<Debug>"NONE " : Created success\n");

    while (1) {
        FILE *fp = fopen("./thread_pool.c", "r");
        if (fp == NULL) {
            perror("fopen()");
            exit(1);
        }

        char buff[BUFFSIZE] = {0};
        
        while (fgets(buff, BUFFSIZE, fp) != NULL) {
            task_queue_push(&taskQueue, buff);
            memset(buff, 0, sizeof(buff));
            usleep(1);
        }
        
        fclose(fp);
        //break;
        /*
        scanf("%[^\n]s", buff);
        getchar();
        DBG(GREEN"<stdin>"NONE "before : %s\n", buff);
        task_queue_push(&taskQueue, buff);
        DBG(GREEN"<stdin>"NONE "after : %s\n", buff);
        */
    }
    //task_queue_clear(&taskQueue);
    for (int i = 0; i < THREADNUM; ++i) {
        pthread_join(tid[i], NULL);
    }
    return 0;
}

```





### 头文件

```c
#ifndef _THREAD_POOL_H
#define _THREAD_POOL_H

#include "head.h"

struct task_queue {
    int head;
    int tail;
    int size;
    int cnt;
    char **data;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};

struct task_queue * task_queue_init(struct task_queue *taskQueue, int size);

int task_queue_push(struct task_queue *taskQueue, char *str);
char *task_queue_pop(struct task_queue *taskQueue);
void task_queue_clear(struct task_queue *taskQueue);
void *thread_run(void *arg);

#endif

```



### 源文件

```c
#include "thread_pool.h" 
#include "head.h"

struct task_queue * task_queue_init(struct task_queue *taskQueue, int size) {
    taskQueue = (struct task_queue *)malloc(sizeof(struct task_queue));
    taskQueue->data = (char **)calloc( size, sizeof(char *));
    taskQueue->head = taskQueue->tail = 0;
    taskQueue->cnt = 0;
    taskQueue->size = size;
    DBG(BLUE"<init>"NONE "head = %d, tail = %d, cnt = %d, size = %d\n", taskQueue->head, taskQueue->tail ,taskQueue->cnt, taskQueue->size);

    if (pthread_mutex_init(&(taskQueue->mutex), NULL) != 0) {
        printf("mutex init error");
        return NULL;
    }
    if (pthread_cond_init(&(taskQueue->cond), NULL) != 0) {
        printf("cond init error");
        return NULL;
    }
    return taskQueue;
}

int task_queue_push(struct task_queue *taskQueue, char *str) {
    pthread_mutex_lock(&taskQueue->mutex);
    if (taskQueue == NULL)  {
        DBG(BLUE"<PUSH>"NONE " NULL");
        pthread_mutex_unlock(&taskQueue->mutex);
        return -1;
    }
    if (taskQueue->cnt > taskQueue->size) {
        DBG(BLUE"<PUSH Full>"NONE " cnt = %d, size = %d\n", taskQueue->cnt, taskQueue->size);
        pthread_mutex_unlock(&taskQueue->mutex);
        return 0;
    } 
    //DBG(BLUE"<PUSH>"NONE " %s\n", str);
    (taskQueue->data)[taskQueue->tail] = strdup(str);
    taskQueue->tail++;
    DBG(BLUE"<PUSH>"NONE "%s\n", taskQueue->data[taskQueue->tail - 1]);
    if (taskQueue->tail == taskQueue->size) taskQueue->tail -= taskQueue->size;
    taskQueue->cnt += 1;

    //pthread_cond_broadcast(&(taskQueue->cond));
    pthread_mutex_unlock(&taskQueue->mutex);
    pthread_cond_signal(&(taskQueue->cond));
    return 1;
}

char *task_queue_pop(struct task_queue *taskQueue) {
    //pthread_mutex_lock(&taskQueue->mutex);
    if (taskQueue == NULL || taskQueue->cnt == 0) {
        pthread_mutex_unlock(&taskQueue->mutex);
        return NULL;
    }
    int idx = taskQueue->head++;
    DBG(BLUE"<POP>"NONE "%s\n", taskQueue->data[taskQueue->head - 1]);
    if (taskQueue->head == taskQueue->size) taskQueue->head -= taskQueue->size;
    taskQueue->cnt -= 1;
    //pthread_cond_broadcast(&(taskQueue->cond);
    //pthread_mutex_unlock(&taskQueue->mutex);
    return taskQueue->data[idx];
}

void task_queue_clear(struct task_queue *taskQueue) {
    
    if (taskQueue == NULL) return ;
    free(taskQueue->data);
    free(taskQueue);
    return ;
}

void *thread_run(void *arg) {
    printf("thread_run ready\n");
    pthread_detach(pthread_self());
    struct task_queue *taskQueue = (struct task_queue *)arg;
    while (1) {
        pthread_mutex_lock(&taskQueue->mutex);
        if (taskQueue->cnt == 0)  {
            DBG(YELLOW"thread <%ld> "NONE" waiting\n", pthread_self());
            pthread_cond_wait(&(taskQueue->cond), &(taskQueue->mutex));
            //pause();
        }
        //DBG(BLUE"<run>"NONE"thread_run_lock\n");
        char *str = task_queue_pop(taskQueue);
        printf(RED"<%ld>"NONE"%s\n", pthread_self(), str);
        if (str != NULL) free(str);
        pthread_mutex_unlock(&taskQueue->mutex);
        //sleep(1);
    }
}

```

### 线程池-增删

```c
struct task_queue * task_queue_init(struct task_queue *taskQueue, int size) {
    taskQueue = (struct task_queue *)malloc(sizeof(struct task_queue));
    taskQueue->data = (char **)calloc(size, sizeof(void *));
    taskQueue->head = taskQueue->tail = 0;
    taskQueue->cnt = 0;
    taskQueue->size = size;
    DBG(BLUE"<init>"NONE "head = %d, tail = %d, cnt = %d, size = %d\n", taskQueue->head, taskQueue->tail ,taskQueue->cnt, taskQueue->size);

    if (pthread_mutex_init(&(taskQueue->mutex), NULL) != 0) {
        printf("mutex init error");
        return NULL;
    }
    if (pthread_cond_init(&(taskQueue->cond), NULL) != 0) {
        printf("cond init error");
        return NULL;
    }
    return taskQueue;
}

int task_queue_push(struct task_queue *taskQueue, char *str) {
    pthread_mutex_lock(&taskQueue->mutex);
    if (taskQueue == NULL)  {
        DBG(BLUE"<PUSH>"NONE " : NULL");
        pthread_mutex_unlock(&taskQueue->mutex);
        return -1;
    }
    if (taskQueue->cnt >= taskQueue->size) {
        DBG(BLUE"<PUSH Full>"NONE " : cnt = %d, size = %d\n", taskQueue->cnt, taskQueue->size);
        pthread_mutex_unlock(&taskQueue->mutex);
        return 0;
    } 
    //DBG(BLUE"<PUSH>"NONE " %s\n", str);
    taskQueue->data[taskQueue->tail] = str;
    taskQueue->tail++;
    DBG(BLUE"<PUSH>"NONE " : %s\n", taskQueue->data[taskQueue->tail - 1]);
    if (taskQueue->tail == taskQueue->size) taskQueue->tail = 0;
    taskQueue->cnt += 1;

    pthread_cond_signal(&(taskQueue->cond));
    pthread_mutex_unlock(&taskQueue->mutex);
    return 1;
}

char *task_queue_pop(struct task_queue *taskQueue) {
    pthread_mutex_lock(&taskQueue->mutex);
    if (taskQueue == NULL) {
        pthread_mutex_unlock(&taskQueue->mutex);
        return NULL;
    }

    DBG(BLUE"<POP>"NONE "in pop!");
    //惊群效应 while 而非 if
    while (taskQueue->cnt == 0) {
        DBG(YELLOW"thread <%ld> "NONE" waiting\n", pthread_self());
        pthread_cond_wait(&taskQueue->cond, &taskQueue->mutex);
    }
    char *str = taskQueue->data[taskQueue->head++];
    taskQueue->cnt -= 1;
    DBG(BLUE"<POP>"NONE "%s cnt = %d\n", str, taskQueue->cnt);
    if (taskQueue->head == taskQueue->size) taskQueue->head = 0;
    //pthread_cond_broadcast(&(taskQueue->cond);
    pthread_mutex_unlock(&taskQueue->mutex);
    return str;
}

void task_queue_clear(struct task_queue *taskQueue) {
    
    if (taskQueue == NULL) return ;
    free(taskQueue->data);
    free(taskQueue);
    return ;
}

void *thread_run(void *arg) {
    printf("thread_run ready\n");
    pthread_detach(pthread_self());
    struct task_queue *taskQueue = (struct task_queue *)arg;
    while (1) {
        //DBG(BLUE"<run>"NONE"thread_run_lock\n");
        char *str = task_queue_pop(taskQueue);
        printf(RED"<%ld>"NONE"%s\n", pthread_self(), str);
        //sleep(1);
    }
}
```



## 6.消息队列

1. 非亲缘通过key_t ftok(path, id);
2. 公共头文件key
3. 亲缘进程

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

struct msgbuf {
    long mtype;
    char mtext[80];
};

static void
usage(char *prog_name, char *msg)
{
    if (msg != NULL)
    fputs(msg, stderr);

    fprintf(stderr, "Usage: %s [options]\n", prog_name);
    fprintf(stderr, "Options are:\n");
    fprintf(stderr, "-s        send message using msgsnd()\n");
    fprintf(stderr, "-r        read message using msgrcv()\n");
    fprintf(stderr, "-t        message type (default is 1)\n");
    fprintf(stderr, "-k        message queue key (default is 1234)\n");
    exit(EXIT_FAILURE);
}

static void
send_msg(int qid, int msgtype)
{
    struct msgbuf msg;
    time_t t;

    msg.mtype = msgtype;

    time(&t);
    snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s",
             ctime(&t));

    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),
               IPC_NOWAIT) == -1) {
                   perror("msgsnd error");
                   exit(EXIT_FAILURE);
               }
    printf("sent: %s\n", msg.mtext);
}

static void
get_msg(int qid, int msgtype)
{
    struct msgbuf msg;

    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,
               MSG_NOERROR | IPC_NOWAIT) == -1) {
                   if (errno != ENOMSG) {
                       perror("msgrcv");
                       exit(EXIT_FAILURE);
                   }
                   printf("No message available for msgrcv()\n");
               } else
    printf("message received: %s\n", msg.mtext);
}

int
main(int argc, char *argv[])
{
    int qid, opt;
    int mode = 0;               /* 1 = send, 2 = receive */
    int msgtype = 1;
    int msgkey = 1234;

    while ((opt = getopt(argc, argv, "srt:k:")) != -1) {
        switch (opt) {
            case 's':
            mode = 1;
            break;
            case 'r':
            mode = 2;
            break;
            case 't':
            msgtype = atoi(optarg);
            if (msgtype <= 0)
            usage(argv[0], "-t option must be greater than 0\n");
            break;
            case 'k':
            msgkey = atoi(optarg);
            break;
            default:
            usage(argv[0], "Unrecognized option\n");
        }
    }

    if (mode == 0)
    usage(argv[0], "must use either -s or -r option\n");

    qid = msgget(msgkey, IPC_CREAT | 0666);

    if (qid == -1) {
        perror("msgget");
        exit(EXIT_FAILURE);
    }

    if (mode == 2)
    get_msg(qid, msgtype);
    else
    send_msg(qid, msgtype);

    exit(EXIT_SUCCESS);
}

```





## 7.信号量PV操作

信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问，分为两种POSIX信号量和SystemV信号量

### POSIX信号量

* 有名信号量，用于进程间同步
* 无名信号量，用于线程间同步
  * posix信号量一般是单个计量信号，全程操作一个信号量 

### SystemV信号量，用于进程间同步

* 进程中使用共享内存实现进程间通信，但他并不是线程安全的，需要通过信号量进行同步
* 一般说的systemV信号量是计量信号集，可以使用多个信号量进行同步

* API
  * `int semget(key_t key, int nsems, int semflag);` 

## 

POSIX 信号量与SYSTEM V信号量的比较
对POSIX来说，信号量是个非负整数。常用于线程间同步。
而SYSTEM V信号量则是一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为SYSTEM V IPC服务的，信号量只不过是它的一部分。常用于进程间同步。

POSIX信号量的引用头文件是`<semaphore.h>`，而SYSTEM V信号量的引用头文件是`<sys/sem.h>`

从使用的角度，System V信号量是复杂的，而Posix信号量是简单。比如，POSIX信号量的创建和初始化或PV操作就很非常方便。




原子:不可再分

银行家算法

读写者问题

生产者消费者问题

PV操作自带锁





#### 管道与共享内存的区别

- 管道需要在内核和用户空间进行四次的数据拷贝：由用户空间的buf中将数据拷贝到内核中 -> 内核将数据拷贝到内存中 -> 内存到内核 -> 内核到用户空间的buf。而共享内存则只拷贝两次数据：用户空间到内存 -> 内存到用户空间。
- 管道用循环队列实现，连续传送数据可以不限大小。共享内存每次传递数据大小是固定的；
- 共享内存可以随机访问被映射文件的任意位置，管道只能顺序读写；
  管道可以独立完成数据的传递和通知机制，共享内存需要借助其他通讯方式进行消息传递。

也就是说，两者之间最大的区别就是： 共享内存区是最快的可用IPC形式，一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递，就不再通过执行任何进入内核的系统调用来传递彼此的数据，节省了时间。

 

## 匿名管道

匿名管道是在具有公共祖先的进程之间进行通信的一种方式。

前面在介绍进程的创建时讲到，由父进程创建的子进程将会赋值父进程包括文件在内的一些资源。如果父进程创建子进程之前创建了一个文件，那么这个文件的描述符就会被父进程在随后所创建的子进程所共享。也就是说，父、子进程可以通过这个文件进行通信。如果通信的双方一方只能进行读操作，而另一方只能进行写操作，那么这个文件就是一个只能单方向传送消息的管道，如下图所示：

![img](/Image/D4.进程间通信-photo/20180810212327500)

进程可以通过调用函数pipe()创建一个管道。函数pipe()的原型如下：

```c
int pipe(int fildes[2]);
与该函数pipe()相对应的系统调用sys_pipe()的原型如下：

asmlinkage int sys_pipe(unsigned long __user * fildes);
```




从本质上来说，pipe()函数的功能就是创建一个内存文件，但与创建普通文件的函数不同，函数pipe()将在参数fildes中为进程返回这个文件的两个文件描述符fildes[0]和fildes[1]。其中，fildes[0]是一个具有“只读”属性的文件描述符，fildes[1]是一个具有“只写”属性的文件描述符，即进程通过fildes[0]只能进行文件的读操作，而通过fildes[1]只能进行文件的写操作。

这样，就使得这个文件像一段只能单向流通的管道一样，一头专门用来输入数据，另一头专门用来输出数据，所以称为管道。由于这种文件没有文件名，不能被非亲进程所打开，只能用于亲属进程间的通信，所以这种没有名称的文件形成的通信管道叫做“匿名管道”。

显然，如果父进程创建的这种文件只是用来通信，那么它感兴趣的只是该文件所占用的内存空间，所以也就没有必要创建一个正式文件，只需创建一个只存在于内存的临时文件。从这一点来看，匿名管道与共享内存具有共同点，只不过匿名管道时单向通信，而且这个通信只能在亲属进程间进行。

为支持匿名管道，内核初始化时由内核函数kernel_mount()安装了一种特殊的文件系统，在该系统中所创建的都是临时文件。

管道实质上就是一个被当做文件来管理的内存缓冲区



![img](/Image/D4.进程间通信-photo/20180810220951114)

![img](/Image/D4.进程间通信-photo/20180810221346372)

**在确定管道的传输方向之后，在父进程中关闭（close()）文件描述符fildes[0]，在子进程中关闭（close()）文件描述符fildes[1]，于是管道的连接情况就变成如下情况的单向传输管道：**

![img](/Image/D4.进程间通信-photo/2018081022321045)



匿名管道具有如下特点：

- 由于这种管道没有其他同步措施，所以为了不产生混乱，它只能是半双工的，即数据只能向一个方向流动。如果需要双方互相传递数据，则需要建立两个管道；
- 只能在父子进程或兄弟进程这些具有亲缘关系的进程之间进行通信；
  匿名管道对于管道两端的进程而言，就是一个只存在于内存的特殊文件；
- 一个进程向管道中写的内容被管道另一端的进程读取。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读取数据。

匿名管道的局限性主要有两点：**一是由于管道建立在内存中，所以它的容量不可能很大；二是管道所传送的是无格式字节流，这就要求使用管道的双方实现必须对传输的数据格式进行约定。**

**命名管道是在实际文件系统上实现的一种通信机制。由于它是一个与进程没有“血缘关系”的、真正且独立的文件，所以它可以在任意进程之间实现通信。由于命名管道不支持诸如lseek()等文件定位操作，严格遵守先进先出的原则进行传输数据，即对管道的读总是从开始处返回数据，对它的写总是把数据添加到末尾，所以这种管道也叫做FIFO文件**




### 存储映射与mmap

epoll模型底层是mmap和红黑树

mmap减少从内核态到用户态的拷贝

页是内存分配的基本单位

![image-20210323082353719](/Image/D4.进程间通信-photo/image-20210323082353719.png)

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    char *addr; //被映射区的指针
    int fd;
    struct stat sb;  //记录文件信息的结构体
    off_t offset, pa_offset; //
    size_t length; //读取长度
    ssize_t s;

    if (argc < 3 || argc > 4) {
        fprintf(stderr, "%s file offset [length]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    fd = open(argv[1], O_RDONLY);
    if (fd == -1)
        handle_error("open");

    if (fstat(fd, &sb) == -1)           /* To obtain file size */
        handle_error("fstat");

    offset = atoi(argv[2]);
 
    //mmap（）的偏移量必须页面对齐
    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
        /* offset for mmap() must be page aligned */
//最接近PAGE_SIZE的倍数
    if (offset >= sb.st_size) {
        fprintf(stderr, "offset is past end of file\n");
        exit(EXIT_FAILURE);
    }

    if (argc == 4) {
        length = atoi(argv[3]);
        if (offset + length > sb.st_size)
            length = sb.st_size - offset;
                /* Can't display bytes past end of file */

    } else {    /* No length arg ==> display to end of file */
        length = sb.st_size - offset;
    }
 //start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。
    //length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理
	//prot：期望的内存保护标志:PROT_READ //页内容可以被读取
    //MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥
    //off_toffset：被映射对象内容的起点，偏移量必须是页面大小的倍数
   
    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                MAP_PRIVATE, fd, pa_offset);
    if (addr == MAP_FAILED)
        handle_error("mmap");

    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);
    if (s != length) {
        if (s == -1)
            handle_error("write");

        fprintf(stderr, "partial write");
        exit(EXIT_FAILURE);
    }
	//该调用在进程地址空间中解除一个映射关系,写回
    munmap(addr, length + offset - pa_offset);
    close(fd);

    exit(EXIT_SUCCESS);
}

```



## 进程和线程



```shell
ulimit -a                                                                         [0]
-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       31153
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  16384
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 31153
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited

```



进程有很多类似的地方，人们习惯上把线程称为轻量级进程，这个所谓的轻量级是指线程并不拥有自己的系统资源，线程依附于创建自己的进程。

我们可以从l两个个方面来理解线程的轻量级

\1. 调度

由于进程之间的线程共享同一个进程地址空间，因此在进程的线程之间做进程切换，并不会引起进程地址空间的切换，从而避免了昂贵的进程切换。当然不同进程组之间是需要进程切换的



\2. 拥有资源

进程是操作系统中拥有资源的独立单位，在创建和撤销进程时，操作系统都会为进程分配和回收资源，资源包括地址空间，文件，IO，页表等。但是由于线程是依附与创建进程的，线程的代码段，数据段，打开文件，IO资源，地址空间，页表等都是和进程的所有线程共享的。



从上面我们看出线程并没有独立的地址空间，这就意味着隶属同一进程的所有线程栈，都在所属进程的地址空间中，他们的栈地址不同，但是如果操作栈时发生越界，是有可能破坏其他线程的栈空间的。

而进程实际上可以看作是主线程，它的栈和其它线程栈没有区别。



单线程只有一个栈，多线程则为每个线程都分配一个栈，并且这些栈的地址不同，可以通过如下方法验证这个结论

\1. pslist输出系统进程以及他们的线程，在我的机器上得到如下结果



```html
1889 gnome-session 1918 1926 1940 1969 1957 2282 2283 1971 1972 1973 1975 1998 2003 2010 2669 2691 2710 2776 2871
```



1889是主线程，后面是这个进程创建的线程

\2. 对每一个线程ID执行，cat /proc/threadID/maps

可以看到没个线程的stack地址范围各不相同，这也从侧面验证了每个线程的栈地址在同一进程地址空间的不同地址范围内。

一般意义上，线程是执行的单位，进程是资源分配的单位，两者的本质区别在于此
