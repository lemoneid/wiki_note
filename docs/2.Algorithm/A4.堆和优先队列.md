---
id : A4.å †å’Œä¼˜å…ˆé˜Ÿåˆ—
title : A4.å †å’Œä¼˜å…ˆé˜Ÿåˆ—
typora-root-url : ../
---



# å †å’Œä¼˜å…ˆé˜Ÿåˆ—

## æœ€å¤§å †å’Œæœ€å°å †

ä¼˜å…ˆçº§é˜Ÿåˆ—é«˜æ•ˆçš„åŸå› ä¸»è¦åŸå› åœ¨äºå…¶ä¸éœ€è¦ç»´æŠ¤ä¸€ä¸ªå…¨åºå…³ç³»ï¼Œä»…ä»…éœ€è¦ç»´æŠ¤ä¸€ååºå…³ç³»ã€‚å®Œå…¨äºŒå‰å †æ˜¯ä¼˜å…ˆçº§é˜Ÿåˆ—çš„ä¸€ç§å®ç°ã€‚ 

å †æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œæ ¹æ®ç»“ç‚¹å’Œå·¦å³å­©å­çš„å¤§å°å…³ç³»ï¼Œåˆ†ä¸ºæœ€å¤§å †å’Œæœ€å°å †

- æœ€å¤§å †
  - æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½å¤§äºæˆ–ç­‰äºå…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼
- æœ€å°å †
  - æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½å°äºæˆ–ç­‰äºå…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼

### åº•å±‚è¡¨ç¤º

å®Œå…¨äºŒå‰å †çš„åº•å±‚å®ç°æ–¹å¼æ˜¯ä¸€ä¸ª`vector`ã€‚åº•å±‚å€ŸåŠ©`vector`ä½¿ç”¨`O(n)`çš„ç´§å‡‘ç©ºé—´è¡¨ç¤ºï¼šå®Œå…¨äºŒå‰æ ‘ä»å·¦åˆ°å³å±‚çš„æ¬¡éå†æ¬¡åºå’Œ`vector`çš„å…ƒç´ å†…å®¹ä¸€ä¸€å¯¹åº”ã€‚



## ä¼˜å…ˆé˜Ÿåˆ—

### å®ç°

```c
/*************************************************************************
    > File Name: 9.priority_queue.cpp
    > Author:
    > Mail:
    > Created Time: äºŒ  2/18 16:31:07 2020
 ************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {
    return q->data[1];
}

int push(priority_queue *q, int val) {
    if (q == NULL) return 0;
    if (q->cnt == q->size) return 0;
    q->cnt += 1;
    q->data[q->cnt] = val;
    int ind = q->cnt;
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
        swap(q->data[ind], q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}

int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        if (temp == ind) break;
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to queue\n", val);
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    clear(q);
    return 0;
}
```

## ==çº¿æ€§å»ºå †æ³•==

`Floydç®—æ³•`ï¼šè‡ªä¸‹è€Œä¸Šçš„ä¸‹æ»¤  

`Floyd`ç®—æ³•ï¼Œæ˜¯ä»åº•å±‚å¼€å§‹ï¼šå¯¹äºå † ***`H0,H1`*** ä»¥åŠç»™å®šçš„é¡¶ç‚¹`p` ï¼Œåˆå¹¶ä¸€ä¸ªæ›´é«˜çš„å †ã€‚ è¿™ä¸ªæ“ä½œç±»ä¼¼äº `deleteMax`, åªæ˜¯éœ€è¦å°†`p`è¿›è¡Œä¸‹æ»¤æ“ä½œå³å¯ã€‚æœ€åˆ ***`H0,H1`*** å°±æ˜¯å¶èŠ‚ç‚¹ï¼Œç»è¿‡ä¸æ–­åœ°åˆå¹¶ï¼Œæœ€ç»ˆå˜æˆä¸€ä¸ªå®Œå…¨äºŒå‰å †ã€‚

## å †æ’åº

### å®ç°

```cpp
/*************************************************************************
    > File Name: 10.heap_sort.cpp
    > Author:
    > Mail:
    > Created Time: äºŒ  2/18 19:24:12 2020
 ************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i >= 1; i--) {
        downUpdate(arr, n, i);
    }
    for (int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);
    }
    return ;
}

void output(int *arr, int n) {
    printf("arr(%d) = [", n);
    for (int i = 0; i < n; i++) {
        printf(" %d", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int *arr = (int *)malloc(sizeof(int) * max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        arr[i] = val;
    }
    output(arr, max_op);
    heap_sort(arr, max_op);
    output(arr, max_op);
    free(arr);
    return 0;
}
```





![image-20201008200910691](/Image/A4.å †å’Œä¼˜å…ˆé˜Ÿåˆ—-photo/image-20201008200910691.png)



#### POJ2431.è¿œå¾

> ä½ éœ€è¦é©¾é©¶ä¸€è¾†å¡è½¦è¡Œé©¶ Lå•ä½è·ç¦»ã€‚æœ€å¼€å§‹æ—¶ ï¼Œå¡è½¦ä¸Šæœ‰ P å•ä½çš„æ±½æ²¹ ã€‚å¡è½¦æ¯å¼€ 1 å•ä½è·ç¦»éœ€è¦æ¶ˆè€— 1 å•ä½çš„æ±½æ²¹ ã€‚å¦‚æœåœ¨é€”ä¸­è½¦ä¸Šçš„æ±½æ²¹è€—å°½ï¼Œå¡è½¦å°±æ— æ³•ç»§ç»­å‰è¡Œï¼Œå›  è€Œæ— æ³•åˆ°è¾¾ç»ˆç‚¹ã€‚ åœ¨é€”ä¸­ä¸€å…±æœ‰ N ä¸ª åŠ æ²¹ç«™ ã€‚ç¬¬ i ä¸ªåŠ æ²¹ç«™åœ¨è·ç¦»èµ·ç‚¹ $A_i$ å•ä½è·ç¦»çš„åœ°æ–¹ ï¼Œæœ€å¤šå¯ä»¥ç»™å¡è½¦åŠ  $B_i$ å•ä½æ±½æ²¹ã€‚å‡è®¾å¡è½¦çš„ç‡ƒæ–™ç®±çš„å®¹é‡æ˜¯æ— é™å¤§çš„ ï¼Œæ— è®ºåŠ å¤šå°‘æ²¹éƒ½æ²¡æœ‰é—®é¢˜ ï¼Œé‚£ä¹ˆè¯·é—®å¡è½¦æ˜¯å¦èƒ½åˆ°è¾¾ç»ˆç‚¹ï¼Ÿ å¦‚ æœå¯ä»¥ ï¼Œæœ€å°‘éœ€è¦åŠ å¤šå°‘æ¬¡æ²¹ï¼Ÿ å¦‚æœå¯ ä»¥åˆ°è¾¾ç»ˆç‚¹ï¼Œè¾“å‡ºæœ€å°‘çš„åŠ æ²¹æ¬¡æ•° ï¼Œå¦åˆ™è¾“å‡º -1ã€‚

å˜æ¢ä¸€ä¸‹æ€è€ƒæ–¹å¼ã€‚åœ¨å¡è½¦å¼€å¾€ç»ˆç‚¹çš„é€”ä¸­ ï¼Œåªæœ‰åœ¨åŠ æ²¹ç«™æ‰å¯ä»¥åŠ æ²¹ã€‚ä½†æ˜¯ï¼Œå¦‚æœè®¤
ä¸ºâ€œåœ¨åˆ°è¾¾åŠ æ²¹ç«™â€œ æ—¶ï¼Œå°±è·å¾—äº†ä¸€æ¬¡åœ¨ä¹‹åçš„ä»»ä½•æ—¶å€™éƒ½å¯ä»¥åŠ æ±½æ²¹çš„æƒåˆ© 

å› ä¸ºå¸Œæœ›åˆ°è¾¾ç»ˆç‚¹æ—¶åŠ æ²¹æ¬¡æ•°å°½å¯èƒ½å°‘ï¼Œä»å¤§åˆ°å°çš„é¡ºåºä¾æ¬¡å–å‡ºæ•°å€¼çš„ä¼˜å…ˆé˜Ÿåˆ—

1. åœ¨ç»è¿‡åŠ æ²¹ç«™ $A_i$ æ—¶ ï¼Œå¾€ä¼˜å…ˆé˜Ÿåˆ—é‡ŒåŠ äºº$B_i$
2. å½“ç‡ƒæ–™ç®±ç©ºäº†æ—¶ï¼Œ
   - å¦‚æœä¼˜å…ˆé˜Ÿåˆ—ä¹Ÿæ˜¯ç©ºçš„ ï¼Œåˆ™æ— æ³•åˆ°è¾¾ç»ˆç‚¹ã€‚
   - å¦åˆ™ å–å‡ºä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€å¤§å…ƒç´  ï¼Œå¹¶ç”¨æ¥ç»™å¡è½¦åŠ æ²¹ã€‚



```cpp
typedef pair<int, int> PII;
vector<PII> arr;
int l, p, n;

bool cmp(const PII &a, const PII &b) {
    return a.first < b.first;
}

int solve() {
    arr[0].first = arr[0].second = 0;
    sort(arr.begin(), arr.end(), cmp);
    priority_queue<int> que;
    int ans = 0, pos = l, tank = p;
    for (int i = n; i >= 0 ; i--){
        int d = pos - arr[i].first;
        while (tank < d) {
            if (que.empty()) {
                return -1;
            }
            tank += que.top();
            que.pop();
            ans++;
        }
        tank -= d;
        pos = arr[i].first;
        que.push(arr[i].second);
    }
    return ans;
}
```



#### [218.å¤©é™…çº¿é—®é¢˜](https://leetcode-cn.com/problems/the-skyline-problem/description/)

> åŸå¸‚çš„å¤©é™…çº¿æ˜¯ä»è¿œå¤„è§‚çœ‹è¯¥åŸå¸‚ä¸­æ‰€æœ‰å»ºç­‘ç‰©å½¢æˆçš„è½®å»“çš„å¤–éƒ¨è½®å»“ã€‚ç»™ä½ æ‰€æœ‰å»ºç­‘ç‰©çš„ä½ç½®å’Œé«˜åº¦ï¼Œè¯·è¿”å›ç”±è¿™äº›å»ºç­‘ç‰©å½¢æˆçš„ **å¤©é™…çº¿** ã€‚
>
> æ¯ä¸ªå»ºç­‘ç‰©çš„å‡ ä½•ä¿¡æ¯ç”±æ•°ç»„ `buildings` è¡¨ç¤ºï¼Œå…¶ä¸­ä¸‰å…ƒç»„ `buildings[i] = [lefti, righti, heighti]` è¡¨ç¤ºï¼š
>
> - `lefti` æ˜¯ç¬¬ `i` åº§å»ºç­‘ç‰©å·¦è¾¹ç¼˜çš„ `x` åæ ‡ã€‚
> - `righti` æ˜¯ç¬¬ `i` åº§å»ºç­‘ç‰©å³è¾¹ç¼˜çš„ `x` åæ ‡ã€‚
> - `heighti` æ˜¯ç¬¬ `i` åº§å»ºç­‘ç‰©çš„é«˜åº¦ã€‚
>
> **å¤©é™…çº¿** åº”è¯¥è¡¨ç¤ºä¸ºç”± â€œå…³é”®ç‚¹â€ ç»„æˆçš„åˆ—è¡¨ï¼Œæ ¼å¼ `[[x1,y1],[x2,y2],...]` ï¼Œå¹¶æŒ‰ **x åæ ‡** è¿›è¡Œ **æ’åº** ã€‚**å…³é”®ç‚¹æ˜¯æ°´å¹³çº¿æ®µçš„å·¦ç«¯ç‚¹**ã€‚åˆ—è¡¨ä¸­æœ€åä¸€ä¸ªç‚¹æ˜¯æœ€å³ä¾§å»ºç­‘ç‰©çš„ç»ˆç‚¹ï¼Œ`y` åæ ‡å§‹ç»ˆä¸º `0` ï¼Œä»…ç”¨äºæ ‡è®°å¤©é™…çº¿çš„ç»ˆç‚¹ã€‚æ­¤å¤–ï¼Œä»»ä½•ä¸¤ä¸ªç›¸é‚»å»ºç­‘ç‰©ä¹‹é—´çš„åœ°é¢éƒ½åº”è¢«è§†ä¸ºå¤©é™…çº¿è½®å»“çš„ä¸€éƒ¨åˆ†ã€‚
>
> **æ³¨æ„ï¼š**è¾“å‡ºå¤©é™…çº¿ä¸­ä¸å¾—æœ‰è¿ç»­çš„ç›¸åŒé«˜åº¦çš„æ°´å¹³çº¿ã€‚ä¾‹å¦‚ `[...[2 3], [4 5], [7 5], [11 5], [12 7]...]` æ˜¯ä¸æ­£ç¡®çš„ç­”æ¡ˆï¼›ä¸‰æ¡é«˜åº¦ä¸º 5 çš„çº¿åº”è¯¥åœ¨æœ€ç»ˆè¾“å‡ºä¸­åˆå¹¶ä¸ºä¸€ä¸ªï¼š`[...[2 3], [4 5], [12 7], ...]`
>
> 
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ![img](https://assets.leetcode.com/uploads/2020/12/01/merged.jpg)
>
> ```cpp
> è¾“å…¥ï¼šbuildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]
> è¾“å‡ºï¼š[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]
> è§£é‡Šï¼š
> å›¾ A æ˜¾ç¤ºè¾“å…¥çš„æ‰€æœ‰å»ºç­‘ç‰©çš„ä½ç½®å’Œé«˜åº¦ï¼Œ
> å›¾ B æ˜¾ç¤ºç”±è¿™äº›å»ºç­‘ç‰©å½¢æˆçš„å¤©é™…çº¿ã€‚å›¾ B ä¸­çš„çº¢ç‚¹è¡¨ç¤ºè¾“å‡ºåˆ—è¡¨ä¸­çš„å…³é”®ç‚¹ã€‚
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```cpp
> è¾“å…¥ï¼šbuildings = [[0,2,3],[2,5,3]]
> è¾“å‡ºï¼š[[0,3],[5,0]]
> ```



ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å‚¨å­˜æ¯ä¸ªå»ºç­‘ç‰©çš„é«˜åº¦å’Œå³ç«¯ï¼ˆè¿™é‡Œä½¿ç”¨ pairï¼Œå…¶é»˜è®¤æ¯”è¾ƒå‡½æ•°æ˜¯å…ˆæ¯”è¾ƒç¬¬ä¸€ä¸ªå€¼ï¼Œå¦‚æœç›¸ç­‰åˆ™å†æ¯”è¾ƒç¬¬äºŒä¸ªå€¼ï¼‰ï¼Œä»è€Œè·å–ç›®å‰ä¼šæ‹”é«˜å¤©é™…çº¿ã€ä¸”å¦¨ç¢åˆ°å‰ä¸€ä¸ªå»ºç­‘ç‰©ï¼ˆçš„å³ç«¯ç«¯ç‚¹ï¼‰çš„ä¸‹ä¸€ä¸ªå»ºç­‘ç‰©ã€‚

```cpp
 class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> ans;
        priority_queue<pair<int, int>> max_heap;
        int i = 0, size = buildings.size();
        int cur_x, cur_h;
        while (i < size || !max_heap.empty()) {
            if (max_heap.empty()
                ||i < size 
                && buildings[i][0] <= max_heap.top().second) {
                cur_x = buildings[i][0];
                while (i < size && cur_x == buildings[i][0]) {
                    max_heap.emplace(buildings[i][2], buildings[i][1]);
                    ++i;
                }
            } else {
                cur_x = max_heap.top().second;
                while (!max_heap.empty() && cur_x >= max_heap.top().second) {
                    max_heap.pop(); 
                }
            }
            cur_h = (max_heap.empty() ? 0 : max_heap.top().first);
            if (ans.empty() || cur_h != ans.back()[1]) {
                ans.push_back({cur_x, cur_h});
            }
        }
        return ans;
    }
};
```



#### [LC-703. æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

è®¾è®¡ä¸€ä¸ªæ‰¾åˆ°æ•°æ®æµä¸­ç¬¬Kå¤§å…ƒç´ çš„ç±»ï¼ˆclassï¼‰ã€‚æ³¨æ„æ˜¯æ’åºåçš„ç¬¬Kå¤§å…ƒç´ ï¼Œä¸æ˜¯ç¬¬Kä¸ªä¸åŒçš„å…ƒç´ ã€‚

ä½ çš„ KthLargest ç±»éœ€è¦ä¸€ä¸ªåŒæ—¶æ¥æ”¶æ•´æ•° k å’Œæ•´æ•°æ•°ç»„nums çš„æ„é€ å™¨ï¼Œå®ƒåŒ…å«æ•°æ®æµä¸­çš„åˆå§‹å…ƒç´ ã€‚æ¯æ¬¡è°ƒç”¨ KthLargest.addï¼Œè¿”å›å½“å‰æ•°æ®æµä¸­ç¬¬Kå¤§çš„å…ƒç´ ã€‚

ç¤ºä¾‹:

int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8

```c
#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

typedef struct {
    int *data;
    int cnt, size;
} KthLargest;

void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] < arr[temp]) temp = l;
        if (r <= n && arr[r] < arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void upUpdate(int *arr, int ind) {
    while (ind >> 1) {
        if (arr[ind] >= arr[ind >> 1]) break;
        swap(arr[ind], arr[ind >> 1]);
        ind >>= 1;
    }
    return ;
}

int kthLargestAdd(KthLargest*, int);
KthLargest* kthLargestCreate(int k, int* nums, int numsSize) {
    KthLargest *p = (KthLargest *)malloc(sizeof(KthLargest));
    p->data = (int *)malloc(sizeof(int) * (k + 1));
    p->size = k;
    p->cnt = k - 1;
    memcpy(p->data + 1, nums, sizeof(int) * (k - 1));
    for (int i = (k - 1) >> 1; i >= 1; --i) {
        downUpdate(p->data, k - 1, i);
    }
    for (int i = k - 1; i < numsSize; i++) {
        kthLargestAdd(p, nums[i]);
    }
    return p;
}

int kthLargestAdd(KthLargest* obj, int val) {
    if (obj->cnt == obj->size) {
        if (val > obj->data[1]) {
            obj->data[1] = val;
            downUpdate(obj->data, obj->size, 1);
        }
    } else {
        obj->cnt += 1;
        obj->data[obj->cnt] = val;
        upUpdate(obj->data, obj->cnt);
    }
    return obj->data[1];
}

void kthLargestFree(KthLargest* obj) {
    if (obj == NULL) return ;
    free(obj->data);
    free(obj);
    return ;
}
```



#### [295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/find-median-from-data-stream/)

å¦‚æœæˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼ç»´æŠ¤ä¸¤ä¸ªå †ï¼š

1. ç”¨äºå­˜å‚¨è¾“å…¥æ•°å­—ä¸­è¾ƒå°ä¸€åŠçš„æœ€å¤§å †
2. ç”¨äºå­˜å‚¨è¾“å…¥æ•°å­—çš„è¾ƒå¤§ä¸€åŠçš„æœ€å°å †

è¿™æ ·å°±å¯ä»¥è®¿é—®è¾“å…¥ä¸­çš„ä¸­å€¼ï¼šå®ƒä»¬ç»„æˆå †çš„é¡¶éƒ¨ï¼

```c
typedef struct Heap {
    int *data;
    int n, size;
} Heap;

void expandHeap(Heap *h) {
    h->data = realloc(h->data, 2 * h->size * sizeof(int));
    h->size *= 2;
    return ;
}

#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

#define pushHeap(h, val, comp) { \
    if (h->size == h->n + 1) { \
        expandHeap(h); \
    } \
    h->data[++(h->n)] = val; \
    int ind = h->n; \
    while (ind != 1 && h->data[ind] comp h->data[ind >> 1]) { \
        swap(h->data[ind], h->data[ind >> 1]); \
        ind >>= 1; \
    } \
}

#define popHeap(h, comp) do { \
    if (h->n == 0) break; \
    h->data[1] = h->data[(h->n)--]; \
    int ind = 1; \
    while (ind << 1 <= h->n) { \
        int temp = ind, l = ind << 1, r = ind << 1 | 1; \
        if (h->data[l] comp h->data[temp]) temp = l; \
        if (r <= h->n && h->data[r] comp h->data[temp]) temp = r; \
        if (temp == ind) break; \
        swap(h->data[temp], h->data[ind]); \
        ind = temp; \
    } \
} while(0);

Heap *creatHeap() {
    Heap *h = (Heap *)malloc(sizeof(Heap));
    h->size = 100;
    h->data = (int *)malloc(sizeof(int) * h->size);
    h->n = 0;
    return h;
}

void clearHeap(Heap *h) {
    if (h == NULL) return ;
    free(h->data);
    free(h);
    return ;
}

typedef struct {
    Heap *min_heap, *max_heap;
} MedianFinder;

/** initialize your data structure here. */

MedianFinder* medianFinderCreate() {
    MedianFinder* m = (MedianFinder*)malloc(sizeof(MedianFinder));
    m->min_heap = creatHeap();
    m->max_heap = creatHeap();
    return m;
}

void medianFinderAddNum(MedianFinder* m, int num) {
    if (m->min_heap->n == 0 || num >= m->min_heap->data[1]) {
        pushHeap(m->min_heap, num, <);
    } else {
        pushHeap(m->max_heap, num, >);
    }
    if (m->min_heap->n - m->max_heap->n == 2) {
        pushHeap(m->max_heap, m->min_heap->data[1], >);
        popHeap(m->min_heap, <);
    }
    if (m->max_heap->n - m->min_heap->n == 2) {
        pushHeap(m->min_heap, m->max_heap->data[1], <);
        popHeap(m->max_heap, >);
    }
    return ;
}

double medianFinderFindMedian(MedianFinder* m) {
    switch (m->min_heap->n - m->max_heap->n) {
        case -1: return m->max_heap->data[1];
        case 0: return 1.0 * (m->min_heap->data[1] + m->max_heap->data[1]) / 2.0;
        case 1: return m->min_heap->data[1];
    }
    return 0.0;
}

void medianFinderFree(MedianFinder* obj) {
    if (obj == NULL) return ;
    clearHeap(obj->min_heap);
    clearHeap(obj->max_heap);
    free(obj);
    return ;
}
```

#### LC-264 [ä¸‘æ•° II](https://leetcode-cn.com/problems/ugly-number-ii/description/)

> ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºç¬¬ `n` ä¸ªä¸‘æ•°ã€‚
>
> ä¸‘æ•°å°±æ˜¯è´¨å› æ•°åªåŒ…å« `2, 3, 5` çš„**æ­£æ•´æ•°**ã€‚

2.ä¼˜å…ˆé˜Ÿåˆ— (å°é¡¶å †)
ä¼˜å…ˆé˜Ÿåˆ—/å°é¡¶å †/å¤§é¡¶å †
åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—æœ‰è‡ªåŠ¨æ’åºçš„åŠŸèƒ½
æ¯æ¬¡å–å‡ºé˜Ÿå¤´å…ƒç´ ï¼Œå­˜å…¥é˜Ÿå¤´å…ƒç´ *2ã€é˜Ÿå¤´å…ƒç´ *3ã€é˜Ÿå¤´å…ƒç´ *5
ä½†æ³¨æ„ï¼Œåƒ 12 è¿™ä¸ªå…ƒç´ ï¼Œå¯ç”± 4 ä¹˜ 3 å¾—åˆ°ï¼Œä¹Ÿå¯ç”± 6 ä¹˜ 2 å¾—åˆ°ï¼Œæ‰€ä»¥è¦æ³¨æ„å»é‡
è¿˜å¯ä»¥æ›´è¿›ä¸€æ­¥é‡‡ç”¨ set æ¥è¯†åˆ«æœ‰æ— é‡å¤

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue <double,vector<double>,greater<double> > q;
        set<int> s;
        s.insert(1);
        vector<int> mask({2,3,5});
        double answer=1;
        for (int i=1;i<n;++i)
        {
            for (int &j:mask)
                if (s.count(answer*j)==0)
                {
                    q.push(answer*j);
                    s.insert(answer*j);
                }
            answer=q.top();
            q.pop();
        }
        return answer;
    }
};

```

3.åŠ¨æ€è§„åˆ’ (ä¸‰æŒ‡é’ˆ)
æˆ‘ä»¬å…ˆæ¨¡æ‹Ÿæ‰‹å†™ä¸‘æ•°çš„è¿‡ç¨‹
1 æ‰“å¤´ï¼Œ1 ä¹˜ 2 1 ä¹˜ 3 1 ä¹˜ 5ï¼Œç°åœ¨æ˜¯ {1,2,3,5}
è½®åˆ° 2ï¼Œ2 ä¹˜ 2 2 ä¹˜ 3 2 ä¹˜ 5ï¼Œç°åœ¨æ˜¯ {1,2,3,4,5,6,10}
æ‰‹å†™çš„è¿‡ç¨‹å’Œé‡‡ç”¨å°é¡¶å †çš„æ–¹æ³•å¾ˆåƒï¼Œä½†æ˜¯æ€ä¹ˆåšåˆ°æå‰æ’åºå‘¢

å°é¡¶å †çš„æ–¹æ³•æ˜¯å…ˆå­˜å†æ’ï¼Œdp çš„æ–¹æ³•åˆ™æ˜¯å…ˆæ’å†å­˜
æˆ‘ä»¬è®¾ 3 ä¸ªæŒ‡é’ˆ p_2,p_3,p_5
ä»£è¡¨çš„æ˜¯ç¬¬å‡ ä¸ªæ•°çš„2å€ã€ç¬¬å‡ ä¸ªæ•° 3 å€ã€ç¬¬å‡ ä¸ªæ•° 5 å€
åŠ¨æ€æ–¹ç¨‹ dp[i]=min(dp[p_2]*2,dp[p_3]*3,dp[p_5]*5)
å°é¡¶å †æ˜¯ä¸€ä¸ªå…ƒç´ å‡ºæ¥ç„¶åå­˜ 3 ä¸ªå…ƒç´ 
åŠ¨æ€è§„åˆ’åˆ™æ˜¯æ ‡è¯† 3 ä¸ªå…ƒç´ ï¼Œé€šè¿‡æ¯”è¾ƒä»–ä»¬çš„ 2 å€ã€3 å€ã€5 å€çš„å¤§å°ï¼Œæ¥ä¸€ä¸ªä¸€ä¸ªå­˜

```cpp
        int t1 = 0, t2 = 0, t3 = 0;
        vector<int> k(n);
        k[0] = 1;
        for (int i = 1; i < n; ++i) {
            int f1 = k[t1] * 2, f2 = k[t2] * 3, f3 = k[t3] * 5;
            k[i] = min(f1, min(f2, f3));
            if (k[i] == f1) t1++;
            if (k[i] == f2) t2++;
            if (k[i] == f3) t3++;
        }
        return k[n - 1];
```

#### LC-23 [åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

1. åˆ†æ²»åˆå¹¶

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return merge(lists, 0, lists.size() - 1);
    }
private :
    ListNode* merge(vector<ListNode*>& lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode dummy, *p = &dummy;
        dummy.next = nullptr;
        while (l1 || l2) {
            if (!l2 || l1 && l1->val < l2->val) {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            } else {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        return dummy.next;
    }
};
```

2. ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—åˆå¹¶

   éœ€è¦ç»´æŠ¤å½“å‰æ¯ä¸ªé“¾è¡¨æ²¡æœ‰è¢«åˆå¹¶çš„å…ƒç´ çš„æœ€å‰é¢ä¸€ä¸ªï¼Œkä¸ªé“¾è¡¨å°±æœ€å¤šæœ‰ kä¸ªæ»¡è¶³è¿™æ ·æ¡ä»¶çš„å…ƒç´ ï¼Œæ¯æ¬¡åœ¨è¿™äº›å…ƒç´ é‡Œé¢é€‰å– val å±æ€§æœ€å°çš„å…ƒç´ åˆå¹¶åˆ°ç­”æ¡ˆä¸­

```cpp
class Solution {
public:
    typedef pair<int, ListNode *> PII;
    struct cmp {
        bool operator()(const PII &a, const PII &b) const {
          return a.first > b.first;
      }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        //return merge(lists, 0, lists.size() - 1);
        priority_queue<PII, vector<PII>, cmp> q;
        for (auto cur : lists) {
            if (cur) q.push({cur->val, cur});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto cur = q.top();
            ListNode *ptr = cur.second;
            q.pop();
            tail->next = ptr;
            tail = tail->next;
            if (ptr->next) q.push({ptr->next->val, ptr->next});
        }
        tail->next = nullptr;
        return head.next;

    }
```



#### HZOJ-571-å…³ç³»ç½‘ç»œ1.cpp

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100
int arr[MAX_N + 5][MAX_N + 5];

struct Data {
    Data(int a, int b, int c) {
        x = a, y = b, cnt = c;
    }
    int cnt, x, y;
};

struct DataCompare {
    bool operator()(const Data &a, const Data &b) const {
        if (a.cnt - b.cnt) return a.cnt < b.cnt;
        if (a.x - b.x) return a.x < b.x;
        return a.y < b.y;
    }
};

set<Data, DataCompare> s;

int main() {
    int n, x, y;
    cin >> n >> x >> y;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
            if (arr[i][j]) {
                s.insert(Data(i, j, 1));
            }
        }
    }
    while (s.size()) {
        int x = s.begin()->x;
        int y = s.begin()->y;
        int cnt = s.begin()->cnt;
        s.erase(s.begin());
        for (int i = 1; i <= n; i++) {
            if (arr[y][i] != 1) continue;
            if (arr[x][i]) continue;
            arr[x][i] = cnt + 1;
            s.insert(Data(x, i, cnt + 1));
        }
    }
    cout << arr[x][y] - 1 << endl;
    return 0;
}
```

#### HZOJ-572-æœ‰åºè¡¨çš„æœ€å°å’Œ.cpp

 ç»™å‡ºä¸¤ä¸ªé•¿åº¦ä¸º *ğ‘›*n çš„æœ‰åºè¡¨ *ğ´*A å’Œ *ğµ*Bï¼Œåœ¨ *ğ´*A å’Œ *ğµ*B ä¸­å„ä»»å–ä¸€ä¸ªå…ƒç´ ï¼Œå¯ä»¥å¾—åˆ° *ğ‘›*2n2 ä¸ªå’Œï¼Œæ±‚è¿™äº›å’Œä¸­å‰ *ğ‘›*n ä¸ªæœ€å°å€¼ã€‚

1. åŒæŒ‡é’ˆ

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 400000
long long a[MAX_N + 5], b[MAX_N + 5];

struct Data {
    Data(long long val, long long i, long long j) : val(val), i(i), j(j) {}
    long long val, i, j;
    bool operator<(const Data &a) const {
        if (val - a.val) return val < a.val;
        if (i - a.i) return i < a.i;
        return j < a.j;
    }
};

set<Data> s;

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%lld", a + i);
    for (int i = 0; i < n; i++) scanf("%lld", b + i);
    s.insert(Data(a[0] + b[0], 0, 0));
    for (long long i = 0; i < n; i++) {
        long long val = s.begin()->val;
        long long x = s.begin()->i;
        long long y = s.begin()->j;
        s.erase(s.begin());
        printf("%lld\n", val);
        if (x + 1 < n) s.insert(Data(a[x + 1] + b[y], x + 1, y));
        if (y + 1 < n) s.insert(Data(a[x] + b[y + 1], x, y + 1));
    }
    return 0;
}
```

2.ä¼˜å…ˆé˜Ÿåˆ—





#### hzoj-284-è¶…å¸‚å–è´§-äºŒå‰å †-å¹¶æŸ¥é›†

> è¶…å¸‚é‡Œæœ‰Nä¸ªå•†å“. ç¬¬iä¸ªå•†å“å¿…é¡»åœ¨ä¿è´¨æœŸ(ç¬¬diå¤©)ä¹‹å‰å–æ‰, è‹¥å–æ‰å¯è®©è¶…å¸‚è·å¾—piçš„åˆ©æ¶¦.
>
> æ¯å¤©åªèƒ½å–ä¸€ä¸ªå•†å“.
>
> ç°åœ¨ä½ è¦è®©è¶…å¸‚è·å¾—æœ€å¤§çš„åˆ©æ¶¦.

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 10000
struct Data {
    int p, d;
} a[MAX_N + 5];

bool cmp(const Data &a, const Data &b) {
    return a.d < b.d;
}

typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].p >> a[i].d;
    }
    sort(a, a + n, cmp);
    for (int i = 0; i < n; i++) {
        if (s.size() < a[i].d) {
      //æ’å…¥iæ˜¯ä¸ºäº†setå»é‡
            s.insert(PII(a[i].p, i));
        } else if (s.begin()->first < a[i].p) {
            s.erase(s.begin());
            s.insert(PII(a[i].p, i));
        }
    }
    int ans = 0;
    for (auto iter = s.begin(); iter != s.end(); iter++) {
        ans += iter->first;
        cout << iter->first << endl;
    }
    cout << ans << endl;
    return 0;
}
```

```cpp
#define MAX_N 10000

struct Data {
    int p, d;
} arr[MAX_N + 5];
 
struct UnionSet {
    int fa[MAX_N + 5];
    void init(int n) {
        for (int i = 0; i <= n; ++i) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    //æ ¹èŠ‚ç‚¹ä»£è¡¨å½“å‰èŠ‚ç‚¹å‰é¢ç¬¬ä¸€ä¸ªç©ºä½ç½®
    //å‰é¢åšå„¿å­
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

bool cmp(const Data &a, const Data &b) {
    return a.p > b.p;
}

UnionSet u;

int solve(int n) {
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].p >> arr[i].d;
    }
    sort(arr, arr + n, cmp);
    u.init(MAX_N);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (u.get(arr[i].d) == 0) continue;
        ans += arr[i].p;
        int day = u.get(arr[i].d);
        //è®©dayä½œä¸ºday-1çš„å­é›†ï¼Œdayè¢«å ç”¨
        u.merge(day, day - 1);
    }
    cout << ans << endl;
    return 0;
}

int main() {
    int n;
    while (cin >> n) solve(n);
    return 0;
}

```

#### hzoj-286. æ•°æ®å¤‡ä»½

ç­‰æ•ˆæƒå€¼æ›¿æ¢

åæ‚”ç­–ç•¥

åŸºäºé€‰æ‹©ä¸€æ¡ç”µç¼†çš„æƒ…å†µå»é€‰æ‹©ç¬¬äºŒæ¡ç”µç¼†

![image-20210121192544196](/Image/A4.å †å’Œä¼˜å…ˆé˜Ÿåˆ—-photo/image-20210121192544196.png)

è‹¥è¦é€‰æ‹©å‘¨å›´çš„3-4åˆ™å¿…é¡»é€‰æ‹©1-2

![image-20210121192854505](/Image/A4.å †å’Œä¼˜å…ˆé˜Ÿåˆ—-photo/image-20210121192854505.png)

ç­‰æ•ˆå›¾çš„ç”Ÿæˆï¼Œåæ‚”ä¾§ç‡

```cpp
#define MAX_N 100000
#define inf 0x3f3f3f

int a[MAX_N + 5];
int l[MAX_N + 5], pre[MAX_N + 5], nxt[MAX_N + 5];
typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n, k;
    cin >> n >> k;
    a[0] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        l[i] = a[i] - a[i - 1];
        pre[i] = i - 1;
        nxt[i] = i + 1 > n ? 0 : i + 1;
        s.insert(PII(l[i], i));
    }
    int sum = 0;
    while (k) {
        int t0 = s.begin()->second, t1 = pre[t0], t2 = nxt[t0];
        if (t1 == 0 || l[t0] != s.begin()->first) {
            s.erase(s.begin());
            continue;
        }
        s.erase(s.begin());
        sum += l[t0];
        k--;
        l[t0] = l[t1] + l[t2] - l[t0];
        l[t1] = l[t2] = inf;
        if (t2 == 0) continue;
        pre[t0] = pre[t1];
        nxt[t0] = nxt[t2];
        nxt[pre[t1]] = t0;
        pre[nxt[t2]] = t0;
        s.insert(PII(l[t0], t0));
    }
    cout << sum << endl;

    return 0;
}

```



#### HZOJ-289-ç”Ÿæ—¥ç¤¼ç‰©.cpp

[BZOJ2288](https://www.cnblogs.com/zyfzyf/p/4114774.html)

>  æå 1818 å²ç”Ÿæ—¥çš„æ—¶å€™ï¼Œå°æ˜ç»™å¥¹çœ‹äº†ä¸€ä¸ªç¥å¥‡çš„åºåˆ— *ğ´*1,*ğ´*2,...,*ğ´**ğ‘*A1,A2,...,ANã€‚ å¥¹è¢«å…è®¸é€‰æ‹©ä¸è¶…è¿‡ *ğ‘€*M ä¸ªè¿ç»­çš„éƒ¨åˆ†ä½œä¸ºè‡ªå·±çš„ç”Ÿæ—¥ç¤¼ç‰©ã€‚è‡ªç„¶åœ°ï¼Œæåæƒ³è¦çŸ¥é“é€‰æ‹©å…ƒç´ ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚ä½ èƒ½å¸®åŠ©å¥¹å—ï¼Ÿ
>  é¦–å…ˆè¿åœ¨ä¸€å—çš„æ­£è´Ÿç›¸åŒçš„è‚¯å®šå¯ä»¥çœ‹æˆä¸€ä¸ªç‚¹ï¼Œç„¶åæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ­£è´Ÿäº¤æ›¿çš„æ•°åˆ—ï¼Œå¹¶ä¸”é¦–ä½ä¸¤é¡¹éƒ½æ˜¯æ­£æ•°ï¼ˆè´Ÿæ•°å»æ‰ï¼‰

ç„¶åå¦‚æœæ­£çš„é¡¹æ•°<=mï¼Œé‚£æ˜¾ç„¶æˆ‘ä»¬å…¨éƒ¨é€‰èµ°å°±è·å¾—äº†æœ€å¤§æƒå€¼ï¼Œå¦åˆ™æˆ‘ä»¬éœ€è¦åšä¸€ç‚¹ç‰ºç‰²ã€‚

1ï¼‰ä¸é€‰æŸäº›æ­£é¡¹

2ï¼‰é€‰ä¸€äº›è´Ÿé¡¹ä½¿å¾—ç›¸é‚»çš„æ­£é¡¹æˆä¸º1å—

è®°æ‰€æœ‰æ­£æ•°ä¹‹å’Œä¸ºsumï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¸Šé¢ä¸¤ç§æ“ä½œä½¿å¾—sumå‡æ‰çš„æ•°æœ€å°å¹¶ä¸”æ»¡è¶³åªæœ‰må—ã€‚

æˆ‘ä»¬æŠŠæ‰€æœ‰æ•°çš„ç»å¯¹å€¼æ”¾å…¥ä¸€ä¸ªå †ï¼Œæ¯æ¬¡å–æœ€å°å…ƒç´ xã€‚sum'-=x

é‚£ä¹ˆå¦‚æœè¯¥æ•°åŸæ¥æ˜¯æ­£çš„ï¼Œæ„æ€æ˜¯ä¸é€‰å®ƒï¼›

å¦‚æœæ˜¯è´Ÿçš„ï¼Œæ„æ€æ˜¯æŠŠå®ƒä¸¤è¾¹çš„æ­£æ•°åˆå¹¶ã€‚

ä½†ç›´æ¥è¿™æ ·åšæ˜¯ä¸è¡Œçš„ï¼Œæˆ‘ä»¬å¿…é¡»ä¿è¯å–è´Ÿçš„æ—¶å€™ä¸¤è¾¹çš„æ­£çš„å¿…é¡»ä¸è¢«å–ï¼Œå–æ­£çš„æ—¶å€™ä¸¤è¾¹çš„è´Ÿçš„ä¸è¢«å–ã€‚

æ¢å¥è¯è¯´ï¼Œä¸èƒ½é€‰æ‹©ç›¸é‚»çš„ä¸¤ä¸ªæ•°ï¼æˆ‘ä»¬æˆåŠŸçš„å°†æ­¤é¢˜è½¬åŒ–æˆäº†æ•°æ®å¤‡ä»½é—®é¢˜ã€‚

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100000
long long arr[MAX_N + 5];

struct Node {
    long long val, id, f;
    long long pre, next;
    bool operator<(const Node &a) const {
        if (abs(val) - abs(a.val)) return abs(val) < abs(a.val);
        return id < a.id;
    }
} list[MAX_N + 5];

set<Node> s;

void del(long long k) {
    if (list[k].f == 0) return ;
    if (list[k].pre)  list[list[k].pre].next = list[k].next;
    if (list[k].next) list[list[k].next].pre = list[k].pre;
    list[k].f = 0;
    return ;
}

int main() {
    long long n, m, cnt = 0, sum = 0;
    cin >> n >> m;
    for (long long i = 0; i < n; i++) cin >> arr[i];
    for (long long i = 0, k = 1; i < n; k++) {
        list[k].val = 0;
        list[k].id = k;
        list[k].f = 1;
        while (i < n && arr[i] == 0) i++;
        long long val = arr[i];
        while (i < n && arr[i] * val >= 0) {
            list[k].val += arr[i++];
        }
        if (k - 1) list[k - 1].next = k;
        list[k].pre = k - 1;
        list[k].next = 0;
        if (list[k].val > 0) cnt += 1, sum += list[k].val;
        s.insert(list[k]);
    }
    while (cnt > m) {
        long long k = s.begin()->id;
        s.erase(s.begin());
        if (list[k].f == 0) continue;
        if (list[k].pre && list[k].next) {
            sum -= abs(list[k].val);
            cnt -= 1;
            list[k].val += list[list[k].pre].val;
            list[k].val += list[list[k].next].val;
            del(list[k].pre);
            del(list[k].next);
            s.insert(list[k]);
        } else {
            if (list[k].val > 0) sum -= list[k].val, cnt -= 1;
            del(k);
        }
    }
    cout << sum << endl;
    return 0;
}
```

#### HZOJ-285 åºåˆ—Må°å’Œ

>   ç»™å‡ºä¸€ä¸ª *ğ‘›*âˆ—*ğ‘š*nâˆ—m çš„çŸ©é˜µï¼Œæ¯è¡Œå–ä¸€ä¸ªå…ƒç´ ï¼Œç»„æˆä¸€ä¸ªåŒ…å« *ğ‘›*n ä¸ªå…ƒç´ çš„åºåˆ—ï¼Œä¸€å…±æœ‰ *ğ‘š**ğ‘›*mn ç§åºåˆ—ï¼Œæ±‚å‡ºåºåˆ—å’Œæœ€å°çš„å‰ *ğ‘š*m ä¸ªåºåˆ—çš„åºåˆ—å’Œã€‚

```cpp
#define INF 0x3f3f3f3f
#define MAX_M 2000
int nums[MAX_M + 5];
//æ—¶é—´æˆ³, åŠ è´Ÿå·æ¨¡æ‹Ÿå¤§é¡¶å †
typedef pair<int, int> PII;

struct BigSet : set<PII> {
public :
    BigSet() : t(0) {}
    void insert(int &a) {
        this->set<PII>::insert(PII(-a, t++));
    }
    void pop() {
        erase(begin());
    }
    int top() {
        return -(begin()->first);
    }

private :
    int t;
};

BigSet s;

void extract(int m) {
    for (int i = m - 1; i >= 0; --i) {
        nums[i] = s.top();
        s.pop();
    }
}

int main() {
    int n, m, x;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> x;
        s.insert(x);
    }
    for (int i = 1; i < n; ++i) {
        extract(m);
        for (int j = 0; j < m; ++j) {
            cin >> x;
            for (int k = 0; k < m; ++k) {
                int y = x + nums[k];
                if (s.size() == m && y >= s.top()) break;
                if (s.size() == m) s.pop();
                s.insert(y);
            }
        }
    }
    extract(m);
    for (int i = 0; i < m; ++i) {
        i && cout << " ";
        cout << nums[i];
    }
    cout << endl;
    return 0;
}

```

