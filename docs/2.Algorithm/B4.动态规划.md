---
id : B4.动态规划
title : B4.动态规划
typora-root-url : ../
---

#  ==动态规划==

![图片](/Image/B4.动态规划-photo/lALPBG1Q6-8czMbNA5nNBDg_1080_921.png_620x10000q90g.jpg)



## 动态规划（Dynamic Programming,DP）

解决有着彼此**重叠子问题**的问题。其解法并不是一遍遍地对彼此重叠的子问题求解，而是只对较小规模的子问题求解一次，然后把结果记录在一个表格中

最优化问题而言，问题必须具备所谓的**最优子结构（**optimal substructure），才能从子问题的局部最优解有效地构造出全局最优解。(对有些问题这个要求并不能完全满足,故有时需要引入一定的近似)。简单地说,问题能够分解成子问题来解决。

1. 动态规划和其它遍历算法(如深/广度优先搜索)都是将原问题拆成多个子问题然后求解,他们之间最本质的区别是,动态规划保存子问题的解,避免重复计算。
2. 动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

动态规划问题的⼀般形式就是求最值。

求解动态规划的核⼼问题是穷举，找到状态转移方程

1. 在「重叠⼦问题」，需要「备忘录」或者「DP table」来优化穷举过程
2. 具备「最优⼦结构」，⼦问题间必须互相独⽴。
3. 空间压缩

#### 求解套路

1. 第一步：确定动归状态
2. 第二步：推导状态转移方程，理解：转移、决策；「容斥原理」
   dp数组如何初始化，确定遍历顺序；
3. 第三步：正确性证明，利用数学归纳法
4. 第四步：程序实现
5. 所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

树形DP，数位DP，区间DP ，概率型DP，博弈型DP，状态压缩dp

### 旅行商问题

> 给定一个 n 个顶点组成的带权有向图的距离矩阵成 $d(I,j)$ ( INF 表示没有边 )。 要求从顶点 0 出发 ,经过每个顶点恰好一次后再回到顶点 0。 问所经过的边的总权重的最小值是多少?

著名的旅行商问题(TSP, Traveling Salesman Problem )。 TSP 问题是 NP 困难的,没有已知的多项式时间的高效算法可以解决这一问题。

所有可能的路线共有 $(n-1)!$ 种

假设现在已经访问过的顶点的集合为 $S$，当前所在的顶点为 $V$，用办 $dp[S][v]$  表示从 $v$ 出发访问剩余的所有顶点,最终回到顶点 $0$ 的路径的权重总和的最小值。由从 $v$ 出发可以移动到任意的一个节点 $u \notin S$
$$
dp[V][0] = 0 \\
dp[S][v] = min\{dp[S \cup {u}][u] + d(v,u) \big| u \notin S \}
$$


### 矩阵的幂





### 利用数据结构高效求解

#### HZOJ-46-切割回文

1. 状态定义

$dp[i]$ 代表取字符串的前 $i$ 位，最少分成多少段回文串

2. 状态转移

$dp[i] = min(dp[j]) + 1\ |\ s[j + 1, i]\ is\ palindrome$

1. 根据状态转移，算法时间复杂度$O(n^2)$
2. 所以，我们需要对转移阶段进行优化
3. 动态规划优化章节的时候，重点解决





#### 五、HZOJ-50-扔鸡蛋

1. 状态定义

$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测多少次

2. 状态转移

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$



1. 程序所使用的存储空间与楼层数量强相关
2. 楼层数量达到了 $2^{31}$，所以在这种状态定一下不可行
3. 状态定义不可行，我们就需要优化状态定义
4. 时间复杂度 $O(n \times m^2)$，当 m 过大的时候，无法通过时间限制



###  一、动态规划优化的分类

1. 状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程
2. 程序实现的优化，例如：01背包问题。状态定义没有变、转移过程也没变。
3. 状态定义的优化，大量训练，才能培养出来的能力，从源头进行优化
4. 状态定义->源头，转移过程->过程，程序实现->结果



程序优化：01背包，钱币问题，滚动数组



### 二、扔鸡蛋问题的优化

####  转移过程优化

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$

通过观察 k 与 $dp[n-1][k-1]$与 $dp[n][m-k]$之间的关系，最优的转移 k 值，一定发生在两个函数的交点处

优化掉 min 以后，总体时间复杂度变成了 $O(n \times m)$

![image-20210615192401451](/Image/B4.动态规划-photo/image-20210615192401451.png)

![image-20210615192406407](/Image/B4.动态规划-photo/image-20210615192406407.png)

#### 状态定义的优化

1. 原状态定义所需存储空间与 m 相关，m 值域大，所以存不下
2. 当发现某个自变量与因变量之间存在相关性的时候，两者即可对调
3. $dp[n][m]=k$ 重定义为$dp[n][k]=m$，代表 n 个鸡蛋扔 k 次，最多测多少层楼
4. k 的值域小，当 n=2 时，$k \le \sqrt{2m}$ 



**状态转移方程：**$dp[n][k] = dp[n-1][k-1]+dp[n][k-1] + 1$

本质上已经不是一个动态规划题目了，实际上变成了一个递推问题

![image-20210615192424816](/Image/B4.动态规划-photo/image-20210615192424816.png)

### 三、多重背包的优化

#### 1. 二进制拆分法

1. 本质上，对于某一类物品，我们具体要选择多少件，才是最优答案
2. 普通的单一拆分法，实际上只是想枚举某个物品选择 1--s 件的所有情况
3. 二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少
4. 拿14举例，普通拆分法 14 份，二进制拆分法 4 份物品



**时间复杂度：**$O(nm\sum_{i=1}^{i=n}{logs_i})$

**最优时间复杂度：**$O(nm)$，借助单调队列，后续再讲

**01背包时间复杂度：**$O(nm)$

**完全背包时间复杂度：**$O(nm)$

![image-20210615192430113](/Image/B4.动态规划-photo/image-20210615192430113.png)

### 四、最长上升子序列

####  状态定义

$dp[i]$，代表以 i 位做为结尾的最长上升子序列的长度



#### 状态转移

$dp[i] = max(dp[j]) + 1 | val_j < val_i$



#### 优化方式

1. 维护一个单调数组 len，len[i] 代表长度为 i 的序列，结尾最小值
2. $dp[i]$ 在转移的时候，在 len 数组中查找第一个 $len[k]>=val_i$ 的位置，$dp[i] = k$
3. 更新 $len[k] = val_i$
4. 需要明确，len 数组为什么是单调的
5. 证明过程：假设，更新前是单调的，更新以后，一定是单调的
6. 在 len 数组中查找位置 k，实际上就是二分算法搞定



**时间复杂度：**$O(nlogl)$


![image-20210615192434217](/Image/B4.动态规划-photo/image-20210615192434217.png)




![image-20210615192910900](/Image/B4.动态规划-photo/image-20210615192910900.png)

### 五、切割回文

提前处理得到 mark 数组，$mark[i]$ 存储的是所有以 i 位置做为结尾的回文串的起始坐标，在转移过程中，利用 mark 数组，就可以避免掉大量的无用循环遍历过程。



**时间复杂度：**$O(n+m)$，m 是字符串中回文串的数量

##  基本动态规划

#### LC-509. 斐波那契数

> 该数列由 0 和 1 开始，后⾯的每⼀项数字都是前⾯两项数字的和。也就是：
>
> - F(0) = 0，F(1) = 1
> - F(n) = F(n - 1) + F(n - 2)，其中 n > 1

```cpp
class Solution {
public:
	int fib(int N) {
		if (N < 2) return N;
		return fib(N - 1) + fib(N - 2);
	}
};
```

时间复杂度：O(2^n)

1. dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2];

#### LC-70. 爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的⽅法可以爬到楼顶呢？



1. dp[i]： 爬到第i层楼梯，有dp[i]种⽅法
2. dp[i] = dp[i - 1] + dp[i - 2];

#### Nowder-

> 就是⼀步⼀个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种⽅法爬
> 到n阶楼顶。
>
> **完全背包问题**



```cpp
int climbStairs(int n) {
	vector<int> dp(n + 1, 0);
	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
			if (i - j >= 0) dp[i] += dp[i - j];
		}
	}
	return dp[n];
}
```

#### LC-62.不同路径

> ⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “Start” ）。机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

动态规划

1. $dp[i][j]$  ：表示从（0 ，0）出发，到(i, j) 有$dp[i][j]$ 条不同的路径。
2. $dp[i][j] = dp[i - 1][j] + dp[i][j - 1]$

数论⽅法

m，n的话，⽆论怎么⾛，⾛到右下的终点都需要 m + n - 2 步。

组合问题：m+n-2步中有n-1步向下

**求组合的时候，要防⽌两个int相乘溢出！**

```cpp
int uniquePaths(int m, int n) {
	long long numerator = 1; // 分⼦
	int denominator = m - 1; // 分⺟
	int count = m - 1;
	int t = m + n - 2;
	while (count--) {
		numerator *= (t--);
		while (denominator != 0 && numerator % denominator == 0) {
        	numerator /= denominator;
			denominator--;
		}
	}
	return numerator;
}
```



> ⼀个机器⼈位于⼀个 m x n ⽹格的左上⻆ （起始点在下图中标记为 “Start” ）。机器⼈每次只能向下或者向右移动⼀步。机器⼈试图达到⽹格的右下⻆（在下图中标记为 “Finish” ）。**现在考虑⽹格中有障碍物**。那么从左上⻆到右下⻆将会有多少条不同的路径？



1. $dp[i][j] $：表示从（0 ，0）出发，到(i, j) 有$dp[i][j]$条不同的路径。

2. ```cpp
   if (obstacleGrid[i][j] == 0) { // 当(i, j)没有障碍的时候，再推导dp[i][j]
   	dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
   }
   ```

#### LC-343. 整数拆分

> 给定⼀个正整数 n，将其拆分为⾄少两个正整数的和，并使这些整数的乘积最⼤化。 返回你可以获得的最⼤乘积。
> 示例 1:
> 输⼊: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1。

动规

1. dp[i]：分拆数字i，可以得到的最⼤乘积为dp[i]。
2. dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

贪⼼

贪⼼，每次拆成n个3，如果剩下是4，则保留4，然后相乘。结论需要数学证明

```cpp
int integerBreak(int n) {
	if (n == 2) return 1;
	if (n == 3) return 2;
	if (n == 4) return 4;
	int result = 1;
	while (n > 4) {result *= 3;
		n -= 3;
	}
	result *= n;
	return result;
}
```

#### LC-96.不同的⼆叉搜索树

> 给定⼀个整数 n，求以 1 ... n 为节点组成的⼆叉搜索树有多少种？



1. dp[i] ： 1到i为节点组成的⼆叉搜索树的个数为dp[i]。
2. dp[i] += dp[以 $j - 1$ 为头结点左⼦树节点数量] * dp[以 $i - j$ 为头结点右⼦树节点数量]
3. dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左⼦树节点数量，i-j 为以j为头结点右⼦树节点数量

```cpp
class Solution {
public:

    int numTrees(int n) {
        if (n < 0) return 0;
        vector<int> dp(n + 1, 0);
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```



#### [LC-542.01矩阵](https://leetcode-cn.com/problems/01-matrix/description/)

> 给定一个由 `0` 和 `1` 组成的矩阵 `mat` ，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。
>
> 两个相邻元素间的距离为 `1` 。

一般来说,因为这道题涉及到四个方向上的最近搜索，第一反应可能会是广度优先搜索。但是对于一个大小 O(mn) 的二维数组,对每个位置进行四向搜索,最坏情况的时间复杂度(即全是 1)会达到恐怖的 $O(m^2n^2)$。

使用一个 dp 数组做 memoization,使得广度优先搜索不会重复遍历相同位置;

另一种更简单的方法是,我们从左上到右下进行一次动态搜索,再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。




```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        if (mat.empty()) return {};
        int row = mat.size(), col = row ? mat[0].size() : 0;
        vector<vector<int>> dp(row, vector<int>(col, INT_MAX - 1));
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (mat[i][j] == 0) {
                    dp[i][j] = 0;
                } else {
                    if (i) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);
                    if (j) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
                }
            }
        }
        for (int i = row - 1; i >= 0; i--) {
          for (int j = col - 1; j >= 0; j--) {
            if (mat[i][j] == 0) {
              dp[i][j] = 0;
            } else {
              if (i < row - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);
              if (j < col - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);
            }
          }
        }
        return dp;

    }
};
```



#### [LC-221.最大正方形](https://leetcode-cn.com/problems/maximal-square/description/)

> 在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。



1. $dp[i][j]$ ：表示以i,j为右下角的只包含1的最大正方形面积
2. 如果当前位置是 0,那么 $dp[i][j]$ 即为 0;
   设 $dp[i][j] = k^2$ ,其充分条件为 $dp[i-1][j-1]$、$dp[i][j-1]$ 和 $dp[i-1][j]$ 的值必须都不小于 $(k − 1)/2$ ,



```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int row = matrix.size(), col = matrix[0].size();
        int ans = 0;
        vector<vector<int>> cnt(row, vector<int>(col, 0));
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (!i || !j || matrix[i][j] == '0') {
                    cnt[i][j] = matrix[i][j] == '0' ? 0 : 1;
                } else {
                    cnt[i][j] = min(min(cnt[i][j - 1], cnt[i - 1][j]), cnt[i - 1][j - 1]) + 1;
                }
                ans = max(ans, cnt[i][j] * cnt[i][j]);

            }
        }
        /*
        for (int j = 0; j < col; ++j) cnt[0][j] = matrix[0][j] == '1';
        for (int i = 1; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                cnt[i][j] = matrix[i][j] == '1' ? cnt[i - 1][j] + 1 : 0;
            }
        }
        for (int i = 0; i < row; ++i) {
            deque<int> q;
            int l = 0;
            for (int j = 0; j < col; ++j) {
                while(!q.empty() && cnt[i][q.back()] > cnt[i][j]) q.pop_back();
                q.push_back(j);
                while (j - l >= 0 && j - l + 1 > cnt[i][q.front()]) {
                    ++l;
                    if (q.front() < l) q.pop_front();
                }
                ans = max(ans, (j - l + 1) * (j - l + 1));
            }
        }
        */
        return ans;

    }
};
// @lc code=end

```





### 子序列问题

#### LC-300.最长递增子序列

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
> 示例 1：
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

1. 定义：**dp[i]表示i之前包括i的最长上升子序列**。

2. 状态转移方程：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

   位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

3. 初始化：每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.



```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (!nums.size()) return 0;
        if (nums.size() == 1) return 1;
        int *arr = new int[nums.size()];
        int head = 0, tail = -1;
        for (int i = 0; i < nums.size(); i++) {
            if (tail + 1 == head || nums[i] > arr[tail]) {
                arr[++tail] = nums[i];
            } else {
                arr[getIdx(arr, 0, tail, nums[i])] = nums[i];
            }
        }
        return tail - head + 1;
    }
    int getIdx(int *arr, int l, int r, int k) {
        while (l < r) {
            int mid = (l + r) >> 1;
            if (arr[mid] >= k) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n <= 1) return n;
    vector<int> dp;
    dp.push_back(nums[0]);
    for (int i = 1; i < n; ++i) {
        if (dp.back() < nums[i]) {
            dp.push_back(nums[i]);
        } else {
            auto itr = lower_bound(dp.begin(), dp.end(), nums[i]);
            *itr = nums[i];
        }
    }
    return dp.size();
}
```





#### LC-674. 最长连续递增序列

> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

1. **dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。
2. if (nums[i] > nums[j]) dp[i + 1] = dp[i] + 1;
3. 初始化：每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是是1.

**贪心**

遇到nums[i + 1] > nums[i]的情况，count就++，否则count为1，记录count的最大值

#### LC-718. 最长重复子数组

> 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。
>
> 输入：
> A: [1,2,3,2,1]
> B: [3,2,1,4,7]
> 输出：3
>
> 解释：
> 长度最长的公共子数组是 [3, 2, 1] 。
>
> **元素连续**

1. $dp[i][j] $：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为$dp[i][j]$。
2. $dp[i][j] = dp[i - 1][j - 1] + 1$;

```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int len1 = A.size(), len2 = B.size();
        int ans = 0;
        vector<int> dp(len2 + 1);
        dp[0] = 0;
        for (int j = 1; j <= len2; j++) {
            dp[j] = !!(A[0] == B[j - 1]);
            ans = max(ans, dp[j]);
        }
        int pre = 0;
        for (int i = 2; i <= len1; i++) {
            for (int j = len2; j >= 1; j--){
                if (A[i - 1] != B[j - 1]) {
                    dp[j] = 0;
                } else {
                    dp[j] = dp[j - 1] + 1;
                }
                ans = max(ans, dp[j]);
            }
        }
        return ans;

    }
};
```

#### LC-1143.最长公共子序列

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
>
> 输入：text1 = "abcde", text2 = "ace"
> 输出：3
> 解释：最长公共子序列是 "ace"，它的长度为 3
>
> **元素无需连续**



1. $dp[i][j]$：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为$dp[i][j]$

2. ```cpp
   if (text1[i - 1] == text2[j - 1]) {
       dp[i][j] = dp[i - 1][j - 1] + 1;
   } else {
       dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
   }
   ```

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size(), len2 = text2.size();
        vector<int> dp(len2 + 5, 0);
        for (int j = 1; j <= len2; j++) {
          dp[j] = (text1[0] == text2[j - 1] ? 1 : dp[j - 1]);
        }
        for (int i = 2; i <= len1; i++) {
            int pre = 0;
            for (int j = 1; j <= len2; j++) {
                int temp = dp[j];
              if (text1[i - 1] == text2[j - 1]) {
                dp[j] = pre + 1;
              } else {
                dp[j] = max(dp[j], dp[j - 1]);
              }
              pre = temp;
            }
        }
        return dp[len2];
    }
};
```





#### LC-1035.不相交的线

> 我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。
>
> 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。
>
> 以这种方法绘制线条，并返回我们可以绘制的最大连线数。
>
> ![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5PlFCN8X5f6P5ur7tgO8v7UvfO8dUlurKQZk6O9aND4MB5OEWFHyXmhqZS1HOx3sS0HKtfOBuL6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



直线不能相交，意味着这个子序列不能改变相对顺序，**其实就是求两个字符串的最长公共子序列的长度！**

#### LC-53. 最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

找最大的连续子序列，就应该找每一个i为终点的连续最大子序列。

1. **dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。
2. dp[i] = max(dp[i - 1] + nums[i], nums[i]);

贪心解法

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

```cpp
	for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
```

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int pre = min(0, nums[0]), sum = nums[0], ans = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            sum += nums[i];
            ans = max(ans, sum - pre);
            pre = min(pre, sum);
        }
        return ans;
    }
};
```









## 字符串编辑

#### LC-392.判断子序列

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

1. **$dp[i][j]$ 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为$dp[i][j]$**。
2. if (s[i - 1] == t[j - 1])
   t中找到了⼀个字符在s中也出现了：$dp[i][j] = dp[i - 1][j - 1] + 1;$
   if (s[i - 1] != t[j - 1])
   相当于t要删除元素，继续匹配：$dp[i][j] = dp[i][j - 1];$



```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int j = 0;
        for (int i = 0; i < t.size(); i++) {
            if (t[i] == s[j] && j < s.size()) {
                j++;
            }
        }
        return j == s.size();
    }
};
```





#### LC-115.不同的⼦序列

> 给定⼀个字符串 s 和⼀个字符串 t ，计算在 s 的⼦序列中 t 出现的个数。
> 字符串的⼀个 ⼦序列 是指，通过删除⼀些（也可以不删除）字符且不⼲扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的⼀个⼦序列，⽽ "AEC" 不是）

如果不是⼦序列，⽽是要求连续序列的，那就可以考虑⽤KMP。

1. $dp[i][j]$ ：以i-1为结尾的s⼦序列中出现以j-1为结尾的t的个数为 $dp[i][j]$。



````cpp

class Solution {
public:
    int numDistinct(string s, string t) {
        int m = t.length(), n = s.length();
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0));
        for (int j = 0; j <= n; j++) dp[0][j] = 1;
        for (int j = 1; j <= n; j++)
            for (int i = 1; i <= m; i++)
                dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0);
        return dp[m][n];
    }
};  
````





#### LC-583. 两个字符串的删除操作

> 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最⼩步数，每步可以删除任意⼀个字符串中的⼀个字符。



```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size(), len2 = word2.size();
        vector<vector<int>> dp(len1 + 5, vector<int>(len2 + 5, 0));
        for (int i = 1; i <= len2; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i<= len1; i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1;
                }
            }
        }
        return dp[len1][len2]; 
    }
};
```





#### [LC-650.只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/description/)

> 最初记事本上只有一个字符 `'A'` 。你每次可以对这个记事本进行两种操作：
>
> - `Copy All`（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
> - `Paste`（粘贴）：粘贴 **上一次** 复制的字符。
>
> 给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出 **恰好** `n` 个 `'A'` 。返回能够打印出 `n` 个 `'A'` 的最少操作次数。

动态规划,这里需要乘除法来计算位置

其中位置 i 表示延展到长度 i 的最少操作次数。对于每个位置j,如果 j 可以被 i 整除,那么长度 i 就可以由长度 j 操作得到,其操作次数等价于把一个长度为 1 的 A 延展到长度为 i/j。

递推公式 dp[i] = dp[j] + dp[i/j]。

```cpp
 class Solution {
public:
    int minSteps(int n) {
        vector<int> dp(n + 5, 0);
        for (int i = 2; i <= n; i++) {
            dp[i] = i;
            for (int j = 2; j * j <= n; j++) {
                if (i % j) continue;
                dp[i] = min(dp[j] + dp[i / j], dp[i]);
            }
        }
        return dp[n];
    }
};
```

#### [10.正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/)

> 给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
>
> - `'.'` 匹配任意单个字符
> - `'*'` 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。



其中 $dp[i][j]$ 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。

字符、星号,点号,分情况讨论

```cpp
class Solution {
 public:
  bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
    dp[0][0] = true;
    for (int i = 1; i < n + 1; ++i) {
      if (p[i - 1] == '*') {
        dp[0][i] = dp[0][i - 2];
      }
    }
    for (int i = 1; i < m + 1; ++i) {
      for (int j = 1; j < n + 1; ++j) {
        if (p[j - 1] == '.') {
          dp[i][j] = dp[i - 1][j - 1];
        } else if (p[j - 1] != '*') {
          dp[i][j] = dp[i - 1][j - 1] && p[j - 1] == s[i - 1];
        } else if (p[j - 2] != s[i - 1] && p[j - 2] != '.') {
          dp[i][j] = dp[i][j - 2];
        } else {
          dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];
        }
      }
    }
    return dp[m][n];
  }
};
// @lc code=end
```





##  背包问题

**背包问题的理论基础重中之重是01背包**

而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。



![416.分割等和子集1](https://img-blog.csdnimg.cn/20210117171307407.png)



### 背包递推公式

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

，对应题目如下：

* [动态规划：416.分割等和子集](https://mp.weixin.qq.com/s/sYw3QtPPQ5HMZCJcT4EaLQ)
* [动态规划：1049.最后一块石头的重量 II](https://mp.weixin.qq.com/s/WbwAo3jaUaNJjvhHgq0BGg)



## ``背包九讲``

### 01背包问题

> 有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 $C_i$ ，得到的
> 价值是 $W_i$ 。求解将哪些物品装入背包可使价值总和最大。
>
> ![image-20210925205706439](/Image/B4.动态规划-photo/image-20210925205706439.png)

**暴力的解法**

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。

**动态规划**

1. $F[i][v]$ 表示从下标为$[0-i]$的物品里任意取，放进容量为$v$的背包，可以获得
   的最大价值。递归公式：$F[i, v] = \max\left\{F[i − 1, v], F[i − 1, v − C_i] + W_i \right\}$
2. 从 $F[i][v]$ 的定义出发，如果背包容量v为0的话，即 $F[i][0]$，无论是选取哪些物品，背包价值总和一定为0。

**滚动数组优化**

滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

1. $F[v]$ 为 容量为v的背包所背的最大价值
2. 递归公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$

**一个常数优化**

for i $←$ 1 to $N$
	for v $←$ V to $C_i$
二重循环的下限可以改进。它可以被优化为：（提示：使用二维的转移方程）
for i $←$ 1 to $N$
	for v $←$ $V$ to $\max(V − Σ^N_i W_i , C_i )$

def ZeroOnePack(F, C, W )
	for v ← V to C
		F [v] ← max(F [v], F [v − C] + W )

**初始化的细节问题**

1. **要求恰好装满背包的最优解。**，那么在初始化时除了 $F[0]$ 为 0 ，其它$F [1..V ]$ 均设为 $−∞$ ，
2. **没有要求必须把背包装，而是只希望价格尽量大。**初始化时应该将 $F[0..V ]$全部设为 0 。

初始化的 F数组事实上就是在没有任何物品可以放入背包时的合法状态。

如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 $-∞$ 了。

如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0 ，所以初始时状态的值也就全部为 0了。



1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值

2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$



1. 第一种程序实现，状态如何定义的，程序就如何实现
2. 第二种程序实现，使用滚动数组，对代码进行了空间优化
3. 第三种程序实现，将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序



```cpp
for (int i = 0; i < n; ++ i) {
    cin >> v >> w;
    for (int j = m; j >= v; --j) {
        dp[j] = max(dp[j], dp[j - v] + w);
    }
}
```



### 完全背包

> 有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。放入第 $i$ 种物品
> 的费用是 $C_i$ ，价值是 $W_i$ 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总
> 和不超过背包容量，且价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。**(也就是可以放入背包多次）**

1. 令 $F[i, v]$ 表示前 i 种物品恰放入一个容量为 v 的背包的最大权值。
2. 递推公式：$F[i, v] = \max{F [i − 1, v − kC_i ] + kW_i \big| 0 ≤ kC_i ≤ v}$
3. 递推公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$

跟 01 背包问题一样有 $O(VN )$ 个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态 F [i, v] 的时间是 $O( \frac{v}{C_i} )$ ，总的复杂度可以认为是 $O(NV \sum\frac{v}{C_i} )$

**一个简单有效的优化**

两件物品 i 、 j 满足 $C_i ≤ C_j$且 $W_i ≥ W_j$ ，则将可以将物品 j 直接去掉，不用考虑。$O(N ^2) $实现

**转化为 01背包问题求解**

考虑到第 i 种物品最多选 $\lfloor V /C_i \rfloor$ 件，于是可以把第 i 种物品转化为 $\lfloor V /C_i \rfloor$件费用及价值均不变的物品，然后求解这个 01 背包问题。

**$O(V N )$ 的算法**

​	F [0..V ] ←0
​	for i ← 1 to N
​		for v ← $C_i$ to V
​			F [v] ←$\max(F[v], F[v - C_i] + W_i)$

def CompletePack(F, C, W )
	for v ← C to V
		F [v] ← max{F [v], f [v − C] + W }

两层 for 循环的次序可以颠倒。

1. 递推公式：$F [i, v] = \max(F [i − 1, v], F [i, v − C_i ] + W_i )$
2. 递推公式：$F[v] = \max(F[v], F[v - C_i] + W_i);$



1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值



2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i][j-v[i]]+w[i] &选了若干个第 i 件\end{aligned}\right.$$



程序实现的时候，参考01背包的程序实现，将逆向刷表，改成正向刷表



```cpp
for (int i = 0; i < n; ++ i) {
    cin >> v >> w;
    for (int j = v; j <= m; ++j) {
        dp[j] = max(dp[j], dp[j - v] + w);
    }
}
```





### 多重背包

> 有N种物品和一个容量为V 的背包。第i种物品最多有 $M_i$ 件可用，每件耗费的空间是 $C_i$，价值是 $W_i$  。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

因为对于第 i 种物品有 $M_i + 1$ 种策略：取 0 件，取 1 件……取 $M_i$ 件。

$F [i ， v] = max{F [i − 1, v − k ∗ C_i ] + k ∗ W_i \big| 0 ≤ k ≤ M_i }$

**转变为01背包**

每件物品最多有 $M_i$ 件可用，把 $M_i$ 件摊开，其实就是一个01背包问题。

时间复杂度：O(m * n * k)  ，m：物品种类个数，n背包容量，k单类物品数量

**二进制优化**

把每种物品的数量，打包成一个个独立的包。为是分拆为各个包最后可以组成一个完整背包

把第 i 种物品拆成费用为 $C_i 2^k$ 、价值为 $W_i 2^k $的若干件物品。$1$, $2$, $2^2$ ,. . ., $2^{k−1}$ , $M_i − 2^k + 1$

因为，不管最优策略选几件第 i 种物品，其件数写成二进制后，总可以表示成若干个 $2^k$ 件物品的和。这样一来就把每种物品拆成 $O(\log M_i)$ 件物品。

**伪代码**

def MultiplePack(F ,C,W ,M )
	if C · M ≥ V
		CompletePack(F ,C,W )
			return
	k ← 1
	while k < M
		ZeroOnePack(kC,kW )
		M ←M − k
		k ← 2k
ZeroOnePack(C · M ,W · M )

**单调队列优化**

问题模型转换

1. 多重背包，每类物品多了一个数量限制
2. 01背包，每种物品只有一个
3. 将多重背包中的数量限制，当做多个单一物品来处理
4. 至此就将多重背包，转成了0/1背包问题



1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值



2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$



#### 转化为01背包

个数为s；当成s个物品；

```c++
for (int i = 1; i <= n; ++i) {
        cin >> v >> w >> s;
        while (s--) {
            for (int j = m; j >= v; --j) {
                f[j] = max(f[j], f[j - v] + w);
            }
        }
    }
```



#### 二进制拆分法

例如17，拆为1，2， 4， 8,  2；这五个数可以合成任意x(s <= 17);

```c++
 for (int i = 1; i <= n; ++i) {
        cin >> v >> w >> s;
        for (int k = 1; s > 0; s -= k, k *= 2) {
            k = min(s, k);
            for (int j = m; j >= k * v; --j) {
                f[j] = max(f[j], f[j - k * v] + k * w);
            }
        }
    }
```

#### 单调队列

https://blog.csdn.net/belous_zxy/article/details/80357450?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

```cpp
int dp[MAX_V + 5];
typedef pair<int, int> PII;
deque<PII> que;
int main() {
    int mostv, n;
    cin >> mostv >> n;
    for (int i = 0, v, w, s; i < n; ++i) {
        cin >> v >> w >> s;
        if (s * v > mostv) s = mostv / v; 
        for (int ind = 0; ind < v; ++ind) {
            que.clear();
            for (int jnd = 0; jnd <= (mostv - ind) / v; ++jnd) {
                int res = dp[ind + jnd * v] - jnd * w;
                while (!que.empty() && que.front().first < jnd - s) que.pop_front();
                while (!que.empty() && que.back().second <= res) que.pop_back();
                que.push_back(PII(jnd, res));
                dp[ind + jnd * v] = que.front().second + jnd * w;
            }
        }
    }
    cout << dp[mostv] << endl;
    return 0;
}

```



### 混合三种背包问题

> 如果将前面 1 、 2 、 3 中的三种背包问题混合起来。也就是说，有的物品只可以取一次（ 01 背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？

**01 背包与完全背包的混合**

for i ← 1 to N
	if 第 i 件物品属于 01 背包
		for v ← V to $C_i$
			F [v] ← max(F [v], F [v − $C_i$ ] + $W_i$ )
	else if 第 i 件物品属于完全背包
		for v ← $C_i$ to V
			F [v] ← max(F [v], F [v − $C_i$ ] + $W_i$ )

**再加上多重背包**

for i ← 1 to N
	if 第 i 件物品属于 01 背包
		ZeroOnePack(F ,$C_i$ ,$W_i$ )
	else if 第 i 件物品属于完全背包
		CompletePack(F ,$C_i$ ,$W_i$ )
	else if 第 i 件物品属于多重背包
		MultiplePack(F ,$C_i$ ,$W_i$ ,N i )

### 二维费用的背包问题

> 二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。
> 设第 i 件物品所需的两种费用分别为 $C_i$ 和 $D_i$ 。两种费用可付出的最大值（也即两
> 种背包容量）分别为 V 和 U 。物品的价值为 $W_i$ 。

费用加了一维，只需状态也加一维即可。

1. 设 $F [i, v, u]$ 表示前 i 件物品付出两种费用分别为 v 和 u 时可获得的最大价值。
2. 状态转移方程：$F [i, v, u] = \max\{F[i − 1, v, u], F[i − 1, v − C_i , u − D_i ] + W_i \}$

**物品总个数的限制**

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。

事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1 ，可以付出的最大件数费用为 U 。换句话说，设 $F [v, u]$ 表示付出费用 v 、最多选 u 件时可得到的最大价值，则根据物品的类型（ 01 、完全、多重）用不同的方法循环更新，最后在f [0 . . . V, 0 . . . U ] 范围内寻找答案。

**复整数域上的背包问题**

另一种看待二维背包问题的思路是：将它看待成复整数域上的背包问题。也就是说，背包的容量以及每件物品的费用都是一个复整数。而常见的一维背包问题则是自然数域上的背包问题。所以说，一维背包的种种思想方法，往往可以应用于二维背包问题的求解中，因为只是数域扩大了而已。

#### LC-474.⼀和零

> 给你⼀个⼆进制字符串数组 strs 和两个整数 m 和 n 。
> 请你找出并返回 strs 的最⼤⼦集的⼤⼩，该⼦集中 最多 有 m 个 0 和 n 个 1 。
> 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 ⼦集 。
>
> 示例 1：
> 输⼊：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最⼤⼦集是 {"10","0001","1","0"} ，因此答案是 4 。
> 其他满⾜题意但较⼩的⼦集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满⾜题意，因为它含 4个 1 ，⼤于 n 的值 3 。

⽽m 和 n相当于是⼀个背包，两个维度的背包。

1. $dp[i][j]$：最多有i个0和j个1的strs的最⼤⼦集的⼤⼩为$dp[i][j]$。
2. $dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)$
   strs⾥的字符串有zeroNum个0，oneNum个1。

```cpp
class Solution {
public:
int findMaxForm(vector<string>& strs, int m, int n) {
	vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
	for (string str : strs) { // 遍历物品
		int oneNum = 0, zeroNum = 0;
		for (char c : str) {
			if (c == '0') zeroNum++;
			else oneNum++;
		}
		for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
			for (int j = n; j >= oneNum; j--) {
				dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
			}
		}
	}
	return dp[m][n];
}
};
```





### 分组的背包问题

> 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 $C_i$ ，价值是 $W_i$ 。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

每组物品有若干种策略：是选择本组的某一件，还是一件都不选。**定义“泛化物品”的概念**

1.  $F [k, v]$ 表示前 k 组物品花费费用 v 能取得的最大权值
2.  $F [k, v] = \max{F [k − 1, v], F [k − 1, v − C_i ] + W_i \big| item \ i \ ∈ group \ k}$

**伪代码**

for k ← 1 to K
	for v ← V to 0
		for all item i in group k
			F [v] ← max{F [v], F [v − Ci ] + Wi }

### 有依赖的背包问题

> 简化的问题
>
> 这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品 i 依赖于物品 j ，表示若选物品 i ，则必须选物品 j 。

所有的物品由若干主件和依赖于每个主件的一个附件集合组成。

按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则策略有 $2^n + 1$ 个，为指数级。

考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于分组的背包问题中的一个物品组。但

> 更一般的问题是：依赖关系以图论中“森林” 的形式给出。也就是说，主件的附件仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。

解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。

这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值

####  HuaWJS-购物单

> ## 描述
>
> 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 
>
>
> | 主件   | 附件           |
> | ------ | -------------- |
> | 电脑   | 打印机，扫描仪 |
> | 书柜   | 图书           |
> | 书桌   | 台灯，文具     |
> | 工作椅 | 无             |
>
> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 **~** 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 
>
> ​    设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为： 
>
> v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号） 
>
> ​    请你帮助王强设计一个满足要求的购物单。 

在背包问题中，设`dp[i][j]`表示在钱数不超过j的条件下，对于前i件产品的选择所能获取的最大价值。
动态方程可以表示为
如果`j>price[i]` ， `dp[i][j]=max(dp[i][j-price[i]]+value[i],dp[i-1][j])`
否则 `dp[i][j]=dp[i-1][j])`
那么如何处理附件,我们知道，这里的编号都是主件，所以在每一主件之后可以增加对附件的判断
`dp[i][j]=`max(主件，主件+附件1，主件+附件2，主件+附件3，不买主件)

```cpp
int main() {
    int n, m;
    cin >> m >> n;
    m /= 10;
    vector<vector<int>> price(n + 1,vector<int>(3, 0));
    vector<vector<int>> value(n + 1,vector<int>(3, 0));
    for (int i = 1, v, p, q; i <= n; i++) {
        cin >> v >> p >> q;
        v /= 10;
        if (q == 0) {
            price[i][0] = v;
            value[i][0] = v * p;
        } else {
            if (price[q][1] == 0) {
                price[q][1] = v;
                value[q][1] = v * p;
            } else {
                price[q][2] = v;
                value[q][2] = v * p;
            }
        }
    }
    
    vector<int> dp(m + 1, 0);
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= price[i][0]; j--) {
            int p = price[i][0], v = value[i][0];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][1], v = value[i][0] + value[i][1];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][2], v = value[i][0] + value[i][2];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][1] + price[i][2], v = value[i][0] + value[i][1] + value[i][2];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
        }
        cout << dp[m] << endl;
    }
    cout << dp[m] * 10 << endl;    
    return 0;
}

```









### 泛化物品

> 考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的
> 费用而变化。这就是泛化物品的概念。
>
> 在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V 中的整数的函数 h ，当分配给它的费用为 v 时，能得到的价值就是 h(v) 。

一个费用为 c 价值为 w 的物品，

- 如果它是 01 背包中的物品，那么把它看成泛化物品，它就是除了 $h(c) = w $外，其它函数值都为 0 的一个函数。
- 如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 $h(v) = w · \frac{v}{c} $，其它函数值均为 0 。
- 如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函数有 $h(v) = w ·\frac{v}{c} $ 仅当 v 被 c 整除且 vc ≤ n ，其它情况函数值均为 0 。
- 一个物品组可以看作一个泛化物品 h 。对于一个 0 . . . V 中的 v ，若物品组中不存在费用为 v 的物品，则 h(v) = 0 ，否则 h(v) 取值为所有费用为 v 的物品的最大价值。 
- 有依赖的背包问题中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。

#### **泛化物品的和**

如果给定了两个泛化物品 h 和 l ，要用一定的费用从这两个泛化物品中得到最大的价值。

对于一个给定的费用 v ，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v ，可以求得费用v 分配到 h 和 l 中的最大价值 f (v) 。也即 

$f (v) = \max\left\{h(k) + l(v − k) | 0 ≤ k ≤ v\right\}$

可以看到，这里的 f 是一个由泛化物品 h 和 l 决定的定义域为 0. . .V 的函数，也就是说， f 是一个由泛化物品 h 和 l 决定的泛化物品。

## 背包问题问法的变化

1. 以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值。
2. 求解最多可以放多少件物品或者最多可以装满多少背包的空间。
3. 如果要求的是“总价值最小”“总件数最小”，只需将状态转移方程中的 max 改成 min 即可。

### 问能否能装满背包（或者最多装多少）

dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); 

#### LC-416. 分割等和⼦集

> 给定⼀个只包含正整数的⾮空数组。是否可以将这个数组分割成两个⼦集，使得两个⼦集的元素和相等。

只要找到集合⾥能够出现 sum / 2 的⼦集总和，就算是可以分割成两个相同元素和⼦集

**01背包问题**

- 背包的体积为sum / 2
- 背包要放⼊的商品（集合⾥的元素）重量为 元素的数值，价值也为元素的数值
- 背包如何正好装满，说明找到了总和为 sum / 2 的⼦集。
- 背包中每⼀个元素是不可重复放⼊。

**算法**

1. dp[i]表示 背包总容量是i，最⼤可以凑成i的⼦集总和为dp[i]。
2. dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);



#### LC-1049. 最后⼀块⽯头的重量 II

> 有⼀堆⽯头，每块⽯头的重量都是正整数。
> 每⼀回合，从中选出任意两块⽯头，然后将它们⼀起粉碎。假设⽯头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 1. 如果 x == y，那么两块⽯头都会被完全粉碎；
>
> 2. 如果 x != y，那么重量为 x 的⽯头将会完全粉碎，⽽重量为 y 的⽯头新重量为 y-x。
>
> 最后，最多只会剩下⼀块⽯头。返回此⽯头最⼩的可能重量。如果没有⽯头剩下，就返回 0。

尽量让⽯头分成重量相同的两堆，相撞之后剩下的⽯头最⼩，这样就化解成01背包问题

1. dp[j]表示容量为j的背包，最多可以背dp[j]这么重的⽯头。
2. dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (auto &cur : stones) {
            sum += cur;
        }
        vector<int> dp(sum + 5, 0);
        for (int i = 0; i < stones.size(); i++) {
            for (int j = sum; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        int result = sum;
        for (int j = sum / 2; j >= 0; j--) {
            if (dp[j] == j) {
                result = sum - 2 * j;
                break;
            }
        }
        return result;
    }
};
```







### **输出方案**

一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。

以 01 背包为例，方程为 $F [i, v] = \max{F [i − 1, v], F [i − 1, v − C_i ] + W_i } $。再用
一个数组 $G[i, v] $，设 $G[i, v] = 0$ 表示推出$ F [i, v] $的值时是采用了方程的前一项（也即
$F [i, v] = F [i − 1, v] ）$， $G[i, v] = 1$ 表示采用了方程的后一项。注意这两项分别表示了两
种策略：未选第 i 个物品及选了第 i 个物品。

i ←N
v ← V
	while i > 0
		if G[i, v] = 0
			print 未选第 i 项物品
		else if G[i, v] = 1
			print 选了第 i 项物品
			$v ← sv − C_i$
		i ← i − 1

另外，采用方程的前一项或后一项也可以在输出方案的过程中根据 $F [i, v]$ 的值实时地求
出来。也即，不须纪录 G 数组，将上述代码中的 $G[i, v] = 0$ 改成 $F [i, v] = F [i − 1, v] ，
G[i, v] = 1$ 改成 $F[i, v] = F [i − 1][v − C_i ] + W_i $ 也可。

### **输出字典序最小的最优方案**

> 字典序最小”的意思是 1 . . . N 号物品的选择方案排列出来以后字典序最小。

如果存在一个选了物品 1 的最优方案，那么答案一定包含物品 1 ，原问题转化为一个背包容量为 $V −C_1$ ，物品为 2 . . . N 的子问题。反之，如果答案不包含物品 1 ，则转化成背包容量仍为 V ，物品为 2 . . . N的子问题。

不管答案怎样，子问题的物品都是以 i . . . N 而非前所述的 1 . . . i 的形式来定义的

### 问装满背包所有物品的最小个数

：dp[j] =  min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

* 求最小数：[动态规划：322.零钱兑换](https://mp.weixin.qq.com/s/dyk-xNilHzNtVdPPLObSeQ)
* [动态规划：279.完全平方数](https://mp.weixin.qq.com/s/VfJT78p7UGpDZsapKF_QJQ)

#### [LC-322.零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)

> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。
>
> 你可以认为每种硬币的数量是无限的。



```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.size(); j++) {
                if (coins[j] <= i) {
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
// @lc code=end


```





### **求方案总数**

> 对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。

一般只需将状态转移方程中的 max 改成 sum 即可。

事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

* [动态规划：494.目标和](https://mp.weixin.qq.com/s/2pWmaohX75gwxvBENS-NCw)
* 求组合数：[动态规划：518. 零钱兑换 II](https://mp.weixin.qq.com/s/PlowDsI4WMBOzf3q80AksQ)
* 求排列数：[动态规划：377.组合总和Ⅳ](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)
* [动态规划：70. 爬楼梯进阶版（完全背包）](https://mp.weixin.qq.com/s/e_wacnELo-2PG76EjrUakA)

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

#### LC-518. 零钱兑换 II

> 给定不同⾯额的硬币和⼀个总⾦额。写出函数来计算可以凑成总⾦额的硬币组合数。假设每⼀种⾯额的硬币有⽆限个。
>
> 输⼊: amount = 5, coins = [1, 2, 5]
> 输出: 4
> 解释: 有四种⽅式可以凑成总⾦额:
> 5=5
> 5=2+2+1
> 5=2+1+1+1
> 5=1+1+1+1+1

组合不强调元素之间的顺序，排列强调元素之间的顺序。

1. dp[j]：凑成总⾦额j的货币组合数为dp[j]
2. dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。

```cpp
for (int i = 0; i < coins.size(); i++) { // 遍历物品
	for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
		dp[j] += dp[j - coins[i]];
	}
}
//coins[0] = 1，coins[1] = 5。
//这种遍历顺序中dp[j]⾥计算的是组合数！

for (int j = 0; j <= amount; j++) { // 遍历背包容量
	for (int i = 0; i < coins.size(); i++) { // 遍历物品
	if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
	}
}

//背包容量的每⼀个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。
//此时dp[j]⾥算出来的就是排列数！
```



**如果求组合数就是外层for循环遍历物品，内层for遍历背包。**
**如果求排列数就是外层for遍历背包，内层for循环遍历物品。**

#### LC-494. ⽬标和

> 给定⼀个⾮负整数数组，a1, a2, ..., an, 和⼀个⽬标数，S。现在你有两个符号 + 和 -。对于数组中的任意⼀个整数，你都可以从 + 或 -中选择⼀个符号添加在前⾯。
>
> 返回可以使最终数组和为⽬标数 S 的所有添加符号的⽅法数。

既然为target，那么就⼀定有 left组合 - right组合 = target。

left + right等于sum，⽽sum是固定的。

left - (sum - left) = target -> left = (target + sum)/2 。

**回溯算法**

组合问题

**动态规划**

假设加法的总和为x，那么减法对应的总和就是sum - x。问题就转化为，装满容量为x背包，有⼏种⽅法。

1. dp[j] 表示：填满j（包括j）这么⼤容积的包，有dp[i]种⽅法
2. dp[j] += dp[j - nums[i]]

```cpp
int findTargetSumWays(vector<int>& nums, int S) {
	int sum = 0;
	for (int i = 0; i < nums.size(); i++) sum += nums[i];
	if (S > sum) return 0; // 此时没有⽅案
	if ((S + sum) % 2 == 1) return 0; // 此时没有⽅案
	int bagSize = (S + sum) / 2;
	vector<int> dp(bagSize + 1, 0);
	dp[0] = 1;
	for (int i = 0; i < nums.size(); i++) {
		for (int j = bagSize; j >= nums[i]; j--) {
			dp[j] += dp[j - nums[i]];
		}
	}
	return dp[bagSize];
}
```

#### 

#### [377.组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/description/)

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<long long> dp(target + 5, 0);
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (i >= nums[j]) dp[i] += dp[i - nums[j]];
                if (dp[i] > INT_MAX) break;
            }
        }
        return dp[target];
    }
};
// @lc code=end


```





### **最优方案的总数**

最优方案是指物品总价值最大的方案。

结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$F [i, v]$ 代表该状态的最大价值， $G[i, v]$ 表示这个子问题的最优方案的总数，则在求 $F [i, v]$ 的同时求 $G[i, v]$ 的伪代码如下：

$G[0, 0] ← 1$
for i ← 1 to N
	for v ← 0 to V
		$F[i, v] ← \max\left\{F [i − 1, v], F [i − 1, v − C_i ] + W_i \right\}$
		$G[i, v] ← 0$
		if F [i, v] = F [i − 1, v]
			$G[i, v] ← G[i, v] + G[i − 1][v]$
		if F [i, v] = F [i − 1, v − C_i ] + W_i
			$G[i, v] ← G[i, v] + G[i − 1][v − C_i ]$



### **求次优解、第 K 优解**

第 K 优解则比求最优解的复杂度上多一个系数 K 。

其基本思想是，将每个状态都表示成有序队列，将状态转移方程中的 max/min 转化成有序队列的合并。

$ F[i, v] = \max\{F [i − 1, v], F [i − 1, v − C_i ] + W_i \}$。如果要求第 K 优解，那么状态 F [i, v] 就应该是一个大小为 K 的队列 $F [i, v, 1 . . . K]$ 。其中 $F [i, v, k]$ 表示前 i 个物品中，背包大小为 v 时，第 k 优解的值。这里也可以简单地理解为在原来的方程中加了一维来表示结果的优先次序。显然$f [i, v, 1 . . . K]$ 这 K 个数是由大到小排列的，所以它可看作是一个有序队列。

然后原方程就可以解释为： $F [i, v]$ 这个有序队列是由 $F [i − 1, v] 和 F [i − 1,v −
C_i ] + W_i $这两个有序队列合并得到的。前者 $F [i − 1][V ]$ 即 $F [i − 1, v, 1 . . . K]$ ，后者
$F [i − 1,v − C_i ] + W_i$ 则理解为在 $F [i − 1,v − C_i , 1 . . . K]$ 的每个数上加上 $W_i$ 后得到的
有序队列。合并这两个有序队列并将结果的前 K 项储存到 $f [i, v, 1 . . . K] $中的复杂度是
$O(K)$ 。最后的第 K 优解的答案是 $F [N, V, K] $。总的时间复杂度是 $ O(V N K) $。

为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为 K 的数组，并在这个数组中有序地保存该状态可取到的前 K 个最优值。那么，对于任两个状态的max 运算等价于两个由大到小的有序队列的合并。
另外还要注意题目对于“第 K 优解”的定义，是要求将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。



## 分割类型题

#### [LC-91.解码方法](https://leetcode-cn.com/problems/decode-ways/description/)

> 一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：
>
> ```
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> ```
>
> 要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：
>
> - `"AAJF"` ，将消息分组为 `(1 1 10 6)`
> - `"KJF"` ，将消息分组为 `(11 10 6)`
>
> 注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。



```cpp
class Solution {
public:
    int numDecodings(string s) {
        int length = s.length();
        if (!length) return 0;
        int prev = s[0] - '0';
        if (!prev) return 0;
        if (length == 1) return 1;
        vector<int> dp(length + 5, 0);
        dp[1] = dp[0] = 1;
        for (int i = 2; i <= length; i++) {
            int cur = s[i - 1] - '0';
            if (!cur && (prev == 0 || prev > 2)) return 0;
            if ((prev == 1) || (prev == 2 && cur < 7)) {
                if (cur) {
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    dp[i] = dp[i - 2];
                }
            } else {
                dp[i] = dp[i - 1];
            }
            prev = cur;
        }
        return dp[length];
    }
};
// @lc code=end

```







#### LC-139.单词拆分

> 给定⼀个⾮空字符串 s 和⼀个包含⾮空单词的列表 wordDict，判定 s 是否可以被空格拆分为⼀个或多个在字典中出现的单词。
> 说明：
> 拆分时可以重复使⽤字典中的单词。
> 你可以假设字典中没有重复的单词。
> 示例 1：
> 输⼊: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

回溯算法

枚举分割所有字符串，判断是否在字典⾥出现过。

```cpp
class Solution {
private:
bool backtracking (const string& s,
const unordered_set<string>& wordSet,
vector<int>& memory,
int startIndex) {
if (startIndex >= s.size()) {
return true;
}
// 如果memory[startIndex]不是初始值了，直接使⽤memory[startIndex]的结果
if (memory[startIndex] != -1) return memory[startIndex];
for (int i = startIndex; i < s.size(); i++) {
string word = s.substr(startIndex, i - startIndex + 1);
if (wordSet.find(word) != wordSet.end() && backtracking(s, wordSet,
memory, i + 1)) {
memory[startIndex] = 1; // 记录以startIndex开始的⼦串是可以被拆分的
return true;
}
}
memory[startIndex] = 0; // 记录以startIndex开始的⼦串是不可以被拆分的
return false;
}
public:
bool wordBreak(string s, vector<string>& wordDict) {
unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
vector<int> memory(s.size(), -1); // -1 表示初始化状态
return backtracking(s, wordSet, memory, 0);
}
```



背包问题

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

1. dp[i] : 字符串⻓度为i的话，dp[i]为true，表示可以拆分为⼀个或多个在字典中出现的单词。
2. if([j, i] 这个区间的⼦串出现在字典⾥ && dp[j]是true) 那么 dp[i] = true。

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (wordSet.find(s.substr(j, i - j)) != wordSet.end() && dp[j] == true) {
                    dp[i] = true;
                    break;
                }
            }

        }
        return dp[s.size()];
    }
};
```

#### 划分数

> 有 n个无 区别的 物品，将它们 划分成不超过m组 ，求出划分方法数模M的余数



## 股票交易



#### 121. 买卖股票的最佳时机

> 给定⼀个数组 prices ，它的第 i 个元素 prices[i] 表示⼀⽀给定股票第 i 天的价格。
> 你只能选择 某⼀天 买⼊这只股票，并选择在 未来的某⼀个不同的⽇⼦ 卖出该股票。设计⼀个算法来计算你所能获取的最⼤利润。
> 返回你可以从这笔交易中获取的最⼤利润。如果你不能获取任何利润，返回 0 。

**股票只能买卖一次，问最大利润**。

【贪心解法】

取最左最小值，取最右最大值，那么得到的差值就是最大利润，代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

【动态规划】

1. $dp[i][0]$ 表示第i天持有股票所得现金。

   $dp[i][1]$ 表示第i天不持有股票所得现金。

2. 如果第i天持有股票即$dp[i][0]$， 那么可以由两个状态推出来

   * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：$dp[i - 1][0]$
   * 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
     所以$dp[i][0] = max(dp[i - 1][0], -prices[i])$;

   如果第i天不持有股票即$dp[i][1]$， 也可以由两个状态推出来

   * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：$dp[i - 1$][1]
   * 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：$prices[i] + dp[i - 1][0]$
     所以 $dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])$;

代码如下：

```C++
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

使用滚动数组，代码如下：

```C++
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```


#### 122.买卖股票的最佳时机II

>给定⼀个数组，它的第 i 个元素是⼀⽀给定股票第 i 天的价格。
>设计⼀个算法来计算你所能获取的最⼤利润。你可以尽可能地完成更多的交易（多次买卖⼀⽀股票）。
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**可以多次买卖股票，问最大收益。**


【贪心解法】

收集每天的正利润便可，代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```


【动态规划】

1. $dp[i][0]$ 表示第i天持有股票所得现金。

   $dp[i][1]$ 表示第i天不持有股票所得现金。

2. 如果第i天持有股票即$dp[i][0]$， 那么可以由两个状态推出来

   * 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：$dp[i - 1][0]$
   * 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格即：$dp[i - 1][1] - prices[i]$

   如果第i天不持有股票即$dp[i][1]$， 也可以由两个状态推出来

   * 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：$dp[i - 1$][1]
   * 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：$prices[i] + dp[i - 1][0]$
     所以 $dp[i][1] = \max(dp[i - 1][1], prices[i] + dp[i - 1][0])$;

**推导 $dp[i][0]$** 

- 因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。
- 因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即 $dp[i][0]$ 一定就是 -prices[i]。

代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```




#### 123.买卖股票的最佳时机III

>给定⼀个数组，它的第 i 个元素是⼀⽀给定的股票在第 i 天的价格。
>设计⼀个算法来计算你所能获取的最⼤利润。你最多可以完成 两笔 交易。
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**最多买卖两次，问最大收益。**

【动态规划】

一天一共就有五个状态，

0. 没有操作
1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

$dp[i][j]$中 i表示第i天，j为 [0 - 4] 五个状态，$dp[i][j]$ 表示第i天状态j所剩最大现金。


达到$dp[i][1]$ 状态，有两个具体操作：

* 操作一：第i天买入股票了，那么$dp[i][1] = dp[i-1][0] - prices[i]$
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：$dp[i][1] = dp[i - 1][1]$

$dp[i][1] = \max(dp[i-1][0] - prices[i], dp[i - 1][1])$;

同理$dp[i][2]$也有两个操作：

* 操作一：第i天卖出股票了，那么 $dp[i][2] = dp[i - 1][1] + prices[i]$
* 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：$dp[i][2] = dp[i - 1$][2]

所以$dp[i][2] = \max(dp[i - 1][1] + prices[i], dp[i - 1][2])$

同理可推出剩下状态部分：

$dp[i][3] = \max(dp[i - 1][3], dp[i - 1][2] - prices[i]);$
$dp[i][4] = \max(dp[i - 1][4], dp[i - 1][3] + prices[i]);$

代码如下：

```C++
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```



一种优化空间写法，对应的C++版本：

```C++
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```



#### 188.买卖股票的最佳时机IV

> 给定⼀个整数数组 prices ，它的第 i 个元素 prices[i] 是⼀⽀给定的股票在第 i 天的价格。
> 设计⼀个算法来计算你所能获取的最⼤利润。你最多可以完成 k 笔交易。
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**最多买卖k笔交易，问最大收益。**

使用二维数组 dp[i][j] ：第i天的状态为v，所剩下的最大现金是dp[i][j]

j的状态表示为：

* 0 表示不操作
* 1 第一次买入
* 2 第一次卖出
* 3 第二次买入
* 4 第二次卖出
* .....

**除了0以外，偶数就是卖出，奇数就是买入**。


2. 确定递推公式

达到 $dp[i][1]$ 状态，有两个具体操作：

* 操作一：第i天买入股票了，那么 $dp[i][1] = dp[i - 1][0] - prices[i]$
* 操作二：第i天没有操作，而是沿用前一天买入的状态，即：$dp[i][1] = dp[i - 1][1]$

$dp[i][1] = \max(dp[i - 1][0] - prices[i], dp[i - 1][0]);$

同理dp[i][2]也有两个操作：

* 操作一：第i天卖出股票了，那么 $dp[i][2] = dp[i - 1][1] + prices[i]$
* 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：$dp[i][2] = dp[i - 1][2]$

$dp[i][2] = \max(dp[i - 1][i] + prices[i], dp[i][2])$

同理可以类比剩下的状态，代码如下：

```C++
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

整体代码如下：

```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

当然有的解法是定义一个三维数组$dp[i][j][k]$，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。但感觉三维数组操作起来有些麻烦，直接用二维数组来模拟三位数组的情况，代码看起来也清爽一些。

#### 309.最佳买卖股票时机含冷冻期 

> 给定⼀个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
> 设计⼀个算法计算出最⼤利润。在满⾜以下约束条件下，你可以尽可能地完成更多的交易（多次买卖⼀⽀股票）:
>
> - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> - 卖出股票后，你⽆法在第⼆天买⼊股票 (即冷冻期为 1 天)。

**可以多次买卖但每次卖出有冷冻期1天。**

相对于`122.买卖股票的最佳时机II` 本题加上了一个冷冻期。

在`122.买卖股票的最佳时机II` 中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。

本题则可以花费为四个状态

$dp[i][j]$ ：第i天状态为j，所剩的最多现金为 $dp[i][j]$。

具体可以区分出如下四个状态：

* 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
* 卖出股票状态，这里就有两种卖出股票状态
  * 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
  * 状态三：今天卖出了股票
* 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！


达到买入股票状态（状态一）即：$dp[i][0]$，有两个具体操作：

* 操作一：前一天就是持有股票状态（状态一），$dp[i][0] = dp[i - 1][0]$
* 操作二：今天买入了，有两种情况
  * 前一天是冷冻期（状态四），$dp[i - 1][3] - prices[i]$
  * 前一天是保持卖出股票状态（状态二），$dp[i - 1][1] - prices[i]$

所以操作二取最大值，即：$\max(dp[i - 1][3], dp[i - 1][1]) - prices[i]$

那么$dp[i][0] = \max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);$

达到保持卖出股票状态（状态二）即：$dp[i][1]$，有两个具体操作：

* 操作一：前一天就是状态二
* 操作二：前一天是冷冻期（状态四）

$dp[i][1] = \max(dp[i - 1][1], dp[i - 1][3]);$

达到今天就卖出股票状态（状态三），即：$dp[i][2] $，只有一个操作：

* 操作一：昨天一定是买入股票状态（状态一），今天卖出

即：$dp[i][2] = dp[i - 1][0] + prices[i];$

达到冷冻期状态（状态四），即：$dp[i][3]$，只有一个操作：

* 操作一：昨天卖出了股票（状态三）

$dp[i][3] = dp[i - 1][2];$

综上分析，递推代码如下：

```C++
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i];
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

整体代码如下：

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)

#### 714.买卖股票的最佳时机含⼿续费

> 给定⼀个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；⾮负整数 fee 代表了交易股票的⼿续费⽤。
> 你可以⽆限次地完成交易，但是你每笔交易都需要付⼿续费。如果你已经购买了⼀个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最⼤值。
> 注意：这⾥的⼀笔交易指买⼊持有并卖出股票的整个过程，每笔交易你只需要为⽀付⼀次⼿续费。

**可以多次买卖，但每次有手续费。**


相对于`122.买卖股票的最佳时机II`，本题只需要在计算卖出操作的时候减去手续费就可以了，

唯一差别在于递推公式部分

这里重申一下dp数组的含义：

$dp[i][0] $表示第i天持有股票所省最多现金。
$dp[i][1]$ 表示第i天不持有股票所得最多现金

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```



## 打家劫舍系列

#### 198.打家劫舍

>你是⼀个专业的⼩偷，计划偷窃沿街的房屋。每间房内都藏有⼀定的现⾦，影响你偷窃的唯⼀制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同⼀晚上被⼩偷闯⼊，系统会⾃动报警。
>给定⼀个代表每个房屋存放⾦额的⾮负整数数组，计算你不触动警报装置的情况下 ，⼀夜之内能够偷窃到的最⾼⾦额。
>示例 1：
>输⼊：[1,2,3,1]
>输出：4
>解释：偷窃 1 号房屋 (⾦额 = 1) ，然后偷窃 3 号房屋 (⾦额 = 3)。
>偷窃到的最⾼⾦额 = 1 + 3 = 4 。
>示例 2：
>输⼊：[2,7,9,3,1]
>输出：12
>解释：偷窃 1 号房屋 (⾦额 = 2), 偷窃 3 号房屋 (⾦额 = 9)，接着偷窃 5 号房屋 (⾦额 = 1)。



1. dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的⾦额为dp[i]。

2. 决定dp[i]的因素就是第i房间偷还是不偷。

   dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);



```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (!nums.size()) return 0;
        int size = nums.size();
        if (size == 1) return nums[0];
        vector<int> dp(size, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[size - 1];
    }
};
```





#### 213.打家劫舍II

> 你是⼀个专业的⼩偷，计划偷窃沿街的房屋，每间房内都藏有⼀定的现⾦。这个地⽅所有的房屋都 **围成⼀圈** ，这意味着第⼀个房屋和最后⼀个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同⼀晚上被⼩偷闯⼊，系统会⾃动报警 。
> 给定⼀个代表每个房屋存放⾦额的⾮负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最⾼⾦额



1. 情况⼀：考虑不包含⾸尾元素
2. 情况⼆：考虑包含⾸元素，不包含尾元素
3. 情况三：考虑包含尾元素，不包含⾸元素

情况三怎么就包含了情况⼀了呢？ 本⽂图中最后⼀间房不能偷啊，偷了⼀定不是最优结果。



```cpp
class Solution {
public:
    int handle(vector<int> &nums, int l, int r) {
        vector<int> dp(nums.size(), 0);
        dp[l] = nums[l];
        dp[l + 1] = max(nums[l], nums[l + 1]);
        for (int i = l + 2; i < r; i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[r - 1];
    }
    int rob(vector<int>& nums) {
        int size = nums.size();
        if (size == 0) return 0;
        if (size == 1) return nums[0];
        if (size == 2) return max(nums[0], nums[1]);
        return max(handle(nums, 0, size - 1), handle(nums, 1, size));
    }
};
```





#### 337.打家劫舍 III

> 在上次打劫完⼀条街道之后和⼀圈房屋后，⼩偷⼜发现了⼀个新的可⾏窃的地区。这个地区只有⼀个⼊⼝，我们称之为“根”。 除了“根”之外，每栋房⼦有且只有⼀个“⽗“房⼦与之相连。⼀番侦察之后，聪明的⼩偷意识到“这个地⽅的所有房屋的排列类似于⼀棵⼆叉树”。 如果两个直接相连的房⼦在同⼀天晚上被打劫，房屋将⾃动报警。
> 计算在不触动警报的情况下，⼩偷⼀晚能够盗取的最⾼⾦额。

对于树的话，⾸先就要想到遍历⽅式，前中后序（深度优先搜索）还是层序遍历（⼴度优先搜索）。

**本题⼀定是要后序遍历，因为通过递归函数的返回值来做下⼀步计算。**

**记忆化递推**

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        Node ans = calc(root);
        return max(ans.x, ans.y);
    }
private : 
    struct Node {
        int x, y;
        Node() : Node(0, 0) {}
        Node(int x, int y) : x(x), y(y) {}
    };
    Node calc(TreeNode *root) {
        if (!root) return Node(0, 0);
        Node l = calc(root->left);
        Node r = calc(root->right);
        int x = root->val + l.y + r.y;
        int y = max(l.x, l.y) + max(r.x , r.y);
        return Node(x, y);
    }
};
```



1. ⼀个节点 偷与不偷的两个状态所得到的⾦钱，那么返回值就是⼀个⻓度为2的数组。`vector<int> robTree(TreeNode* cur)`
   下标为0记录不偷该节点所得到的的最⼤⾦钱，下标为1记录偷该节点所得到的的最⼤⾦钱。

2. ⾸先明确的是使⽤后序遍历。 因为通过递归函数的返回值来做下⼀步计算。
   通过递归左节点，得到左节点偷与不偷的⾦钱。
   通过递归右节点，得到右节点偷与不偷的⾦钱。

3. ```s
   vector<int> left = robTree(cur->left); // 左
   vector<int> right = robTree(cur->right); // 右
   // 偷cur
   int val1 = cur->val + left[0] + right[0];
   // 不偷cur
   int val2 = max(left[0], left[1]) + max(right[0], right[1]);
   return {val2, val1};
   ```



## 回文

#### 647. 回⽂⼦串

> 给定⼀个字符串，你的任务是计算这个字符串中有多少个回⽂⼦串。
> 具有不同开始位置或结束位置的⼦串，即使是由相同的字符组成，也会被视作不同的⼦串。

`动态规划`

1. 布尔类型的 $dp[i][j]$ ：表示区间范围[i,j] （注意是左闭右闭）的⼦串是否是回⽂⼦串，如果是 $dp[i][j]$ 为true，否则为false。

2. ```cpp
   if (s[i] == s[j]) {
   	if (j - i <= 1) { // 情况⼀ 和 情况⼆
   		result++;
   		dp[i][j] = true;
   	} else if (dp[i + 1][j - 1]) { // 情况三
   		result++;
   		dp[i][j] = true;
   	}
   }
   ```

   

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int ans = 0, n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        for (int d = 0; d < n; d++) {
            for (int i = 0; i + d < n; i++) {
                int j = i + d;
                if (s[i] != s[j]) continue;
                if (d == 0 || d == 1) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                if (dp[i][j]) ans++;
            }
        }
        return ans;
    }
};
```



`双指针法`

⾸先确定回⽂串，就是找中⼼然后想两边扩散看是不是对称

在遍历中⼼点的时候，⼀个元素可以作为中⼼点，两个元素也可以作为中⼼点。



```cpp
int countSubstrings(string s) {
    int count = 0;
    for (int i = 0; i < s.length(); ++i) {
        count += extendSubstrings(s, i, i); // 奇数长度
        count += extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return count;
}
int extendSubstrings(string s, int l, int r) {
    int count = 0;
    while (l >= 0 && r < s.length() && s[l] == s[r]) {
        --l;
        ++r;
        ++count;
    }
    return count;
}
```





#### 516.最⻓回⽂⼦序列

> 给定⼀个字符串 s ，找到其中最⻓的回⽂⼦序列，并返回该序列的⻓度。可以假设 s 的最⼤⻓度为 1000



1. $dp[i][j]$ ：字符串s在[i, j]范围内最⻓的回⽂⼦序列的⻓度为 $dp[i][j]$。

2. ```cpp
   if (s[i] == s[j]) {
   	dp[i][j] = dp[i + 1][j - 1] + 2;
   } else {
   	dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
   }
   ```

   

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int size = s.size();
        vector<vector<int> > dp(size, vector<int>(size, 0));
        for (int i = 0; i < size; i++) {
            dp[i][i] = 1;
        }
        for (int l = 1; l < size; l++) {
            // starting index of window
            for (int i = 0; i < size - l; i++) {
                // ending index of window
                int j = i + l;
                if (j - i + 1 == 2) {
                    dp[i][j] = 1 + (s[i] == s[j]);
                } else {
                    if (s[i] == s[j]) {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    } else {
                        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                    }
                }
            }
        }
        return dp[0][size - 1];
    }
};
```



```cpp
状态
f[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列长度是多少。

转移方程
如果 s 的第 i 个字符和第 j 个字符相同的话

f[i][j] = f[i + 1][j - 1] + 2

如果 s 的第 i 个字符和第 j 个字符不同的话

f[i][j] = max(f[i + 1][j], f[i][j - 1])

然后注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i + 1 开始往后遍历，这样可以保证每个子问题都已经算好了。

初始化
f[i][i] = 1 单个字符的最长回文序列是 1

结果
f[0][n - 1]
```



```cpp
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] f = new int[n][n];
        for (int i = n - 1; i >= 0; i--) {
            f[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    f[i][j] = f[i + 1][j - 1] + 2;
                } else {
                    f[i][j] = Math.max(f[i + 1][j], f[i][j - 1]);
                }
            }
        }
        return f[0][n - 1];
    }
}
```

