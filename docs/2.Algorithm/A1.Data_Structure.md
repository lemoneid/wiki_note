---
id : A1.DataStructure
title : A1.DataStructure
typora-root-url : ../
---

# æ•°æ®ç»“æ„å’Œç®—æ³•



# 1. ==æ ˆå’Œé˜Ÿåˆ—==

#### 1.0.0.1. hzoj-372-åŒç”Ÿé˜Ÿåˆ—

**RMQ ( Range Minimum / Maximum Query ) é—®é¢˜**æ˜¯æŒ‡ï¼šå¯¹äºé•¿åº¦ä¸º n çš„æ•°åˆ— Aï¼Œå›ç­”è‹¥å¹²è¯¢é—® RMQ (A , i , j ) ( i , j â‰¤ n)ï¼Œè¿”å›æ•°åˆ—Aä¸­ä¸‹æ ‡åœ¨ i , j é‡Œçš„**æœ€å°ï¼ˆå¤§ï¼‰å€¼**ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒRMQé—®é¢˜æ˜¯æŒ‡æ±‚**åŒºé—´æœ€å€¼**çš„é—®é¢˜ã€‚

å•è°ƒé˜Ÿåˆ—è§£å†³å›ºå®šæœ«å°¾ï¼²ï¼­ï¼±é—®é¢˜

```c
int a[MAX_N + 5], b[MAX_N + 5];
int main() {
    int n, p = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    int top1 = -1, top2 = -1;
    while (p < n) {
        while (top1 != -1 && a[p] < a[top1]) --top1;
        while (top2 != -1 && b[p] < b[top2]) --top2;
        a[++top1] = a[p];
        b[++top2] = b[p];
        p += 1;
    }
    cout << p << endl;
    return 0;
}

```

#### 1.0.0.2. leetcode-20-æ‹¬å·åŒ¹é…

```c
 bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }
        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
```

```c
bool isValid(char * s){
    int len = strlen(s);
    char*stack = (char *)malloc(sizeof(char) * len);
    int top = -1, flag = 1;
    for (int i = 0; i < len; ++i) {
        switch (s[i]) {
            case '(' : 
            case '[' : 
            case '{' : 
                stack[++top] = s[i]; 
                break;
            case ')' :
                flag = (top != -1 && stack[top--] == '(' );
                break;
            case ']' :
                flag = (top != -1 && stack[top--] == '[' );
                break;
            case '}' :
                flag = (top != -1 && stack[top--] == '{');
                break;
        }
        if (!flag) return false;
    }
    return top == -1;
}
```

#### 1.0.0.3. LC-221-æœ€å¤§æ­£æ–¹å½¢-dp,å•è°ƒæ ˆ

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
};


int maximalSquare(char** matrix, int matrixRowSize, int matrixColSizes) {
    int n = matrixRowSize, m = matrixColSizes;
    if (n == 0) return 0;
    int **cnt = (int **)malloc(sizeof(int *) * n);
    int *q = (int *)malloc(sizeof(int) * m);
    int head, tail, l;
    for (int i = 0; i < n; i++) cnt[i] = (int *)malloc(sizeof(int) * m);
    for (int i = 0; i < m; i++) cnt[0][i] = (matrix[0][i] == '1');
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cnt[i][j] = (matrix[i][j] == '1' ? cnt[i - 1][j] + 1 : 0);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        head = tail = 0;
        l = 0;
        for (int j = 0; j < m; j++) {
            while (tail - head > 0 && cnt[i][q[tail - 1]] > cnt[i][j]) --tail;
            q[tail++] = j;       
            while (j - l >= 0 && j - l + 1 > cnt[i][q[head]]) {
                ++l;
                if (q[head] < l) ++head;
            }
            ans = fmax(ans, (j - l + 1) * (j - l + 1));    
        }
    }
    for (int i = 0; i < n; i++) free(cnt[i]);
    free(cnt);
    free(q);
    return ans;
}
```

#### 1.0.0.4. LC-42-æ¥é›¨æ°´-å•è°ƒæ ˆ

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> stk;
        int ans = 0;
        for (int i = 0; i < height.size(); ++i) {
            while (!stk.empty() && height[stk.top()] <= height[i]) {
                int cur = stk.top();
                stk.pop();
                if (stk.empty()) break;
                int width = i - stk.top() - 1;
                int h = min(height[i], height[stk.top()]) - height[cur];
                ans += width * h;
            } 
            stk.push(i);
        }
        return ans;
    }
};
```

#### 1.0.0.5. LC-102-å±‚åºéå†

#### 1.0.0.6. ç¤ºä¾‹ï¼š

äºŒå‰æ ‘ï¼š[3,9,20,null,null,15,7],

â€‹    3
   / \
  9  20
â€‹    /  \
   15   7
è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š

[
  [3],
  [9,20],
  [15,7]
]

```cpp
int getDepth(struct TreeNode *root) {
    if (root == NULL) return 0;
    int l = getDepth(root->left), r = getDepth(root->right);
    return (l > r ? l : r) + 1;
}

void getCnt(struct TreeNode *root, int k, int *cnt) {
    if (root == NULL) return ;
    cnt[k] += 1;
    getCnt(root->left, k + 1, cnt);
    getCnt(root->right, k + 1, cnt);
    return ;
}

void getResult(struct TreeNode *root, int k, int *cnt, int **ret) {
    if (root == NULL) return ;
    ret[k][cnt[k]++] = root->val;
    getResult(root->left, k + 1, cnt, ret);
    getResult(root->right, k + 1, cnt, ret);
    return ;
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** columnSizes) {
    int depth = getDepth(root);
    int *cnt = (int *)calloc(sizeof(int), depth);
    int **ret = (int **)malloc(sizeof(int *) * depth);
    getCnt(root, 0, cnt);
    for (int i = 0; i < depth; i++) {
        ret[i] = (int *)malloc(sizeof(int) * cnt[i]);
        cnt[i] = 0;
    }
    getResult(root, 0, cnt, ret);
    *returnSize = depth;
    *columnSizes = cnt;
    return ret;
}
```

#### 1.0.0.7. åˆ¤å¹³è¡¡äºŒå‰æ ‘

```c
int maxDepth(struct TreeNode* root) {
    if (root == NULL) return 0;
    int d1 = maxDepth(root->left);
    int d2 = maxDepth(root->right);
    if (d1 == -2 || d2 == -2 || abs(d1 - d2) > 1) return -2;
    return fmax(d1, d2) + 1;
}

bool isBalanced(struct TreeNode* root) {
    return maxDepth(root) >= 0;
```

#### 1.0.0.8. æ±‚è·¯å¾„å’Œ

```c
bool hasPathSum(struct TreeNode* root, int sum) {
    if (root == NULL) return false;
    if (root->left == 0 && root->right == NULL) return root->val == sum;
    return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
}
```

#### 1.0.0.9. æœ€è¿‘å…¬å…±ç¥–å…ˆ

```c
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL || root == p || root == q) {
        return root;
    }
    struct TreeNode *left = lowestCommonAncestor(root->left, p, q);
    struct TreeNode *right = lowestCommonAncestor(root->right, p, q);
    if (left && right) {
        return root;
    }
    return left ? left : right;
}
```

#### 1.0.0.10. äºŒå‰æ’åºæœç´¢æ ‘

```cpp
struct TreeNode* __lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root->val == p->val) return p;
    if (root->val == q->val) return q;
    if (p->val < root->val && q->val > root->val) return root;
    if (p->val > root->val) return __lowestCommonAncestor(root->right, p, q);
    return __lowestCommonAncestor(root->left, p, q);
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL) return NULL;
    if (p->val == q->val) return p;
    if (p->val > q->val) {
        struct TreeNode *temp = p;
        p = q;
        q = temp;
    }
    return __lowestCommonAncestor(root, p, q);
}
```



#### 1.0.0.11. äºŒå‰æ ‘æ‰€æœ‰è·¯å¾„-haffmanæ ‘

```c
int getPathCnt(struct TreeNode *root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return 1;
    return getPathCnt(root->left) + getPathCnt(root->right);
}

int getResult(struct TreeNode *root, int len, int k, char **ret, char *buff) {
    if (root == NULL) return 0;
    len += sprintf(buff + len, "%d", root->val);
    buff[len] = 0;
    if (root->left == NULL && root->right == NULL) {
        ret[k] = strdup(buff);
        return 1;
    }
    len += sprintf(buff + len, "->");
    int cnt = getResult(root->left, len, k, ret, buff);
    cnt += getResult(root->right, len, k + cnt, ret, buff);
    return cnt;
}

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    int pathCnt = getPathCnt(root);
    char **ret = (char **)malloc(sizeof(char *) * pathCnt);
    int max_len = 10000;
    char *buff = (char *)malloc(sizeof(char) * max_len);
    getResult(root, 0, 0, ret, buff);
    free(buff);
    *returnSize = pathCnt;
    return ret;
}
```



#### 1.0.0.12. å¹¿ä¹‰è¡¨è½¬äºŒå‰æ ‘

```cpp
Node *build(char *str, int *node_num) {
    Node *temp = NULL, *p = NULL;
    Stack *s = init_stack(strlen(str));
    int flag = 0;
    while (str[0]) {
        switch (str[0]) {
            case '(':
                push(s, temp);
                flag = 0;
                temp = NULL;
                break;
            case ')':
                p = top(s);
                pop(s);
                break;
            case ',':
                flag = 1;
                temp = NULL;
                break;
            case ' ':
                break;
            default:
                temp = getNewNode(str[0]);
                if (!empty(s) && flag == 0) {
                    top(s)->lchild = temp;
                } else if (!empty(s) && flag == 1) {
                    top(s)->rchild = temp;
                }
                ++(*node_num);
            break;
        }
        ++str;
    }
    clear_stack(s);
    if (temp && !p) p = temp;
    return p;
}

```

#### 1.0.0.13. äºŒå‰æ ‘ä¸­åºçº¿ç´¢åŒ–

```cpp
void build_thread(Node *root) {
    if (root == NULL) return ;
    static Node *pre = NULL;
    build_thread(root->lchild);
    if (root->lchild == NULL) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    build_thread(root->rchild);
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == NORMAL) clear(root->lchild);
    if (root->rtag == NORMAL) clear(root->rchild);
    free(root);
    return ;
}

Node *leftMost(Node *p) {
    while (p && p->ltag == NORMAL && p->lchild) p = p->lchild;
    return p;
}

void output(Node *root) {
    Node *p = leftMost(root);
    while (p) {
        printf("%d ", p->key);
        if (p->rtag == THREAD) {
            p = p->rchild;
        } else {
            p = leftMost(p->rchild);
        }
    }
    printf("\n");
    return ;
}
```

#### 1.0.0.14. äºŒå‰æ ‘å…ˆåºçº¿ç´¢åŒ–

```cpp
void buildThead(Node *root) {
    if (!root) return ;
    static Node *pre = nullptr;
    if (root->lchild == nullptr) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    
    if (pre != nullptr && pre->rchild == nullptr) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    if (root->ltag == NORMAL) buildThead(root->lchild);
    if (root->rtag == NORMAL) buildThead(root->rchild);
    return ;
}

void clear(Node *root) {
    if (!root) return ;
    if (root->ltag == NORMAL) clear(root->lchild);
    if (root->rtag == NORMAL) clear(root->rchild);
    free(root);
    return ;
}

Node *leftMost(Node *p) {
    while (p && p->ltag == NORMAL && p->lchild) p = p->lchild;
    return p;
}

void output(Node *root) {
    if (!root) return ;
    //Node *p = leftMost(root);
    Node *p = root;
    while (p) {
        printf("%d ", p->key);
        if (p->ltag == NORMAL) {
            p = p->lchild;
        } else {
            p = p->rchild;
        }
    }
    printf("\n");
    return ;
}

```

#### 1.0.0.15. morriséå†

```cpp
void morrisPre(Node *root) {
    if (!root) return ;
    Node *cur = root, *mostRight = nullptr;
    while (cur) {
        mostRight = cur->lchild;
        if (mostRight) {
            while (mostRight->rchild && mostRight->rchild != cur) {
                mostRight = mostRight->rchild;
            }
            if (mostRight->rchild == nullptr) {
                mostRight->rchild = cur;
                cout << cur->key << " ";
                cur = cur->lchild;
                continue;
            } else {
                mostRight->rchild =nullptr;
            }
        } else {
            cout << cur->key << " ";
        }
        cur = cur->rchild;
    }
    cout << endl;
}

void morrisIn(Node *root) {
    if (!root) return ;
    Node *cur = root, *mostRight = nullptr;
    while (cur) {
        mostRight = cur->lchild;
        if (mostRight) {
            while (mostRight->rchild && mostRight->rchild != cur) {
                mostRight = mostRight->rchild;
            }
            if (mostRight->rchild == nullptr) {
                mostRight->rchild = cur;
                cur = cur->lchild;
                continue ;
            } else {
                mostRight->rchild = nullptr;
            }
        }
        cout << cur->key << " ";
        cur = cur->rchild;
    }
    return ;
}

```





# 2. ==å“ˆå¼—æ›¼æ ‘ä¸å“ˆå¼—æ›¼ç¼–ç ==

- è¯¾ç¨‹èŠ‚å¥

1. ç›´è§‚çš„äº†è§£å“ˆå¼—æ›¼æ ‘ä¸å“ˆå¼—æ›¼ç¼–ç 
2. è¯æ˜ï¼šå“ˆå¼—æ›¼ç¼–ç æ˜¯æœ€ä¼˜çš„å˜é•¿ç¼–ç 



### 2.0.1. ä»€ä¹ˆæ˜¯ç¼–ç 

'a' = 97 = $(0110\ 0001)_2$

'0' = 48 = $(0011\ 0000)_2$

æ³¨æ„ï¼šä»»ä½•ä¿¡æ¯ï¼Œåœ¨è®¡ç®—æœºä¸­ï¼Œéƒ½æ˜¯äºŒè¿›åˆ¶å­˜å‚¨çš„



ä¿¡æ¯ï¼š"aa00" = $01100001ã€01100001ã€00110000ã€00110000$

ä¸€å°è®¡ç®—æœº   ä¼ è¾“åˆ°  å¦å¤–ä¸€å°è®¡ç®—æœºï¼Œä¼ è¾“ 32 ä¸ªæ¯”ç‰¹ä½

å‡è®¾ï¼šè®¡ç®—æœºçš„ç½‘ç»œæ˜¯ 32bit/sã€‚æ‰€ä»¥ç”¨æ—¶ï¼š1 s



ç‰¹å®šåœºé™ï¼šåªæœ‰ a,b,0,1 å››ç§å­—ç¬¦éœ€è¦ä¼ è¾“

æµ·è´¼ç­ç¼–ç ï¼ša:00, b: 01, 0: 10, 1: 11

"aa00" = 00001010

åœ¨å¸¦å®½ä¸å˜çš„æƒ…å†µä¸‹ï¼Œå½“å‰åªéœ€è¦ä¼ è¾“ 0.25s



### 2.0.2. å®šé•¿ä¸å˜é•¿ç¼–ç 

1. Ascii ç¼–ç  å’Œ ç‰¹å®šåœºæ™¯ä¸‹çš„æµ·è´¼ç­ç¼–ç ï¼Œéƒ½å±äºå®šé•¿ç¼–ç 
2. å¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œç¼–ç é•¿åº¦ç›¸åŒï¼Œè¿™å°±æ˜¯å®šé•¿ç¼–ç 
3. ã€å¤§å®¶è‡ªè¡Œè¡¥å……ã€‘UTF-8ç¼–ç ï¼Œæ˜¯å˜é•¿ç¼–ç ï¼ŒUTF-16ï¼Œæ˜¯å®šé•¿ç¼–ç 
4. å¯¹äºæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œç¼–ç é•¿åº¦ä¸ç›¸åŒï¼Œè¿™å°±æ˜¯å˜é•¿ç¼–ç 
5. å°†å®šé•¿ç¼–ç ï¼Œçœ‹æˆæ˜¯å˜é•¿ç¼–ç çš„ç‰¹ä¾‹
6. å˜é•¿ç¼–ç ï¼Œä¸€å®šä¸å·®äºå®šé•¿ç¼–ç 



### 2.0.3. å˜é•¿ç¼–ç åº”ç”¨åœºæ™¯

ç‰¹å®šåœºé™ï¼š

1. åªæœ‰å››ç§å­—ç¬¦ : ab01
2. a: 0.8, b: 0.05, 0: 0.1, 1: 0.05

å¹³å‡ç¼–ç é•¿åº¦ï¼š

$l_i$ï¼šç¬¬ i ç§å­—ç¬¦ï¼Œç¼–ç é•¿åº¦

$p_i$ï¼šç¬¬ i ç§å­—ç¬¦ï¼Œå‡ºç°æ¦‚ç‡

$avg(l) = \sum{l_i}\times{p_i}$



å‡è®¾ï¼Œå¹³å‡ç¼–ç é•¿åº¦ï¼š1.16ï¼Œä¼°ç®—ä¼ è¾“100ä¸ªå­—ç¬¦ï¼Œéœ€è¦ä¼ è¾“116ä¸ªæ¯”ç‰¹ä½



æµ·è´¼ç­ç¼–ç çš„å¹³å‡ç¼–ç é•¿åº¦ï¼š$avg(l) = 2\times\sum{p_i}=2$



æ–°Â·æµ·è´¼ç­ç¼–ç ï¼š

a: 1

b: 01

0: 000

1: 001



å¹³å‡ç¼–ç é•¿åº¦ï¼š$1*0.8+2*0.05+3*0.1+3*0.05=1.35$



100ä¸ªå­—ç¬¦ï¼Œä¼ è¾“135ä¸ªæ¯”ç‰¹ä½





## 2.1. ä¸‰ã€å“ˆå¼—æ›¼ç¼–ç 

1. é¦–å…ˆï¼Œç»Ÿè®¡å¾—åˆ°æ¯ä¸€ç§å­—ç¬¦çš„æ¦‚ç‡
2. å°† n ä¸ªå­—ç¬¦ï¼Œå»ºç«‹æˆä¸€æ£µå“ˆå¼—æ›¼æ ‘
3. æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œéƒ½è½åœ¨å¶å­ç»“ç‚¹ä¸Šï¼Œæ‰€ä»¥æ²¡æœ‰ä¸€ä¸ªç¼–ç æ˜¯å…¶ä»–ç¼–ç çš„å‰ç¼€
4. æŒ‰ç…§å·¦0ï¼Œå³1çš„å½¢å¼ï¼Œå°†ç¼–ç è¯»å–å‡ºæ¥



å¾—åˆ°æ–°ç¼–ç ï¼š

a: 0 | b: 110 | 0: 10 | 1: 111

å¹³å‡ç¼–ç é•¿åº¦ï¼š$1*0.8+3*0.05+2*0.1+3*0.05=1.3$



ç»“è®ºï¼šå“ˆå¼—æ›¼ç¼–ç ï¼Œæ˜¯æœ€ä¼˜çš„å˜é•¿ç¼–ç 



## 2.2. å››ã€å…¬å¼è¯æ˜

1. é¦–å…ˆè¡¨ç¤ºå¹³å‡ç¼–ç é•¿åº¦ï¼Œæ±‚è§£å…¬å¼æœ€ä¼˜è§£
2. æœ€ç»ˆï¼Œå’Œç†µä¸äº¤å‰ç†µä¹‹é—´çš„å…³ç³»



```cpp
typedef struct Node {
    char ch;
    double p;
    struct Node *next[2];
} Node;

typedef struct Code {
    char ch;
    char *str;
} Code;

typedef struct Haffman_Tree {
    Node *root;
    int n;
    Code *codes;
} Haffman_Tree;

typedef struct Data {
    char ch;
    double p;
} Data;

Data arr[max_n + 5];

Node *getNewNode(Data *obj) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->ch = (obj ? obj->ch : 0);
    p->p = (obj ? obj->p : 0);
    p->next[0] = p->next[1] = NULL;
    return p;
}

Haffman_Tree *getNewTree(int n) {
    Haffman_Tree *tree = (Haffman_Tree *)malloc(sizeof(Haffman_Tree));
    tree->codes = (Code *)malloc(sizeof(Code) * n);
    tree->n = n;
    tree->root = NULL;
    return tree;
}

void insertOnce(Node **arr, int n) {
    for (int j = n; j >= 1; j--) {
        if (arr[j]->p > arr[j - 1]->p) {
            swap(arr[j], arr[j - 1]);
            continue;
        }
        break;
    }
    return ;
}

int extract_Codes(Node *root, Code *arr, int k, int l, char *buff) {
    buff[l] = 0;
    if (root->next[0] == NULL && root->next[1] == NULL) {
        arr[k].ch = root->ch;
        arr[k].str = strdup(buff);
        return 1;
    }
    int delta = 0;
    buff[l] = '0';
    delta += extract_Codes(root->next[0], arr, k + delta, l + 1, buff);
    buff[l] = '1';
    delta += extract_Codes(root->next[1], arr, k + delta, l + 1, buff);
    return delta;
}

Haffman_Tree *build(Data *arr, int n) {
    Node **nodes = (Node **)malloc(sizeof(Node *) * n);
    for (int i = 0; i < n; i++) {
        nodes[i] = getNewNode(arr + i);
    }
    for (int i = 1; i < n; i++) {
        insertOnce(nodes, i);
    }
    for (int i = n - 1; i >= 1; i--) {
        Node *p = getNewNode(NULL);
        p->next[0] = nodes[i - 1];
        p->next[1] = nodes[i];
        p->p = nodes[i - 1]->p + nodes[i]->p;
        nodes[i - 1] = p;
        insertOnce(nodes, i - 1);
    }
    char *buff = (char *)malloc(sizeof(char *) * n);
    Haffman_Tree *tree = getNewTree(n);
    tree->root = nodes[0];
    extract_Codes(tree->root, tree->codes, 0, 0, buff);
    free(nodes);
    free(buff);
    return tree;
}

int main() {
    int n;
    char str[10];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%c %lf", str, &arr[i].p);
        arr[i].ch = str[0];
    }
    Haffman_Tree *tree = build(arr, n);
    for (int i = 0; i < tree->n; i++) {
        printf("%c : %s\n", tree->codes[i].ch, tree->codes[i].str);
    }
    return 0;
}
```







## 2.3. ==ä¼˜å…ˆé˜Ÿåˆ—-å †==

## 2.3. ==ä¼˜å…ˆé˜Ÿåˆ—-å †==

```c
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {
    return q->data[1];
}
//è‡ªä¸‹è€Œä¸Šè°ƒæ•´
int push(priority_queue *q, int val) {
    if (q == NULL) return 0;
    if (q->cnt == q->size) return 0;
    q->cnt += 1;
    q->data[q->cnt] = val;
    int ind = q->cnt;
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
        swap(q->data[ind], q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}

int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        if (temp == ind) break;
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to queue\n", val);
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    clear(q);
    return 0;
}
```

## 2.4. ==çº¿æ€§å»ºå †æ³•==

```c
//è‡ªä¸Šè€Œä¸‹
void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i >= 1; i--) {
        downUpdate(arr, n, i);
    }
    for (int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);
    }
    return ;
}

```

![image-20201008200910691](/Image/A1.Data_Structure-photo/image-20201008200910691.png)



#### 2.4.0.1. [LC-703. æ•°æ®æµä¸­çš„ç¬¬Kå¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

è®¾è®¡ä¸€ä¸ªæ‰¾åˆ°æ•°æ®æµä¸­ç¬¬Kå¤§å…ƒç´ çš„ç±»ï¼ˆclassï¼‰ã€‚æ³¨æ„æ˜¯æ’åºåçš„ç¬¬Kå¤§å…ƒç´ ï¼Œä¸æ˜¯ç¬¬Kä¸ªä¸åŒçš„å…ƒç´ ã€‚

ä½ çš„ KthLargest ç±»éœ€è¦ä¸€ä¸ªåŒæ—¶æ¥æ”¶æ•´æ•° k å’Œæ•´æ•°æ•°ç»„nums çš„æ„é€ å™¨ï¼Œå®ƒåŒ…å«æ•°æ®æµä¸­çš„åˆå§‹å…ƒç´ ã€‚æ¯æ¬¡è°ƒç”¨ KthLargest.addï¼Œè¿”å›å½“å‰æ•°æ®æµä¸­ç¬¬Kå¤§çš„å…ƒç´ ã€‚

ç¤ºä¾‹:

int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8

```c
#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

typedef struct {
    int *data;
    int cnt, size;
} KthLargest;

void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] < arr[temp]) temp = l;
        if (r <= n && arr[r] < arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void upUpdate(int *arr, int ind) {
    while (ind >> 1) {
        if (arr[ind] >= arr[ind >> 1]) break;
        swap(arr[ind], arr[ind >> 1]);
        ind >>= 1;
    }
    return ;
}

int kthLargestAdd(KthLargest*, int);
KthLargest* kthLargestCreate(int k, int* nums, int numsSize) {
    KthLargest *p = (KthLargest *)malloc(sizeof(KthLargest));
    p->data = (int *)malloc(sizeof(int) * (k + 1));
    p->size = k;
    p->cnt = k - 1;
    memcpy(p->data + 1, nums, sizeof(int) * (k - 1));
    for (int i = (k - 1) >> 1; i >= 1; --i) {
        downUpdate(p->data, k - 1, i);
    }
    for (int i = k - 1; i < numsSize; i++) {
        kthLargestAdd(p, nums[i]);
    }
    return p;
}

int kthLargestAdd(KthLargest* obj, int val) {
    if (obj->cnt == obj->size) {
        if (val > obj->data[1]) {
            obj->data[1] = val;
            downUpdate(obj->data, obj->size, 1);
        }
    } else {
        obj->cnt += 1;
        obj->data[obj->cnt] = val;
        upUpdate(obj->data, obj->cnt);
    }
    return obj->data[1];
}

void kthLargestFree(KthLargest* obj) {
    if (obj == NULL) return ;
    free(obj->data);
    free(obj);
    return ;
}
```



#### 2.4.0.2. [295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/find-median-from-data-stream/)

å¦‚æœæˆ‘ä»¬å¯ä»¥ç”¨ä»¥ä¸‹æ–¹å¼ç»´æŠ¤ä¸¤ä¸ªå †ï¼š

1. ç”¨äºå­˜å‚¨è¾“å…¥æ•°å­—ä¸­è¾ƒå°ä¸€åŠçš„æœ€å¤§å †
2. ç”¨äºå­˜å‚¨è¾“å…¥æ•°å­—çš„è¾ƒå¤§ä¸€åŠçš„æœ€å°å †

è¿™æ ·å°±å¯ä»¥è®¿é—®è¾“å…¥ä¸­çš„ä¸­å€¼ï¼šå®ƒä»¬ç»„æˆå †çš„é¡¶éƒ¨ï¼

```c
typedef struct Heap {
    int *data;
    int n, size;
} Heap;

void expandHeap(Heap *h) {
    h->data = realloc(h->data, 2 * h->size * sizeof(int));
    h->size *= 2;
    return ;
}

#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

#define pushHeap(h, val, comp) { \
    if (h->size == h->n + 1) { \
        expandHeap(h); \
    } \
    h->data[++(h->n)] = val; \
    int ind = h->n; \
    while (ind != 1 && h->data[ind] comp h->data[ind >> 1]) { \
        swap(h->data[ind], h->data[ind >> 1]); \
        ind >>= 1; \
    } \
}

#define popHeap(h, comp) do { \
    if (h->n == 0) break; \
    h->data[1] = h->data[(h->n)--]; \
    int ind = 1; \
    while (ind << 1 <= h->n) { \
        int temp = ind, l = ind << 1, r = ind << 1 | 1; \
        if (h->data[l] comp h->data[temp]) temp = l; \
        if (r <= h->n && h->data[r] comp h->data[temp]) temp = r; \
        if (temp == ind) break; \
        swap(h->data[temp], h->data[ind]); \
        ind = temp; \
    } \
} while(0);

Heap *creatHeap() {
    Heap *h = (Heap *)malloc(sizeof(Heap));
    h->size = 100;
    h->data = (int *)malloc(sizeof(int) * h->size);
    h->n = 0;
    return h;
}

void clearHeap(Heap *h) {
    if (h == NULL) return ;
    free(h->data);
    free(h);
    return ;
}

typedef struct {
    Heap *min_heap, *max_heap;
} MedianFinder;

/** initialize your data structure here. */

MedianFinder* medianFinderCreate() {
    MedianFinder* m = (MedianFinder*)malloc(sizeof(MedianFinder));
    m->min_heap = creatHeap();
    m->max_heap = creatHeap();
    return m;
}

void medianFinderAddNum(MedianFinder* m, int num) {
    if (m->min_heap->n == 0 || num >= m->min_heap->data[1]) {
        pushHeap(m->min_heap, num, <);
    } else {
        pushHeap(m->max_heap, num, >);
    }
    if (m->min_heap->n - m->max_heap->n == 2) {
        pushHeap(m->max_heap, m->min_heap->data[1], >);
        popHeap(m->min_heap, <);
    }
    if (m->max_heap->n - m->min_heap->n == 2) {
        pushHeap(m->min_heap, m->max_heap->data[1], <);
        popHeap(m->max_heap, >);
    }
    return ;
}

double medianFinderFindMedian(MedianFinder* m) {
    switch (m->min_heap->n - m->max_heap->n) {
        case -1: return m->max_heap->data[1];
        case 0: return 1.0 * (m->min_heap->data[1] + m->max_heap->data[1]) / 2.0;
        case 1: return m->min_heap->data[1];
    }
    return 0.0;
}

void medianFinderFree(MedianFinder* obj) {
    if (obj == NULL) return ;
    clearHeap(obj->min_heap);
    clearHeap(obj->max_heap);
    free(obj);
    return ;
}
```

#### 2.4.0.3. LC-264 [ä¸‘æ•° II](https://leetcode-cn.com/problems/ugly-number-ii/description/)

> ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºç¬¬ `n` ä¸ªä¸‘æ•°ã€‚
>
> ä¸‘æ•°å°±æ˜¯è´¨å› æ•°åªåŒ…å« `2, 3, 5` çš„**æ­£æ•´æ•°**ã€‚

2.ä¼˜å…ˆé˜Ÿåˆ— (å°é¡¶å †)
ä¼˜å…ˆé˜Ÿåˆ—/å°é¡¶å †/å¤§é¡¶å †
åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—æœ‰è‡ªåŠ¨æ’åºçš„åŠŸèƒ½
æ¯æ¬¡å–å‡ºé˜Ÿå¤´å…ƒç´ ï¼Œå­˜å…¥é˜Ÿå¤´å…ƒç´ *2ã€é˜Ÿå¤´å…ƒç´ *3ã€é˜Ÿå¤´å…ƒç´ *5
ä½†æ³¨æ„ï¼Œåƒ 12 è¿™ä¸ªå…ƒç´ ï¼Œå¯ç”± 4 ä¹˜ 3 å¾—åˆ°ï¼Œä¹Ÿå¯ç”± 6 ä¹˜ 2 å¾—åˆ°ï¼Œæ‰€ä»¥è¦æ³¨æ„å»é‡
è¿˜å¯ä»¥æ›´è¿›ä¸€æ­¥é‡‡ç”¨ set æ¥è¯†åˆ«æœ‰æ— é‡å¤

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue <double,vector<double>,greater<double> > q;
        set<int> s;
        s.insert(1);
        vector<int> mask({2,3,5});
        double answer=1;
        for (int i=1;i<n;++i)
        {
            for (int &j:mask)
                if (s.count(answer*j)==0)
                {
                    q.push(answer*j);
                    s.insert(answer*j);
                }
            answer=q.top();
            q.pop();
        }
        return answer;
    }
};

```

3.åŠ¨æ€è§„åˆ’ (ä¸‰æŒ‡é’ˆ)
æˆ‘ä»¬å…ˆæ¨¡æ‹Ÿæ‰‹å†™ä¸‘æ•°çš„è¿‡ç¨‹
1 æ‰“å¤´ï¼Œ1 ä¹˜ 2 1 ä¹˜ 3 1 ä¹˜ 5ï¼Œç°åœ¨æ˜¯ {1,2,3,5}
è½®åˆ° 2ï¼Œ2 ä¹˜ 2 2 ä¹˜ 3 2 ä¹˜ 5ï¼Œç°åœ¨æ˜¯ {1,2,3,4,5,6,10}
æ‰‹å†™çš„è¿‡ç¨‹å’Œé‡‡ç”¨å°é¡¶å †çš„æ–¹æ³•å¾ˆåƒï¼Œä½†æ˜¯æ€ä¹ˆåšåˆ°æå‰æ’åºå‘¢

å°é¡¶å †çš„æ–¹æ³•æ˜¯å…ˆå­˜å†æ’ï¼Œdp çš„æ–¹æ³•åˆ™æ˜¯å…ˆæ’å†å­˜
æˆ‘ä»¬è®¾ 3 ä¸ªæŒ‡é’ˆ p_2,p_3,p_5
ä»£è¡¨çš„æ˜¯ç¬¬å‡ ä¸ªæ•°çš„2å€ã€ç¬¬å‡ ä¸ªæ•° 3 å€ã€ç¬¬å‡ ä¸ªæ•° 5 å€
åŠ¨æ€æ–¹ç¨‹ dp[i]=min(dp[p_2]*2,dp[p_3]*3,dp[p_5]*5)
å°é¡¶å †æ˜¯ä¸€ä¸ªå…ƒç´ å‡ºæ¥ç„¶åå­˜ 3 ä¸ªå…ƒç´ 
åŠ¨æ€è§„åˆ’åˆ™æ˜¯æ ‡è¯† 3 ä¸ªå…ƒç´ ï¼Œé€šè¿‡æ¯”è¾ƒä»–ä»¬çš„ 2 å€ã€3 å€ã€5 å€çš„å¤§å°ï¼Œæ¥ä¸€ä¸ªä¸€ä¸ªå­˜

```cpp
        int t1 = 0, t2 = 0, t3 = 0;
        vector<int> k(n);
        k[0] = 1;
        for (int i = 1; i < n; ++i) {
            int f1 = k[t1] * 2, f2 = k[t2] * 3, f3 = k[t3] * 5;
            k[i] = min(f1, min(f2, f3));
            if (k[i] == f1) t1++;
            if (k[i] == f2) t2++;
            if (k[i] == f3) t3++;
        }
        return k[n - 1];
```

#### 2.4.0.4. LC-23 [åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

1. åˆ†æ²»åˆå¹¶

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return merge(lists, 0, lists.size() - 1);
    }
private :
    ListNode* merge(vector<ListNode*>& lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode dummy, *p = &dummy;
        dummy.next = nullptr;
        while (l1 || l2) {
            if (!l2 || l1 && l1->val < l2->val) {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            } else {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        return dummy.next;
    }
};
```

2. ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—åˆå¹¶

   éœ€è¦ç»´æŠ¤å½“å‰æ¯ä¸ªé“¾è¡¨æ²¡æœ‰è¢«åˆå¹¶çš„å…ƒç´ çš„æœ€å‰é¢ä¸€ä¸ªï¼Œkä¸ªé“¾è¡¨å°±æœ€å¤šæœ‰ kä¸ªæ»¡è¶³è¿™æ ·æ¡ä»¶çš„å…ƒç´ ï¼Œæ¯æ¬¡åœ¨è¿™äº›å…ƒç´ é‡Œé¢é€‰å– val å±æ€§æœ€å°çš„å…ƒç´ åˆå¹¶åˆ°ç­”æ¡ˆä¸­

```cpp
class Solution {
public:
    typedef pair<int, ListNode *> PII;
    struct cmp {
        bool operator()(const PII &a, const PII &b) const {
          return a.first > b.first;
      }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        //return merge(lists, 0, lists.size() - 1);
        priority_queue<PII, vector<PII>, cmp> q;
        for (auto cur : lists) {
            if (cur) q.push({cur->val, cur});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto cur = q.top();
            ListNode *ptr = cur.second;
            q.pop();
            tail->next = ptr;
            tail = tail->next;
            if (ptr->next) q.push({ptr->next->val, ptr->next});
        }
        tail->next = nullptr;
        return head.next;

    }
```



#### 2.4.0.5. HZOJ-571-å…³ç³»ç½‘ç»œ1.cpp

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100
int arr[MAX_N + 5][MAX_N + 5];

struct Data {
    Data(int a, int b, int c) {
        x = a, y = b, cnt = c;
    }
    int cnt, x, y;
};

struct DataCompare {
    bool operator()(const Data &a, const Data &b) const {
        if (a.cnt - b.cnt) return a.cnt < b.cnt;
        if (a.x - b.x) return a.x < b.x;
        return a.y < b.y;
    }
};

set<Data, DataCompare> s;

int main() {
    int n, x, y;
    cin >> n >> x >> y;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
            if (arr[i][j]) {
                s.insert(Data(i, j, 1));
            }
        }
    }
    while (s.size()) {
        int x = s.begin()->x;
        int y = s.begin()->y;
        int cnt = s.begin()->cnt;
        s.erase(s.begin());
        for (int i = 1; i <= n; i++) {
            if (arr[y][i] != 1) continue;
            if (arr[x][i]) continue;
            arr[x][i] = cnt + 1;
            s.insert(Data(x, i, cnt + 1));
        }
    }
    cout << arr[x][y] - 1 << endl;
    return 0;
}
```

#### 2.4.0.6. HZOJ-572-æœ‰åºè¡¨çš„æœ€å°å’Œ.cpp

#### 2.4.0.7. é¢˜ç›®æè¿°

 ç»™å‡ºä¸¤ä¸ªé•¿åº¦ä¸º *ğ‘›*n çš„æœ‰åºè¡¨ *ğ´*A å’Œ *ğµ*Bï¼Œåœ¨ *ğ´*A å’Œ *ğµ*B ä¸­å„ä»»å–ä¸€ä¸ªå…ƒç´ ï¼Œå¯ä»¥å¾—åˆ° *ğ‘›*2n2 ä¸ªå’Œï¼Œæ±‚è¿™äº›å’Œä¸­å‰ *ğ‘›*n ä¸ªæœ€å°å€¼ã€‚

1. åŒæŒ‡é’ˆ

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 400000
long long a[MAX_N + 5], b[MAX_N + 5];

struct Data {
    Data(long long val, long long i, long long j) : val(val), i(i), j(j) {}
    long long val, i, j;
    bool operator<(const Data &a) const {
        if (val - a.val) return val < a.val;
        if (i - a.i) return i < a.i;
        return j < a.j;
    }
};

set<Data> s;

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%lld", a + i);
    for (int i = 0; i < n; i++) scanf("%lld", b + i);
    s.insert(Data(a[0] + b[0], 0, 0));
    for (long long i = 0; i < n; i++) {
        long long val = s.begin()->val;
        long long x = s.begin()->i;
        long long y = s.begin()->j;
        s.erase(s.begin());
        printf("%lld\n", val);
        if (x + 1 < n) s.insert(Data(a[x + 1] + b[y], x + 1, y));
        if (y + 1 < n) s.insert(Data(a[x] + b[y + 1], x, y + 1));
    }
    return 0;
}
```

2.ä¼˜å…ˆé˜Ÿåˆ—





#### 2.4.0.8. hzoj-284-è¶…å¸‚å–è´§-äºŒå‰å †-å¹¶æŸ¥é›†

> è¶…å¸‚é‡Œæœ‰Nä¸ªå•†å“. ç¬¬iä¸ªå•†å“å¿…é¡»åœ¨ä¿è´¨æœŸ(ç¬¬diå¤©)ä¹‹å‰å–æ‰, è‹¥å–æ‰å¯è®©è¶…å¸‚è·å¾—piçš„åˆ©æ¶¦.
>
> æ¯å¤©åªèƒ½å–ä¸€ä¸ªå•†å“.
>
> ç°åœ¨ä½ è¦è®©è¶…å¸‚è·å¾—æœ€å¤§çš„åˆ©æ¶¦.

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 10000
struct Data {
    int p, d;
} a[MAX_N + 5];

bool cmp(const Data &a, const Data &b) {
    return a.d < b.d;
}

typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].p >> a[i].d;
    }
    sort(a, a + n, cmp);
    for (int i = 0; i < n; i++) {
        if (s.size() < a[i].d) {
      //æ’å…¥iæ˜¯ä¸ºäº†setå»é‡
            s.insert(PII(a[i].p, i));
        } else if (s.begin()->first < a[i].p) {
            s.erase(s.begin());
            s.insert(PII(a[i].p, i));
        }
    }
    int ans = 0;
    for (auto iter = s.begin(); iter != s.end(); iter++) {
        ans += iter->first;
        cout << iter->first << endl;
    }
    cout << ans << endl;
    return 0;
}
```

```cpp
#define MAX_N 10000

struct Data {
    int p, d;
} arr[MAX_N + 5];
 
struct UnionSet {
    int fa[MAX_N + 5];
    void init(int n) {
        for (int i = 0; i <= n; ++i) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    //æ ¹èŠ‚ç‚¹ä»£è¡¨å½“å‰èŠ‚ç‚¹å‰é¢ç¬¬ä¸€ä¸ªç©ºä½ç½®
    //å‰é¢åšå„¿å­
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

bool cmp(const Data &a, const Data &b) {
    return a.p > b.p;
}

UnionSet u;

int solve(int n) {
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].p >> arr[i].d;
    }
    sort(arr, arr + n, cmp);
    u.init(MAX_N);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (u.get(arr[i].d) == 0) continue;
        ans += arr[i].p;
        int day = u.get(arr[i].d);
        //è®©dayä½œä¸ºday-1çš„å­é›†ï¼Œdayè¢«å ç”¨
        u.merge(day, day - 1);
    }
    cout << ans << endl;
    return 0;
}

int main() {
    int n;
    while (cin >> n) solve(n);
    return 0;
}

```

#### 2.4.0.9. hzoj-286. æ•°æ®å¤‡ä»½

ç­‰æ•ˆæƒå€¼æ›¿æ¢

åæ‚”ç­–ç•¥

åŸºäºé€‰æ‹©ä¸€æ¡ç”µç¼†çš„æƒ…å†µå»é€‰æ‹©ç¬¬äºŒæ¡ç”µç¼†

![image-20210121192544196](/Image/A1.Data_Structure-photo/image-20210121192544196.png)

è‹¥è¦é€‰æ‹©å‘¨å›´çš„3-4åˆ™å¿…é¡»é€‰æ‹©1-2

![image-20210121192854505](/Image/A1.Data_Structure-photo/image-20210121192854505.png)

ç­‰æ•ˆå›¾çš„ç”Ÿæˆï¼Œåæ‚”ä¾§ç‡

```cpp
#define MAX_N 100000
#define inf 0x3f3f3f

int a[MAX_N + 5];
int l[MAX_N + 5], pre[MAX_N + 5], nxt[MAX_N + 5];
typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n, k;
    cin >> n >> k;
    a[0] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        l[i] = a[i] - a[i - 1];
        pre[i] = i - 1;
        nxt[i] = i + 1 > n ? 0 : i + 1;
        s.insert(PII(l[i], i));
    }
    int sum = 0;
    while (k) {
        int t0 = s.begin()->second, t1 = pre[t0], t2 = nxt[t0];
        if (t1 == 0 || l[t0] != s.begin()->first) {
            s.erase(s.begin());
            continue;
        }
        s.erase(s.begin());
        sum += l[t0];
        k--;
        l[t0] = l[t1] + l[t2] - l[t0];
        l[t1] = l[t2] = inf;
        if (t2 == 0) continue;
        pre[t0] = pre[t1];
        nxt[t0] = nxt[t2];
        nxt[pre[t1]] = t0;
        pre[nxt[t2]] = t0;
        s.insert(PII(l[t0], t0));
    }
    cout << sum << endl;

    return 0;
}

```



#### 2.4.0.10. HZOJ-289-ç”Ÿæ—¥ç¤¼ç‰©.cpp

[BZOJ2288](https://www.cnblogs.com/zyfzyf/p/4114774.html)

>  æå 1818 å²ç”Ÿæ—¥çš„æ—¶å€™ï¼Œå°æ˜ç»™å¥¹çœ‹äº†ä¸€ä¸ªç¥å¥‡çš„åºåˆ— *ğ´*1,*ğ´*2,...,*ğ´**ğ‘*A1,A2,...,ANã€‚ å¥¹è¢«å…è®¸é€‰æ‹©ä¸è¶…è¿‡ *ğ‘€*M ä¸ªè¿ç»­çš„éƒ¨åˆ†ä½œä¸ºè‡ªå·±çš„ç”Ÿæ—¥ç¤¼ç‰©ã€‚è‡ªç„¶åœ°ï¼Œæåæƒ³è¦çŸ¥é“é€‰æ‹©å…ƒç´ ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚ä½ èƒ½å¸®åŠ©å¥¹å—ï¼Ÿ
>  é¦–å…ˆè¿åœ¨ä¸€å—çš„æ­£è´Ÿç›¸åŒçš„è‚¯å®šå¯ä»¥çœ‹æˆä¸€ä¸ªç‚¹ï¼Œç„¶åæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ­£è´Ÿäº¤æ›¿çš„æ•°åˆ—ï¼Œå¹¶ä¸”é¦–ä½ä¸¤é¡¹éƒ½æ˜¯æ­£æ•°ï¼ˆè´Ÿæ•°å»æ‰ï¼‰

ç„¶åå¦‚æœæ­£çš„é¡¹æ•°<=mï¼Œé‚£æ˜¾ç„¶æˆ‘ä»¬å…¨éƒ¨é€‰èµ°å°±è·å¾—äº†æœ€å¤§æƒå€¼ï¼Œå¦åˆ™æˆ‘ä»¬éœ€è¦åšä¸€ç‚¹ç‰ºç‰²ã€‚

1ï¼‰ä¸é€‰æŸäº›æ­£é¡¹

2ï¼‰é€‰ä¸€äº›è´Ÿé¡¹ä½¿å¾—ç›¸é‚»çš„æ­£é¡¹æˆä¸º1å—

è®°æ‰€æœ‰æ­£æ•°ä¹‹å’Œä¸ºsumï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¸Šé¢ä¸¤ç§æ“ä½œä½¿å¾—sumå‡æ‰çš„æ•°æœ€å°å¹¶ä¸”æ»¡è¶³åªæœ‰må—ã€‚

æˆ‘ä»¬æŠŠæ‰€æœ‰æ•°çš„ç»å¯¹å€¼æ”¾å…¥ä¸€ä¸ªå †ï¼Œæ¯æ¬¡å–æœ€å°å…ƒç´ xã€‚sum'-=x

é‚£ä¹ˆå¦‚æœè¯¥æ•°åŸæ¥æ˜¯æ­£çš„ï¼Œæ„æ€æ˜¯ä¸é€‰å®ƒï¼›

å¦‚æœæ˜¯è´Ÿçš„ï¼Œæ„æ€æ˜¯æŠŠå®ƒä¸¤è¾¹çš„æ­£æ•°åˆå¹¶ã€‚

ä½†ç›´æ¥è¿™æ ·åšæ˜¯ä¸è¡Œçš„ï¼Œæˆ‘ä»¬å¿…é¡»ä¿è¯å–è´Ÿçš„æ—¶å€™ä¸¤è¾¹çš„æ­£çš„å¿…é¡»ä¸è¢«å–ï¼Œå–æ­£çš„æ—¶å€™ä¸¤è¾¹çš„è´Ÿçš„ä¸è¢«å–ã€‚

æ¢å¥è¯è¯´ï¼Œä¸èƒ½é€‰æ‹©ç›¸é‚»çš„ä¸¤ä¸ªæ•°ï¼æˆ‘ä»¬æˆåŠŸçš„å°†æ­¤é¢˜è½¬åŒ–æˆäº†æ•°æ®å¤‡ä»½é—®é¢˜ã€‚

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100000
long long arr[MAX_N + 5];

struct Node {
    long long val, id, f;
    long long pre, next;
    bool operator<(const Node &a) const {
        if (abs(val) - abs(a.val)) return abs(val) < abs(a.val);
        return id < a.id;
    }
} list[MAX_N + 5];

set<Node> s;

void del(long long k) {
    if (list[k].f == 0) return ;
    if (list[k].pre)  list[list[k].pre].next = list[k].next;
    if (list[k].next) list[list[k].next].pre = list[k].pre;
    list[k].f = 0;
    return ;
}

int main() {
    long long n, m, cnt = 0, sum = 0;
    cin >> n >> m;
    for (long long i = 0; i < n; i++) cin >> arr[i];
    for (long long i = 0, k = 1; i < n; k++) {
        list[k].val = 0;
        list[k].id = k;
        list[k].f = 1;
        while (i < n && arr[i] == 0) i++;
        long long val = arr[i];
        while (i < n && arr[i] * val >= 0) {
            list[k].val += arr[i++];
        }
        if (k - 1) list[k - 1].next = k;
        list[k].pre = k - 1;
        list[k].next = 0;
        if (list[k].val > 0) cnt += 1, sum += list[k].val;
        s.insert(list[k]);
    }
    while (cnt > m) {
        long long k = s.begin()->id;
        s.erase(s.begin());
        if (list[k].f == 0) continue;
        if (list[k].pre && list[k].next) {
            sum -= abs(list[k].val);
            cnt -= 1;
            list[k].val += list[list[k].pre].val;
            list[k].val += list[list[k].next].val;
            del(list[k].pre);
            del(list[k].next);
            s.insert(list[k]);
        } else {
            if (list[k].val > 0) sum -= list[k].val, cnt -= 1;
            del(k);
        }
    }
    cout << sum << endl;
    return 0;
}
```

#### 2.4.0.11. HZOJ-285 åºåˆ—Må°å’Œ

>   ç»™å‡ºä¸€ä¸ª *ğ‘›*âˆ—*ğ‘š*nâˆ—m çš„çŸ©é˜µï¼Œæ¯è¡Œå–ä¸€ä¸ªå…ƒç´ ï¼Œç»„æˆä¸€ä¸ªåŒ…å« *ğ‘›*n ä¸ªå…ƒç´ çš„åºåˆ—ï¼Œä¸€å…±æœ‰ *ğ‘š**ğ‘›*mn ç§åºåˆ—ï¼Œæ±‚å‡ºåºåˆ—å’Œæœ€å°çš„å‰ *ğ‘š*m ä¸ªåºåˆ—çš„åºåˆ—å’Œã€‚

```cpp
#define INF 0x3f3f3f3f
#define MAX_M 2000
int nums[MAX_M + 5];
//æ—¶é—´æˆ³, åŠ è´Ÿå·æ¨¡æ‹Ÿå¤§é¡¶å †
typedef pair<int, int> PII;

struct BigSet : set<PII> {
public :
    BigSet() : t(0) {}
    void insert(int &a) {
        this->set<PII>::insert(PII(-a, t++));
    }
    void pop() {
        erase(begin());
    }
    int top() {
        return -(begin()->first);
    }

private :
    int t;
};

BigSet s;

void extract(int m) {
    for (int i = m - 1; i >= 0; --i) {
        nums[i] = s.top();
        s.pop();
    }
}

int main() {
    int n, m, x;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> x;
        s.insert(x);
    }
    for (int i = 1; i < n; ++i) {
        extract(m);
        for (int j = 0; j < m; ++j) {
            cin >> x;
            for (int k = 0; k < m; ++k) {
                int y = x + nums[k];
                if (s.size() == m && y >= s.top()) break;
                if (s.size() == m) s.pop();
                s.insert(y);
            }
        }
    }
    extract(m);
    for (int i = 0; i < m; ++i) {
        i && cout << " ";
        cout << nums[i];
    }
    cout << endl;
    return 0;
}

```



## 2.5. ==HashTable==

```c
typedef struct Node {
    char *str;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node **data;
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n * 2;
    h->data = (Node **)calloc(h->size, sizeof(Node *));
    return h;
}

int BKDRHash(char *str) {
    int hash = 0, seed = 31;
    for (int i = 0; str[i]; ++i) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *head = h->data[ind];
    while (head && strcmp(str, head->str)) head = head->next;
    return head != NULL;
}

int insert(HashTable *h, char *str) {
    if (search(h, str)) return 0;
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}

void clear_node(Node *head) {
    if (head == NULL) return ;
    Node *p = head, *q;
    while(p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    return ;
}

void clear_hashtable(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i < h->size; ++i) clear_node(h->data[i]);
    free(h);
    return ;
}

int main() {
    #define max_n 1000
    HashTable *h = init_hashtable(max_n + 5);
    char *str = (char *)malloc(sizeof(char) * (max_n + 5));
    int op;
    while (~scanf("%d%s", &op, str)) {
        switch (op) {
            case 0 : 
                printf("%s insert to the HashTable = %d\n", str, insert(h, str));
            break;
            default : 
                printf("search %s from the HashTable = %d\n", str, search(h, str));
            break;
        }
    }
    clear_hashtable(h);
    #undef max_n

    return 0;
}

```

## 2.6. ==sort==



![849589-20171015223238449-2146169197](/Image/A1.Data_Structure-photo/849589-20171015223238449-2146169197.gif)

![849589-20180402133438219-1946132192](/Image/A1.Data_Structure-photo/849589-20180402133438219-1946132192.png)

Code:

```cpp
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp; \
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s\t= ", #func);\
    func(num, args);\
    output(num, n);\
    free(num);\
}


int insert_sort(int *arr, int n) {
    for (int i = 1; i < n; ++i) {
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; --j) {
            swap(arr[j], arr[j - 1]);
        }
    }
    return 1;
}

int bubble_sort(int *arr, int n) {
    int times = 1;
    for (int i = 1; times && i < n; ++i) {
        times = 0;
        for (int j = 0; j < n - i; ++j) {
            if (arr[j] <= arr[j + 1]) continue;
            swap(arr[j], arr[j + 1]);
            times++;
        }
    }
    return 1;
}

int merge_sort(int *arr, int l , int r) {
    if (r - l <= 1) {
        if (r - l == 1 && arr[r] < arr[l]) {
            swap(arr[r], arr[l]);
        }
        return 1;
    }
    int mid =  (l + r) >> 1;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);
    int p1 = l, p2 = mid + 1, ind = 0;
    int *tmp =  (int *)malloc(sizeof(int) * (r - l + 1));
    while (p1 <= mid || p2 <= r) {
        if (p2 > r || p1 <= mid && arr[p1] < arr[p2]) tmp[ind++] = arr[p1++];
        else tmp[ind++] = arr[p2++];
    }
    memcpy(arr + l, tmp, sizeof(int) * (r - l + 1));
    free(tmp);
    return 1;
}

int select_sort(int *arr, int n) {
    for (int i = 0; i < n - 1; ++i) {
        int ind = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[ind] <= arr[j]) continue;
            ind = j;
        }
        swap(arr[ind], arr[i]);
    }
    return 1;
}

int quick_sort(int *arr, int l, int r) {
    if (l >= r) return 0;
    int x = l, y = r, z = arr[l];
    while (x  < y) {
        while (x < y && arr[y] > z) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] < z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    quick_sort(arr, l, x - 1);
    quick_sort(arr, x + 1, r);
    return 1;
}

void output(int *arr, int n) {
    for (int i = 0; i < n; ++i) {
        printf(" %d", arr[i]);
    }
    printf("\n");
}

int *init(int n) {
    int *arr = (int *)malloc(sizeof(int) * n);
    while (n--) arr[n] = rand() % 100;
    return arr;
}

void downUpdate(int *arr, int ind, int n) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind ) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

int heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i > 0; --i) {
        downUpdate(arr, i, n);
    }
    for (int i = n; i > 1; --i) {
        swap(arr[i], arr[1]);
        downUpdate(arr, 1, i - 1);
    }
    return 1;
}


int main() {
    srand(time(0));
    #define max_op 20
    int *arr = init(max_op);
    TEST(arr, max_op, insert_sort, max_op);
    TEST(arr, max_op, bubble_sort, max_op);
    TEST(arr, max_op, merge_sort, 0, max_op - 1);
    TEST(arr, max_op, select_sort, max_op);
    TEST(arr, max_op, quick_sort, 0, max_op - 1);
    TEST(arr, max_op, heap_sort, max_op);
    #undef max_op
    return 0;
}

```



#### 2.6.0.12. lc-2å¯»æ‰¾æŒ‡å®šå’Œ

```cpp
class Solution {
public:
    typedef pair<int, int> PII;
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> ret;
        vector<PII> nums2;
        for (int i = 0; i < nums.size(); i++) {
            nums2.push_back(PII(nums[i], i));
        }
        sort(nums2.begin(), nums2.end());
        int i = 0, j = nums2.size() - 1;
        while (nums2[i].first + nums2[j].first - target) {
            if (nums2[i].first + nums2[j].first > target) --j;
            if (nums2[i].first + nums2[j].first < target) ++i;
        }
        if (nums2[i].second > nums2[j].second) swap(i, j);
        ret.push_back(nums2[i].second);
        ret.push_back(nums2[j].second);
        return ret;
    }
};
```



#### 2.6.0.13. lc-11[ç››æœ€å¤šæ°´çš„å®¹å™¨](https://leetcode-cn.com/problems/container-with-most-water/description/)

#### 2.6.0.14. [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int *map = (int *)malloc(sizeof(int) * 256);
        for (int i = 0 ; i < 256; ++i) {
            map[i] =  -1;
        }
        int ans = 0, cur = 0, pre  = -1;
        for (int i = 0; i < s.size(); ++i) {
            pre = max(pre, map[s[i]]);
            cur = i - pre;
            ans = max(ans, cur);
            map[s[i]] = i;
        }
        return ans;
    }
};


```

```c
class Solution {
public: 
    int check(string &s, int l) {
        unordered_map<char, int> m;
        int cnt = 0;
        for (int i = 0; s[i]; i++) {
            m[s[i]] += 1;
            if (m[s[i]] == 1) cnt += 1;
            if (i >= l) {
                m[s[i - l]] -= 1;
                if (m[s[i - l]] == 0) cnt -= 1;
            }
            if (cnt == l) return 1;
        }
        return 0;
    }
    
    int lengthOfLongestSubstring(string s) {
        int head = 0, tail = s.length(), mid;
        while (head < tail) {
            mid = (head + tail + 1) >> 1;
            if (check(s, mid)) head = mid;
            else tail = mid - 1;
        }
        return head;
    }
};
```

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> m;
        int pre_l = 0, ans = 0;
        for (int i = 0; s[i]; i++) {
            if (m.find(s[i]) == m.end()) pre_l += 1;
            else pre_l = min(pre_l + 1, i - m[s[i]]);
            ans = max(ans, pre_l);
            m[s[i]] = i;
        }
        return ans;
    }
};
```

#### 2.6.0.15. [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

æ–¹æ³•ä¸€ï¼šäºŒåˆ†æŸ¥æ‰¾
ç»™å®šä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œè¦æ±‚æ‰¾åˆ°ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°ï¼Œæœ€ç›´è§‚çš„æ€è·¯æœ‰ä»¥ä¸‹ä¸¤ç§ï¼š

ä½¿ç”¨å½’å¹¶çš„æ–¹å¼ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œå¾—åˆ°ä¸€ä¸ªå¤§çš„æœ‰åºæ•°ç»„ã€‚å¤§çš„æœ‰åºæ•°ç»„çš„ä¸­é—´ä½ç½®çš„å…ƒç´ ï¼Œå³ä¸ºä¸­ä½æ•°ã€‚

ä¸éœ€è¦åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œåªè¦æ‰¾åˆ°ä¸­ä½æ•°çš„ä½ç½®å³å¯ã€‚ç”±äºä¸¤ä¸ªæ•°ç»„çš„é•¿åº¦å·²çŸ¥ï¼Œå› æ­¤ä¸­ä½æ•°å¯¹åº”çš„ä¸¤ä¸ªæ•°ç»„çš„ä¸‹æ ‡ä¹‹å’Œä¹Ÿæ˜¯å·²çŸ¥çš„ã€‚ç»´æŠ¤ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆå§‹æ—¶åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªæ•°ç»„çš„ä¸‹æ ‡ 00 çš„ä½ç½®ï¼Œæ¯æ¬¡å°†æŒ‡å‘è¾ƒå°å€¼çš„æŒ‡é’ˆåç§»ä¸€ä½ï¼ˆå¦‚æœä¸€ä¸ªæŒ‡é’ˆå·²ç»åˆ°è¾¾æ•°ç»„æœ«å°¾ï¼Œåˆ™åªéœ€è¦ç§»åŠ¨å¦ä¸€ä¸ªæ•°ç»„çš„æŒ‡é’ˆï¼‰ï¼Œç›´åˆ°åˆ°è¾¾ä¸­ä½æ•°çš„ä½ç½®ã€‚![fig1](/Image/A1.Data_Structure-photo/4_fig1.png)

å¦‚æœ$A[k/2âˆ’1]<B[k/2âˆ’1]$ï¼Œåˆ™æ¯”$A[k/2âˆ’1]$ å°çš„æ•°æœ€å¤šåªæœ‰ $A$ çš„å‰$ k/2-1$ä¸ªæ•°å’ŒBçš„å‰ $k/2-1$ä¸ªæ•°ï¼Œå³æ¯” $A[k/2âˆ’1]$å°çš„æ•°æœ€å¤šåªæœ‰$kâˆ’2$ ä¸ªï¼Œå› æ­¤ $A[k/2âˆ’1]$ ä¸å¯èƒ½æ˜¯ç¬¬ $k$ä¸ªæ•°ï¼Œ$A[0]$ åˆ° $A[k/2âˆ’1] $ä¹Ÿéƒ½ä¸å¯èƒ½æ˜¯ç¬¬$k$ä¸ªæ•°ï¼Œå¯ä»¥å…¨éƒ¨æ’é™¤

ä»¥ä¸‹ä¸‰ç§æƒ…å†µéœ€è¦ç‰¹æ®Šå¤„ç†ï¼š

å¦‚æœ ${A}[k/2-1]$ æˆ–è€… $B[k/2âˆ’1]$ è¶Šç•Œï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é€‰å–å¯¹åº”æ•°ç»„ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚**åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¿…é¡»æ ¹æ®æ’é™¤æ•°çš„ä¸ªæ•°å‡å°‘ k çš„å€¼ï¼Œè€Œä¸èƒ½ç›´æ¥å°† k å‡å» k/2**ã€‚

å¦‚æœä¸€ä¸ªæ•°ç»„ä¸ºç©ºï¼Œè¯´æ˜è¯¥æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½è¢«æ’é™¤ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å›å¦ä¸€ä¸ªæ•°ç»„ä¸­ç¬¬ k å°çš„å…ƒç´ ã€‚

å¦‚æœ k=1ï¼Œæˆ‘ä»¬åªè¦è¿”å›ä¸¤ä¸ªæ•°ç»„é¦–å…ƒç´ çš„æœ€å°å€¼å³å¯

```cpp
class Solution {
public:
    double kth(vector<int> &n1, vector<int> &n2, int k) {
        int len1 = n1.size(), len2 = n2.size();
        int t1 = 0, t2 = 0, res = 0;
        while (true) {
            if (t1 == len1) {
                res = n2[t2 + k - 1];
                break;
            }
            if (t2 == len2) {
                res = n1[t1 + k - 1];
                break;
            }
            if (k == 1) {
                res = min(n1[t1], n2[t2]);
                break;
            }
            int idx1 = min(t1 + k / 2 - 1, len1 - 1);
            int idx2 = min(t2 + k / 2 - 1, len2 - 1);
            if (n1[idx1] <= n2[idx2]) {
                k -= idx1 - t1 + 1;
                t1 = idx1 + 1;
            } else {
                k -= idx2 - t2 + 1;
                t2 = idx2 + 1;
            }
        }
        return res;
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size(), len2 = nums2.size();
        int k = (len1 + len2) >> 1;
        double m1 = kth(nums1, nums2, k + 1);
        if ((len1 + len2) & 1 == 1) {
            return m1;
        }
        double m2 = kth(nums1, nums2, k);
        return (m1 + m2) / 2.0;
    }
};
```





```cpp
class Solution {
public:
    double bs(vector<int> &n1, vector<int> &n2, int i, int j, int k) {
        if (i == n1.size()) return n2[k - 1];
        if (j == n2.size()) return n1[k - 1];
        if (k == 1) return min(n1[i], n2[j]);
        int a, b;
        a = k / 2 > n1.size() - i ? n1.size() - i : k / 2;
        b = k - a > n2.size() - j ? n2.size() - j : k - a;
        a = k - b;
        if (n1[i + a - 1] < n2[j + b - 1]) {
            return bs(n1, n2, i + a, j, k - a);
        }
        return bs(n1, n2, i, j + b, k - b);
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        double val1 = bs(nums1, nums2, 0, 0, (n + m + 1) / 2);
        if ((n + m) % 2 == 0) {
            double val2 = bs(nums1, nums2, 0, 0, (n + m) / 2 + 1);
            return (val1 + val2) / 2;
        }
        return val1;
    }
};
```

æ–¹æ³•äºŒï¼šåˆ’åˆ†æ•°ç»„
è¯´æ˜

æ–¹æ³•ä¸€çš„æ—¶é—´å¤æ‚åº¦å·²ç»å¾ˆä¼˜ç§€äº†ï¼Œä½†æœ¬é¢˜å­˜åœ¨æ—¶é—´å¤æ‚åº¦æ›´ä½çš„ä¸€ç§æ–¹æ³•ã€‚è¿™é‡Œç»™å‡ºæ¨å¯¼è¿‡ç¨‹ï¼Œå‹‡äºæŒ‘æˆ˜è‡ªå·±çš„è¯»è€…å¯ä»¥è¿›è¡Œå°è¯•ã€‚

æ€è·¯ä¸ç®—æ³•

ä¸ºäº†ä½¿ç”¨åˆ’åˆ†çš„æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦ç†è§£ã€Œä¸­ä½æ•°çš„ä½œç”¨æ˜¯ä»€ä¹ˆã€ã€‚åœ¨ç»Ÿè®¡ä¸­ï¼Œä¸­ä½æ•°è¢«ç”¨æ¥ï¼š

**å°†ä¸€ä¸ªé›†åˆåˆ’åˆ†ä¸ºä¸¤ä¸ªé•¿åº¦ç›¸ç­‰çš„å­é›†ï¼Œå…¶ä¸­ä¸€ä¸ªå­é›†ä¸­çš„å…ƒç´ æ€»æ˜¯å¤§äºå¦ä¸€ä¸ªå­é›†ä¸­çš„å…ƒç´ **



#### 2.6.0.16. [38. å¤–è§‚æ•°åˆ—](https://leetcode-cn.com/problems/count-and-say/)

```cpp
class Solution {
public:
    string countAndSay(int n) {
        if (n == 1) return "1";
        string ret = "", str = countAndSay(n - 1);
        char tmp[10];
        int cnt = 1;
        for (int i = 1, j = 0; str[i]; i++) {
            if (str[i] == str[j]) cnt += 1;
            else {
                sprintf(tmp, "%d%c", cnt, str[j]);
                ret += tmp;
                cnt = 1, j = i;
            }
        }
        sprintf(tmp, "%d%c", cnt, str[str.size() - 1]);
        ret += tmp;
        return ret;
    }
};
```

#### 2.6.0.17. [217å­˜åœ¨é‡å¤å…ƒç´ ](https://leetcode-cn.com/problems/contains-duplicate/description/)

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        return nums.size() > set<int>(nums.begin(), nums.end()).size();        
    }
};

```

#### 2.6.0.18. [219. å­˜åœ¨é‡å¤å…ƒç´  II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„å’Œä¸€ä¸ªæ•´æ•° *k*ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„ç´¢å¼• *i* å’Œ *j*ï¼Œä½¿å¾— **nums [i] = nums [j]**ï¼Œå¹¶ä¸” *i* å’Œ *j* çš„å·®çš„ **ç»å¯¹å€¼** è‡³å¤šä¸º *k*ã€‚

 

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        k += 1;
        unordered_map<int, int> s;
        for (int i = 0; i < nums.size(); i++) {
            s[nums[i]] += 1;
            if (i >= k) s[nums[i - k]] -= 1;
            if (s[nums[i]] == 2) return true;
        }
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n = nums.size();
        int l = 0,  r = -1;
        while (l < n) {
            if (r + 1 < n && r + 1 <= l + k) {
                ++r;
            } else {
                ++l;
            }
            if (r <= l) continue;
            if (nums[r] == nums[l]) return true;
        }
        return false;
    }
};
```

#### 2.6.0.19. [349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2) {
        set<int> record;
        for (int i = 0; i < nums1.size(); i++) {
            record.insert(nums1[i]);
        }

        set<int> resultSet;
        for (int i = 0; i < nums2.size(); ++i) {
            if (record.find(nums2[i]) != record.end()) {
                resultSet.insert(nums2[i]);
            }
        }

        vector<int> res;
        for (set<int>::iterator iter = resultSet.begin(); iter != resultSet.end(); iter++) {
            res.push_back(*iter);
        }
        return res;
    }
};
```

```cpp
è¾“å‡ºç»“æœä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œåº”ä¸å…ƒç´ åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°çš„æœ€å°å€¼ä¸€è‡´ã€‚
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) return intersect(nums2,nums1);
        unordered_map<int,int> mp;
        for (int i:nums1)
        {
            mp[i]++;
        }
        vector<int> nums;
        for (int j:nums2)
        {
            if (mp[j] > 0)
            {
                nums.push_back(j);
                mp[j]--;
            }
        }
        return nums;


    }
};
```

#### 2.6.0.20. LC-375[çŒœæ•°å­—å¤§å° II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/description/)

æˆ‘ä»¬æ­£åœ¨ç©ä¸€ä¸ªçŒœæ•°æ¸¸æˆï¼Œæ¸¸æˆè§„åˆ™å¦‚ä¸‹ï¼š

æˆ‘ä» **1** åˆ° **n** ä¹‹é—´é€‰æ‹©ä¸€ä¸ªæ•°å­—ï¼Œä½ æ¥çŒœæˆ‘é€‰äº†å“ªä¸ªæ•°å­—ã€‚

æ¯æ¬¡ä½ çŒœé”™äº†ï¼Œæˆ‘éƒ½ä¼šå‘Šè¯‰ä½ ï¼Œæˆ‘é€‰çš„æ•°å­—æ¯”ä½ çš„å¤§äº†æˆ–è€…å°äº†ã€‚

ç„¶è€Œï¼Œå½“ä½ çŒœäº†æ•°å­— x å¹¶ä¸”çŒœé”™äº†çš„æ—¶å€™ï¼Œä½ éœ€è¦æ”¯ä»˜é‡‘é¢ä¸º x çš„ç°é‡‘ã€‚ç›´åˆ°ä½ çŒœåˆ°æˆ‘é€‰çš„æ•°å­—ï¼Œä½ æ‰ç®—èµ¢å¾—äº†è¿™ä¸ªæ¸¸æˆã€‚

**ç¤ºä¾‹:**

```
n = 10, æˆ‘é€‰æ‹©äº†8.

ç¬¬ä¸€è½®: ä½ çŒœæˆ‘é€‰æ‹©çš„æ•°å­—æ˜¯5ï¼Œæˆ‘ä¼šå‘Šè¯‰ä½ ï¼Œæˆ‘çš„æ•°å­—æ›´å¤§ä¸€äº›ï¼Œç„¶åä½ éœ€è¦æ”¯ä»˜5å—ã€‚
ç¬¬äºŒè½®: ä½ çŒœæ˜¯7ï¼Œæˆ‘å‘Šè¯‰ä½ ï¼Œæˆ‘çš„æ•°å­—æ›´å¤§ä¸€äº›ï¼Œä½ æ”¯ä»˜7å—ã€‚
ç¬¬ä¸‰è½®: ä½ çŒœæ˜¯9ï¼Œæˆ‘å‘Šè¯‰ä½ ï¼Œæˆ‘çš„æ•°å­—æ›´å°ä¸€äº›ï¼Œä½ æ”¯ä»˜9å—ã€‚

æ¸¸æˆç»“æŸã€‚8 å°±æ˜¯æˆ‘é€‰çš„æ•°å­—ã€‚

ä½ æœ€ç»ˆè¦æ”¯ä»˜ 5 + 7 + 9 = 21 å—é’±ã€‚
```

ç»™å®š **n â‰¥ 1ï¼Œ**è®¡ç®—ä½ è‡³å°‘éœ€è¦æ‹¥æœ‰å¤šå°‘ç°é‡‘æ‰èƒ½ç¡®ä¿ä½ èƒ½èµ¢å¾—è¿™ä¸ªæ¸¸æˆã€‚

åŠ¨æ€è§„åˆ’ æå°æå¤§åŒ–æ€è·¯ï¼šè¿™æ˜¯ä¸€é“Minimaxç®—æ³• åˆåæå°åŒ–æå¤§ç®—æ³•é—®é¢˜ã€‚å±€éƒ¨æœ€å¤§å€¼ï¼Œå…¨å±€æœ€å°å€¼ã€‚

ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„å¥½å¤„åœ¨äºæˆ‘å¯ä»¥ç©·ä¸¾æ‰€æœ‰çš„æƒ…å†µï¼Œå¯¹äºè¿™ä¸ªé¢˜æ¥è¯´ï¼Œå°±æ˜¯æŒ‡åŠ¨æ€è§„åˆ’çš„æ–¹æ³•å¯ä»¥æŠŠæ¯ä¸€ä¸ªæ•°å­—éƒ½å½“ä½œåˆ†å‰²ç‚¹ï¼Œè€ŒäºŒåˆ†åªèƒ½æŠŠä¸­é—´çš„æ•°å­—å½“ä½œåˆ†å‰²ç‚¹ã€‚

å¯¹äºåŠ¨æ€è§„åˆ’æ¥è¯´ï¼Œéœ€è¦æ˜ç™½dp[i][j]çš„å«ä¹‰ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥æˆ‘å°è¯•è§£é‡Šdp\[i][j]çš„å«ä¹‰:
dp\[i][j]æ˜¯è¯´ä¾æ¬¡ä»¥ä»iåˆ°jçš„æ•°å­—ä½œä¸ºåˆ†å‰²ç‚¹(çŒœçš„æ•°)ï¼Œå¿…å®šèµ¢çš„æ¸¸æˆæ‰€ç”¨é’±çš„æœ€å°å€¼ã€‚

å¯¹äºæ¯ä¸€ä¸ªåˆ†å‰²ç‚¹ï¼Œæˆ‘ä»¬å–å®ƒå·¦å³ä¸¤è¾¹åŒºé—´çš„æœ€å¤§å€¼åŠ ä¸Šåˆ†å‰²ç‚¹æœ¬èº«ä½œä¸ºå–æ­¤åˆ†å‰²ç‚¹çš„dp[i][j]å€¼
å¯¹äºæ¯ä¸€ä¸ªåŒºé—´ï¼Œæˆ‘ä»¬å–æ‰€æœ‰åˆ†å‰²ç‚¹çš„dp[i][j]çš„æœ€å°å€¼ä½œä¸ºdp[i][j]çš„çœŸæ­£çš„å€¼
ç‰¹åˆ«åœ°ï¼Œå¯¹äºä»¥iä½œä¸ºåˆ†å‰²ç‚¹çš„dp[i][j]ï¼Œåªå–iå³è¾¹çš„åŒºé—´ï¼›å¯¹äºä»¥jä½œä¸ºåˆ†å‰²ç‚¹çš„dp[i][j]ï¼Œåªå–jå·¦è¾¹çš„åŒºé—´

>i i+1 i+2 ... ... j-2 j-1 j
>ä»¥i+1ä¸ºåˆ†å‰²ç‚¹å¯¹åº”çš„ï¼šdp1=max(dp\[i][i],dp\[i+2][j])+i+1
>ä»¥j-1ä¸ºåˆ†å‰²ç‚¹å¯¹åº”çš„: dp2=max(dp\[i][j-2],dp\[j][j])+j-1
>ç‰¹åˆ«åœ°,ä»¥iä¸ºåˆ†å‰²ç‚¹ï¼šdp0=i+dp\[i+1][j];ä»¥jä¸ºåˆ†å‰²ç‚¹: dp3=j+dp[i][j-1]
>dp\[i][j]=min(dp0,dp1,dp2,dp3)

ç»™å‡ºä¸€ä¸ªdpäºŒç»´æ•°ç»„æ¥ç”¨ä»£ç å¡«å……å®ƒï¼Œâ€œ\â€è¡¨ç¤ºæ­£æ— ç©·

(1)åˆå§‹åŒ–ï¼š         (2)æ˜“çŸ¥dp\[i][i]=0   

| \ \ \ \ |         | 0 \ \ \ |
| \ \ \ \ |         | \ 0 \ \ |
| \ \ \ \ |         | \ \ 0 \ |
| \ \ \ \ |         | \ \ \ 0 |
æ¥ä¸‹æ¥è¦è€ƒè™‘æ€ä¹ˆå¡«å……çŸ©é˜µä»¥å¾—åˆ°dp\[1][n]:
å¾ˆå®¹æ˜“æˆ‘ä»¬å‘ç°å¯ä»¥ç”¨ä¸€ä¸ªä½ç½®å·¦è¾¹å’Œä¸‹è¾¹åœ°æ•°æ®æ¥è®¡ç®—å®ƒæœ¬èº«ï¼Œå› æ­¤å¯ä»¥è¿™æ ·å¡«å……

(3)å¡«å……1åˆ—ï¼š
| 0 1 \ \ |  dp\[1][2]è®¡ç®—æ­¥éª¤å‘ä¸Šçœ‹
| \ 0 \ \ |
| \ \ 0 \ |
| \ \ \ 0 |
(4)å†å¡«å……1åˆ—ï¼š
| 0 1 x \ |  dp\[1][3]è®¡ç®—æ­¥éª¤å‘ä¸Šçœ‹
| \ 0 2 \ |  dp\[2][3]è®¡ç®—æ­¥éª¤å‘ä¸Šçœ‹(å…ˆå¡«å……)
| \ \ 0 \ |
| \ \ \ 0 |

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        if (n == 1) return 0;
        int dp[n + 1][n + 1];
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= n; ++j) {
                dp[i][j] = INT_MAX;
            }
        }
        for (int i = 0; i <= n; ++i) dp[i][i] = 0;
        for (int j = 2; j <= n; j++) {
            for (int i = j - 1; i >= 1; i--) {
                for (int k = i + 1; k <= j - 1; k++) {
                    dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]));

                }
                dp[i][j] = min(dp[i][j], i + dp[i + 1][j]);
                dp[i][j] = min(dp[i][j], j + dp[i][j - 1]);

            }
        }

        return dp[1][n];
    }
private :
    int calculate(int low, int high) {
        if (low >= high) return 0;
        int minres = 0x7fffffff;
        for (int i = (low + high) / 2; i <= high; ++i) {
            int res = max(calculate(low, i - 1), calculate(i + 1, high)) + i;
            minres = min(minres, res);
        }
        return minres;
    }
};
```







#### 2.6.0.21. [378. æœ‰åºçŸ©é˜µä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

éš¾åº¦ä¸­ç­‰443

ç»™å®šä¸€ä¸ª *`n x n`* çŸ©é˜µï¼Œå…¶ä¸­æ¯è¡Œå’Œæ¯åˆ—å…ƒç´ å‡æŒ‰å‡åºæ’åºï¼Œæ‰¾åˆ°çŸ©é˜µä¸­ç¬¬ `k` å°çš„å…ƒç´ ã€‚
è¯·æ³¨æ„ï¼Œå®ƒæ˜¯æ’åºåçš„ç¬¬ `k` å°å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ `k` ä¸ªä¸åŒçš„å…ƒç´ ã€‚

 ```cpp

class Solution {
public:
    bool check(vector<vector<int>>& matrix,int k,int mid,int n){
        int i=n-1,j=0;
        int num=0;
        while(i>=0 && j<n){
            if(matrix[i][j]<=mid){
                num+=i+1;
                j++;
            }
            else    i--;
        }
        return num>=k;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n=matrix.size();
        int left=matrix[0][0],right=matrix[n-1][n-1];
        while(left<right){
            int mid=left+(right-left)/2;
            if(check(matrix,k,mid,n)) right=mid;
            else left=mid+1;
        }
        return left;
    }
};
 ```

```cpp
class Solution {
public:
    int bs_max(vector<vector<int>> &g, int val) {
        int cnt = 0, i = g.size();
        while (i > 0 && g[i - 1][0] > val) i -= 1;
        cnt += g.size() - i;
        for (int j = 1; j < g.size(); j++) {
            while (i > 0 && g[i - 1][j] > val) --i;
            cnt += g.size() - i;
        }
        return cnt;
    }
    int bs_min(vector<vector<int>> &g, int val) {
        int cnt = 0, i = -1;
        while (i + 1 < g.size() && g[i + 1][0] < val) i += 1;
        cnt += i + 1;
        for (int j = 1; j < g.size(); j++) {
            while (i >= 0 && g[i][j] >= val) --i;
            cnt += i + 1;
        }
        return cnt;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        int head = matrix[0][0], tail = matrix[n - 1][n - 1], mid;
        while (head <= tail) {
            mid = ((head ^ tail) >> 1) + (head & tail);
            int a = bs_min(matrix, mid);
            int b = bs_max(matrix, mid);
            int c = n * n - a - b;
            if (k <= a + c && k > a) return mid;
            if (a + c < k) head = mid + 1;
            else tail = mid - 1;
        }
        return -1;
    }
};
```

#### 2.6.0.22. LC-88 åˆå¹¶æ•°ç»„

> ç»™ä½ ä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2`ï¼Œè¯·ä½ å°† `nums2` åˆå¹¶åˆ° `nums1` ä¸­*ï¼Œ*ä½¿ `nums1` æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚
>
> åˆå§‹åŒ– `nums1` å’Œ `nums2` çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º `m` å’Œ `n` ã€‚ä½ å¯ä»¥å‡è®¾ `nums1` çš„ç©ºé—´å¤§å°ç­‰äº `m + n`ï¼Œè¿™æ ·å®ƒå°±æœ‰è¶³å¤Ÿçš„ç©ºé—´ä¿å­˜æ¥è‡ª `nums2` çš„å…ƒç´ ã€‚

``` cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, tar = m + n - 1;
        while (j >= 0) {
            nums1[tar--] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
        }
    }
};
```

#### 2.6.0.23. æœ€å¤§å¹³å‡å€¼

**é¢˜ç›®æè¿°**

 ç»™å®šä¸€ä¸ªæœ‰ Nä¸ªå…ƒç´ çš„éè´Ÿåºåˆ—ï¼Œæ±‚é•¿åº¦å¤§äºç­‰äº M çš„è¿ç»­å­åºåˆ—çš„æœ€å¤§å¹³å‡å€¼ã€‚

æœ€å¤§å¹³å‡å€¼ä»‹äºå…ƒç´ çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ä¹‹é—´->äºŒåˆ†æ³•

åŒºé—´å’Œ->å‰ç¼€å’Œ->æ±‚è§£åˆ¤æ–­æ˜¯å¦å­˜åœ¨é•¿åº¦>=Mçš„è¿ç»­å­åºåˆ— >= LA(ç»™å®šå€¼)

æ–¹æ³•:åœ¨å‰ç¼€å’Œæ•°ç»„ä¸­ç»´æŠ¤ä¸€ä¸ªæœ€å°å€¼->åˆ¤å­˜åœ¨æ€§

$a_{i+1} + \cdots + a_{i + L} >= AL \\ b_i = a_i - L \\ b_{i + 1} + \cdots + a_{i + L} >= 0$



````cpp
#define MAX_N 100000
long long arr[MAX_N + 5];
long long b[MAX_N + 5];
bool check(long long n, long long m, long long val) {
    for (long long i = 1; i <= n; ++i) b[i] = arr[i] - val;
    for (long long i = 1; i <= n; ++i) b[i] += b[i - 1];
    long long pre = 0;
    for (long long i = m; i <= n; ++i) {
        pre = min(pre, b[i - m]);
        if (b[i] - pre >= 0) return true;
    }
    return false;
}

long long bs(long long l, long long r, long long n, long long m) {
    if (l == r) return l;
    long long mid = (l + r + 1) >> 1;
    if (check(n, m, mid)) return bs(mid, r, n, m);
    return bs(l, mid - 1, n, m);

}

int main() {
    long long n, m, s, t;
    cin >> n >> m;
    for (long long i = 1; i <= n; ++i) {
        cin >> arr[i];
        arr[i] *= 1000;
        if (i == 1) s = t = arr[i];
        s = min(s, arr[i]);
        t = max(t, arr[i]);
    }
    cout << bs(s, t, n, m) << endl;
    return 0;
}

````

#### 2.6.0.24. ç§¦è…¾ä¸æ•™å­¦è¯„ä¼°.cpp

> æˆ‘ä»¬å¯ä»¥ç”¨ä¸‰ä¸ªæ•´æ•°S,E,D æ¥æè¿°è¯„ä¼°å›¢çš„å°ç»„: æ—¢è¯¥å°ç»„çš„æˆå‘˜åœ¨ä»å®¿èˆåˆ°æ•™å­¦æ¥¼çš„è·¯ä¸Šçš„:S,S+D,S+2D,â€¦,S+KD(KâˆˆZ,S+KDâ‰¤E,S+(K+1)D>E) ä½ç½®ã€‚
>
> æ‰¾å‡ºå¥‡æ•°äººæ•°çš„ä½ç½®æœ€å¤šæœ‰ä¸€ä¸ª
>
> ![image-20210125213921849](/Image/A1.Data_Structure-photo/image-20210125213921849.png)

```cpp
#define MAX_N  200000

struct Node {
    long long s, e, d;
} data[MAX_N + 5];

long long count(long long n, long long pos) {
    long long sum = 0;
    for (long long i = 0; i < n; ++i) {
        if (data[i].s > pos) continue;
        if (data[i].e <= pos) {
            sum += (data[i].e - data[i].s) / data[i].d + 1;
            continue;
        }
        sum += (pos - data[i].s) / data[i].d + 1;
    }
    return sum;
}

long long check(long long n, long long pos) {
   return count(n, pos) % 2; 
}

long long bs(long long l, long long r, long long n) {
    if (l == r) return l;
    long long mid = (l + r) >> 1;
    if (check(n, mid)) return bs(l, mid, n);
    else bs(mid + 1, r, n);
}

long long calc(long long n) {
    long long l, r, mid;
    for (long long i = 0; i < n; ++i) {
        cin >> data[i].s >> data[i].e >> data[i].d;
        if (i == 0) l = data[i].s, r = data[i].e;
        l = min(l, data[i].s);
        r = max(r, data[i].e);
    }
    long long pos = bs(l, r, n);
    long long cnt = count(n, pos) - count(n, pos - 1);
    if (cnt & 1) {
        cout << pos << " " << cnt << endl;
    } else {
        cout << "Poor QIN Teng:(" << endl;
    }
    return 0;
}


int main() {
    long long t, n;
    cin >> t;
    for (long long i = 0; i < t; ++i) {
        cin >> n;
        calc(n);
    }
    return 0;
}

```

#### 2.6.0.25. HZOJ-244-å¥¶ç‰›å›´æ 

![image-20210125233324739](/Image/A1.Data_Structure-photo/image-20210125233324739.png)



10000->äºŒç»´æ•°ç»„,ç¦»æ•£åŒ–å‡ä¸å¯

```cpp
#define MAX_N 500

struct Data {
    int x, y;
} arr[MAX_N + 5];
int tmp[MAX_N + 5];

bool check_y(int l, int r, int c, int len) {
    int cnt = 0;
    for (int i = l; i <= r; ++i) {
        tmp[cnt++] = arr[i].y;
    }
    sort(tmp, tmp + cnt);
    for (int i = c - 1; i < cnt; ++i) {
        if (tmp[i] - tmp[i - c + 1] < len)  return true;
    }
    return false;
}

bool check(int n, int len, int c) {
    int j = 0;
    for (int i = 0; i < n; ++i) {
        while (arr[i].x - arr[j].x >= len) j++;
        if (arr[i].x - arr[j].x + 1 < c) continue;
        if (check_y(j, i, c, len)) return true;
    }
    return false;
}

bool cmp(const Data &a, const Data &b) {
    return a.x < b.x;
}

int main() {
    int c, n;
    cin >> c >> n;
    for (int i = 0; i < n; ++i) cin >> arr[i].x >> arr[i].y;
    sort(arr, arr + n, cmp);
    int l = 1, r = 10000;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(n, mid, c)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}

```



#### 2.6.0.26. [199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root!=NULL)
            que.push(root);
        while(!que.empty())
        {
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                TreeNode* p=que.front();
                que.pop();
                if(i==size-1)
                    res.push_back(p->val);
                if(p->left!=NULL)
                    que.push(p->left);
                if(p->right!=NULL)
                    que.push(p->right);
            }
        }
        return res;
    }
};
```

#### 2.6.0.27. [515. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        if(nullptr == root) return ans;
        dfs(root, 0);
        return ans;
    }
private:
    vector<int> ans;
    void dfs(TreeNode* root, int depth){
        if(nullptr == root) return;
        if(depth >= ans.size()) ans.push_back(root->val);
        if(root->val > ans[depth]) ans[depth] = root->val;
        dfs(root->left, depth + 1);
        dfs(root->right, depth + 1);
    }
};
```

# 3. ==å•è°ƒæ ˆ&å•è°ƒé˜Ÿåˆ—==

### 3.0.1. ã€HZOJ-261-æ•°æ®ç»“æ„

1. å…³é”®å°±æ˜¯æ–°é€ ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œç»“æ„å®šä¹‰ + ç»“æ„æ“ä½œ
2. æ¨¡æ‹Ÿå…‰æ ‡çš„åŠŸèƒ½ï¼Œå·¦ç§»åŠ¨ã€å³ç§»åŠ¨ã€æ’å…¥ã€åˆ é™¤ï¼Œç”¨å¯¹é¡¶æ ˆæ¨¡æ‹Ÿ
3. å®ç°å¯¹é¡¶æ ˆï¼Œç”¨æ•°ç»„æ¨¡æ‹Ÿã€ç”¨é“¾è¡¨æ¨¡æ‹Ÿ
4. é¢˜ç›®ä¸­çš„ BUGï¼šQuery K ä¸­ï¼ŒK å¯èƒ½å¤§äºå½“å‰ä½ç½®

```cpp
#include <cinttypes>
using namespace std;

class NewStruct {
public :
    NewStruct() {
        sum[0] = 0;
        ans[0] = INT64_MIN;
    }
    void insert(long long x) {
        s1.push(x);
        int ind = s1.size();
        long long val = x + sum[ind - 1];
        long long val1 = max(ans[ind - 1], val);
        sum[ind] = val;
        ans[ind] = val1;
        return ;
    }
    void del() {
        if (s1.empty()) return ;
        s1.pop();
        return ;
    }
    void move_left() {
        if (s1.empty()) return ;
        s2.push(s1.top());
        del();
        return ;
    }
    void move_right() {
        if (s2.empty()) return ;
        insert(s2.top());
        s2.pop();
        return ;
    }
    long long query(long long k) {
        return ans[k];
    }
private:
    stack<long long> s1, s2;
    long long sum[1005];
    long long ans[1005];
};

int main() {
    long long n;
    cin >> n;
    string op;
    int val;
    NewStruct s;
    for (int i = 0; i < n; i++) {
        cin >> op;
        switch (op[0]) {
            case 'I': cin >> val; s.insert(val); break;
            case 'D': s.del(); break;
            case 'L': s.move_left(); break;
            case 'R': s.move_right(); break;
            case 'Q': {
                cin >> val; 
                cout << s.query(val) << endl;
            } break;
        }
    }
    return 0;
}
```

### 3.0.2. hzoj-262 å¡ç‰¹å…°æ•°



f(n)è¡¨ç¤ºè¿›æ ˆé¡ºåºä¸º1,2,...,Næ—¶å¯èƒ½çš„å‡ºæ ˆæ–¹æ¡ˆæ•°ï¼Œæ ¹æ®ä»¥å‰çš„ç»éªŒï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒåˆ’åˆ†æˆèŒƒå›´æ›´å°çš„å­é—®é¢˜ã€‚
è€ƒè™‘â€œ1â€â€œ1â€è¿™ä¸ªæ•°æ’åœ¨æœ€ç»ˆåºåˆ—çš„ä½ç½®ï¼Œå¯çŸ¥åªè¦â€œ1â€â€œ1â€çš„ä½ç½®ä¸åŒï¼Œåºåˆ—å°±ä¸åŒã€‚å¦‚æœâ€œ1â€â€œ1â€è¿™ä¸ªæ•°æ’åœ¨ç¬¬*ğ‘˜*kä¸ªï¼Œé‚£ä¹ˆæ•´ä¸ªåºåˆ—è¿›å‡ºæ ˆçš„è¿‡ç¨‹å³ä¸ºï¼š

1. â€œ1â€**å…¥æ ˆ**ã€‚

2. â€œ2,3,...,k"è¿™*ğ‘˜*âˆ’1kâˆ’1ä¸ªæ•°æŒ‰æŸç§é¡ºåº**è¿›å‡ºæ ˆ**ã€‚

3. â€œ1â€**å‡ºæ ˆ**ã€‚

4. â€œk+1,k+2,...,Nâ€è¿™*ğ‘*âˆ’*ğ‘˜*Nâˆ’kä¸ªæ•°æŒ‰æŸç§é¡ºåº**è¿›å‡ºæ ˆ**ã€‚

   ç”±äº k  æœ€åå‡ºæ ˆï¼Œåˆ™åœ¨ k å…¥æ ˆä¹‹å‰æ‰€æœ‰æ¯”ä»–å°çš„éƒ½å‡ºæ ˆäº†ï¼Œè¿™é‡Œçš„æƒ…å†µä¸º Fï¼ˆk-1ï¼‰ï¼Œæ‰€æœ‰æ¯” k å¤§çš„å…ƒç´ éƒ½åœ¨ k ä¹‹å‰å‡ºæ ˆï¼Œä¸º Fï¼ˆn-kï¼‰ç§æƒ…å†µ

äºæ˜¯è¿™æ ·å°±æŠŠåŸé—®é¢˜åˆ’åˆ†æˆäº†èŒƒå›´æ›´å°çš„å­é—®é¢˜ï¼Œå¾—åˆ°å…¬å¼ï¼š

$f(n)=âˆ‘_{i=1}^Nf(kâˆ’1)âˆ—f(Nâˆ’k)$



å½“ç„¶ï¼Œè¾¹ç•Œæ¡ä»¶ä¸ºï¼š*ğ‘“*(0)=1,*ğ‘“*(1)=1f(0)=1,f(1)=1

æ—¶é—´å¤æ‚åº¦ä¸º*ğ‘‚*(*ğ‘›*2)O(n2)ã€‚





### 3.0.3. ã€HZOJ-263-ç«è½¦è¿›æ ˆ

1. å½“å‰è¿›æ ˆçš„æœ€å¤§æ•°å­—æ˜¯ xï¼Œåºåˆ—ä¸­å½“å‰å¾…å‡ºæ ˆçš„æ•°å­—æ˜¯ y
2. $y <= x$ï¼Œè¯´æ˜ y ä¸€å®šæ˜¯æ ˆé¡¶å…ƒç´ 
3. $y > x$ï¼Œå°† $[x + 1, y]$ å…¥æ ˆï¼Œæ­¤æ—¶æ ˆé¡¶å…ƒç´ ä¸€å®šæ˜¯ y



```cpp
int a[30], s[30], top;

bool is_valid(int *a, int n) {
    int j = 0;
    top = -1;
    for (int i = 0; i < n; i++) {
        while (j < a[i]) { s[++top] = (++j); }
        if (top == -1 || s[top] - a[i]) return false;
        --top;
    }
    return true;
}

int main() {
    int n, ans = 20;
    cin >> n; 
    for (int i = 0; i < n; i++) a[i] = i + 1;
    do {
        if (!is_valid(a, n)) continue;
        for (int i = 0; i < n; i++) {
            cout << a[i];
        }
        cout << endl;
        --ans;
    } while (ans && next_permutation(a, a + n));
    return 0;
}
```



### 3.0.4. hzoj-68. æœ‹å‹é˜Ÿåˆ—



![image-20210308140505286](/Image/A1.Data_Structure-photo/image-20210308140505286.png)



Code:

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;
#define MAX_N 200000

map<int, int> q_ind;
queue<int> main_q;
queue<int> q[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    for (int i = 1, m; i <= n; i++) {
        cin >> m;
        for (int j = 1, a; j <= m; j++) {
            cin >> a;
            q_ind[a] = i;
        }
    }
    string op;
    while (cin >> op) {
        if (op == "STOP") break;
        if (op == "ENQUEUE") {
            int x;
            cin >> x;
            q[q_ind[x]].push(x);
            if (q[q_ind[x]].size() == 1) {
                main_q.push(q_ind[x]);
            }
        } else {
            cout << q[main_q.front()].front() << endl;
            q[main_q.front()].pop();
            if (q[main_q.front()].empty()) main_q.pop();
        }
    }
    return 0;
}

```







## 3.1. äºŒã€å•è°ƒé˜Ÿåˆ—







## 3.1. äºŒã€å•è°ƒé˜Ÿåˆ—

1. æœ¬è´¨é—®é¢˜æ˜¯ï¼šå›ºå®šæŸ¥è¯¢ç»“å°¾çš„ RMQ é—®é¢˜ï¼Œä¾‹å¦‚ $RMQ(x, 7)$
2. é—®é¢˜æ€§è´¨ï¼šç»´æŠ¤æ»‘åŠ¨çª—å£æœ€å€¼é—®é¢˜
3. å…¥é˜Ÿï¼šå°†é˜Ÿå°¾è¿åå•è°ƒæ€§çš„å…ƒç´ æ·˜æ±°å‡ºå±€ï¼Œå†å°†å½“å‰å…ƒç´ å…¥é˜Ÿ
4. å‡ºé˜Ÿï¼šå¦‚æœé˜Ÿé¦–å…ƒç´ è¶…å‡ºäº†æ»‘åŠ¨çª—å£çš„èŒƒå›´ï¼Œé˜Ÿé¦–å‡ºé˜Ÿ
5. é˜Ÿé¦–å…ƒç´ ï¼šæ»‘åŠ¨çª—å£å†…çš„æœ€å€¼
6. å‡æ‘Šæ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

```cpp
#define MAX_N 300000
int q[MAX_N + 5], head = 0, tail = 0;
int val[MAX_N + 5];

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] > val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    head = tail = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] < val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    return 0;
}
```





### 3.1.1. HZOJ-271-æ»‘åŠ¨çª—å£

å•è°ƒé˜Ÿåˆ—çš„è£¸é¢˜ï¼Œæ²¡ä»€ä¹ˆå¥½è®²çš„ï¼Œä¸»è¦è¦å­¦ä¹ ä»£ç å®ç°

**æ€è€ƒï¼š**å•è°ƒé˜Ÿåˆ—ä¸­æ˜¯è®°å½•å€¼è¿˜æ˜¯è®°å½•ä¸‹æ ‡çš„é—®é¢˜

**ç»“è®ºï¼š**è®°å½•ä¸‹æ ‡ï¼Œå› ä¸ºæœ‰äº†ä¸‹æ ‡å¯ä»¥ç´¢å¼•åˆ°å€¼ï¼Œè®°å½•å€¼åˆ™åå‘ä¸å¯æŸ¥

```cpp
#define MAX_N 100000
long long s[MAX_N + 5], top;
long long h[MAX_N + 5], n;
long long l[MAX_N + 5], r[MAX_N + 5];

void read() {
    scanf("%lld", &n);
    for (long long i = 1; i <= n; i++) scanf("%lld", h + i);
    return ;
}

long long solve() {
    h[0] = h[n + 1] = -1;
    top = -1;
    s[++top] = 0;
    for (long long i = 1; i <= n; i++) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        l[i] = s[top];
        s[++top] = i;
    }
    top = -1;
    s[++top] = n + 1;
    for (long long i = n; i >= 1; i--) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        r[i] = s[top];
        s[++top] = i;
    }
    long long ans = 0;
    for (long long i = 1; i <= n; i++) {
        ans = max(ans, h[i] * (r[i] - l[i] - 1));
    }
    return ans;
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}
```





## 3.2. ä¸‰ã€å•è°ƒæ ˆ

1. å•è°ƒæ ˆä¿ç•™äº†å•è°ƒé˜Ÿåˆ—çš„ã€å…¥é˜Ÿã€æ“ä½œ
2. å•è°ƒæ ˆä¾ç„¶æ˜¯ç»´æŠ¤äº†ä¸€ç§å•è°ƒæ€§
3. é—®é¢˜æ€§è´¨ï¼šæœ€è¿‘ï¼ˆå¤§äº/å°äºï¼‰å…³ç³»
4. å…¥æ ˆä¹‹å‰ï¼Œç¬¦åˆå•è°ƒæ€§çš„æ ˆé¡¶å…ƒç´ ï¼Œå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘ï¼ˆå¤§äº/å°äºï¼‰å…³ç³»
5. å‡æ‘Šæ—¶é—´å¤æ‚åº¦ï¼š$O(1)$



### 3.2.1. HZOJ-264-æœ€å¤§çŸ©å½¢é¢ç§¯

1. åˆ†ææœ€ä¼˜è§£çš„æ€§è´¨ï¼Œæ˜¯è§£å†³é—®é¢˜çš„ç¬¬ä¸€æ­¥
2. æœ€å¤§çŸ©å½¢çš„æ€§è´¨ï¼šä¸€å®šæ˜¯ä»¥å…¶æ‰€åœ¨åŒºåŸŸä¸­æœ€çŸ®çš„æœ¨æ¿ä¸ºé«˜åº¦çš„
3. ä»¥æ¯ä¸€å—æœ¨æ¿åšä¸ºçŸ©å½¢é«˜åº¦ï¼Œæ±‚èƒ½å¾—åˆ°çš„æœ€å¤§çŸ©å½¢é¢ç§¯ï¼Œæœ€ååœ¨æ‰€æœ‰é¢ç§¯ä¸­ï¼Œå–ä¸€ä¸ªæœ€å¤§å€¼
4. éœ€è¦æ±‚è§£ï¼šæ¯ä¸€å—æœ¨æ¿æœ€è¿‘çš„é«˜åº¦å°äºå½“å‰æœ¨æ¿çš„ä½ç½®ï¼Œæ‰€ä»¥éœ€è¦ç”¨å•è°ƒæ ˆ







# 4. ==å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•==

**ç¡®å®šå‹æœ‰ç©·è‡ªåŠ¨æœºï¼ˆDeterminism Finite Automate, DFAï¼‰**ï¼Œä¸**éç¡®å®šå‹æœ‰ç©·è‡ªåŠ¨æœºï¼ˆNon-determinism Finite Automate, NFAï¼‰**ã€‚

***nextè¡¨ç¤ºé•¿åº¦ä¸ºiçš„å­—ç¬¦ä¸²å‰ç¼€å’Œåç¼€çš„æœ€é•¿å…¬å…±éƒ¨åˆ†*kmpç®—æ³•**

nextæ•°ç»„ä¸‰ç§ç”¨æ³•

https://blog.csdn.net/yutianzuijin/article/details/11954939/

![image-20210126164802088](/Image/A1.Data_Structure-photo/image-20210126164802088.png)

Taæ˜¯æœ€é•¿å‰ç¼€(å¦åˆ™æ¼ç­”æ¡ˆ)

**==kmpç®—æ³•çš„æ ¸å¿ƒ==**å³æ˜¯è®¡ç®—å­—ç¬¦ä¸²fæ¯ä¸€ä¸ªä½ç½®ä¹‹å‰çš„å­—ç¬¦ä¸²çš„å‰ç¼€å’Œåç¼€å…¬å…±éƒ¨åˆ†çš„æœ€å¤§é•¿åº¦

å½“æ¯æ¬¡æ¯”è¾ƒåˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å­—ç¬¦ä¸åŒæ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ ¹æ®æœ€å¤§å…¬å…±é•¿åº¦å°†å­—ç¬¦ä¸²få‘å‰ç§»åŠ¨(å·²åŒ¹é…é•¿åº¦-æœ€å¤§å…¬å…±é•¿åº¦)ä½ï¼Œæ¥ç€ç»§ç»­æ¯”è¾ƒä¸‹ä¸€ä¸ªä½ç½®ã€‚

â€‹    å¦‚æœä½ç½®iå’Œnext[i]å¤„çš„ä¸¤ä¸ªå­—ç¬¦ç›¸åŒï¼ˆä¸‹æ ‡ä»é›¶å¼€å§‹)ï¼Œåˆ™next[i+1]ç­‰äºnext[i]åŠ 1ã€‚

â€‹    å¦‚æœä¸¤ä¸ªä½ç½®çš„å­—ç¬¦ä¸ç›¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å°†é•¿åº¦ä¸ºnext[i]çš„å­—ç¬¦ä¸²ç»§ç»­åˆ†å‰²ï¼Œè·å¾—å…¶æœ€å¤§å…¬å…±é•¿åº¦next[next[i]]ï¼Œç„¶åå†å’Œä½ç½®içš„å­—ç¬¦æ¯”è¾ƒã€‚è¿™æ˜¯å› ä¸ºé•¿åº¦ä¸ºnext[i]å‰ç¼€å’Œåç¼€éƒ½å¯ä»¥åˆ†å‰²æˆä¸Šéƒ¨çš„æ„é€ ï¼Œå¦‚æœä½ç½®next[next[i]]å’Œä½ç½®içš„å­—ç¬¦ç›¸åŒï¼Œåˆ™next[i+1]å°±ç­‰äºnext[next[i]]åŠ 1ã€‚å¦‚æœä¸ç›¸ç­‰ï¼Œå°±å¯ä»¥ç»§ç»­åˆ†å‰²é•¿åº¦ä¸ºnext[next[i]]çš„å­—ç¬¦ä¸²ï¼Œç›´åˆ°å­—ç¬¦ä¸²é•¿åº¦ä¸º0ä¸ºæ­¢

![img](/Image/A1.Data_Structure-photo/20151212110619965)



## 4.1. ä¸€ã€æš´åŠ›åŒ¹é…ç®—æ³•

1. å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ï¼šå•æ¨¡åŒ¹é…é—®é¢˜ï¼Œé¡¾åæ€ä¹‰ï¼Œåªæœ‰ä¸€ä¸ªæ¨¡å¼ä¸²
2. ä¾æ¬¡å¯¹é½æ¨¡å¼ä¸²å’Œæ–‡æœ¬ä¸²çš„æ¯ä¸€ä½ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸ
3. å…³é”®ï¼šä¸é‡ä¸æ¼çš„æ‰¾åˆ°ç­”æ¡ˆ



## 4.2. äºŒã€KMP ç®—æ³•

1. KMP ç®—æ³•ä¸­ï¼Œæ¨¡å¼ä¸²ä¸­çš„ç¬¬ä¸‰éƒ¨åˆ†çš„é‡è¦æ€§
2. ç¬¬ä¸‰éƒ¨åˆ†æ˜¯å¯ä»¥å¸®åŠ©æˆ‘ä»¬åŠ å¿«åŒ¹é…é€Ÿåº¦çš„ï¼Œé¿å…æ‰å¤§é‡æ— ç”¨çš„åŒ¹é…å°è¯•
3. KMP ç®—æ³•ä¿è¯ä¸æ¼ï¼šç¬¬ä¸‰éƒ¨åˆ†åŒ¹é…åˆ°çš„æ˜¯æ¨¡å¼ä¸²çš„æœ€é•¿å‰ç¼€
4. æ™®é€šç¼–ç ï¼šè·å¾— NEXT æ•°ç»„ï¼Œä½¿ç”¨ NEXT æ•°ç»„
5. é«˜çº§ç¼–ç ï¼šæŠ½è±¡åŒ–äº†ä¸€ä¸ªçŠ¶æ€æœºæ¨¡å‹ï¼Œj æ‰€æŒ‡å‘çš„å°±æ˜¯çŠ¶æ€æœºä¸­çš„ä½ç½®
6. getNext æ–¹æ³•ç›¸å½“äºæ ¹æ®è¾“å…¥å­—ç¬¦ï¼Œè¿›è¡ŒçŠ¶æ€è·³è½¬ï¼Œå®é™…ä¸Šå°±æ˜¯æ”¹å˜ j çš„å€¼

Taæ˜¯æœ€é•¿å‰ç¼€(å¦åˆ™æ¼ç­”æ¡ˆ)

## 4.3. ä¸‰ã€SUNDAY ç®—æ³•

1. SUNDAY ç®—æ³•ç†è§£çš„æ ¸å¿ƒï¼Œåœ¨äºç†è§£é»„é‡‘å¯¹é½ç‚¹ä½

2. æ˜¯æ–‡æœ¬ä¸²çš„åŒ¹é…å°¾éƒ¨ï¼Œä¸€å®šä¼šå‡ºç°åœ¨æ¨¡å¼ä¸²ä¸­çš„å­—ç¬¦

3. åº”è¯¥å’Œæ¨¡å¼ä¸²ä¸­æœ€åä¸€ä½å‡ºç°è¯¥å­—ç¬¦çš„ä½ç½®å¯¹é½

4. ç¬¬ä¸€æ­¥ï¼šé¢„å¤„ç†æ¯ä¸€ä¸ªå­—ç¬¦åœ¨æ¨¡å¼ä¸²ä¸­æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®

5. ç¬¬äºŒæ­¥ï¼šæ¨¡æ‹Ÿæš´åŠ›åŒ¹é…ç®—æ³•è¿‡ç¨‹ï¼Œå¤±é…çš„æ—¶å€™ï¼Œæ–‡æœ¬ä¸²æŒ‡é’ˆæ ¹æ®é¢„å¤„ç†ä¿¡æ¯å‘åç§»åŠ¨è‹¥å¹²ä½


## 4.4. ä¸€ã€å­—ç¬¦ä¸²çš„å“ˆå¸ŒåŒ¹é…ç®—æ³•

   

  1. å¯ä»¥ä½¿ç”¨å“ˆå¸Œæ“ä½œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰
  2. å“ˆå¸Œå€¼ä¸åŒçš„è¯ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²ä¸€å®šä¸ç›¸ç­‰ï¼Œä»è€Œå°±ä¸éœ€è¦æŒ‰ä½æ¯”è¾ƒäº†
  3. $H = (\sum_{k=0}^{n-1}{C_k\times base^k})\%P$
  4. åœ¨æ–‡æœ¬ä¸²ä¸Šï¼Œæ¯ä¸€ä½å­—ç¬¦ä¸²å“ˆå¸Œå€¼çš„å‰ç¼€å’Œï¼Œæ–¹ä¾¿ä¸€ä¼šæ±‚åŒºé—´å’Œ
  5. $H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}\%P $



æ‹“å±•æ¬§å‡ é‡Œå¾—ç®—æ³•



â€‹	$x_1 * x_2 \% p = 1 x_1$å’Œ$x_2$äº’ä¸ºé€†å…ƒ

   å¿«é€Ÿæ±‚é€†å…ƒçš„æ¨å¯¼è¿‡ç¨‹
$$
\begin{aligned}
   x\times x^{-1}&\equiv1\ (mod\ P) \\
   Letï¼šP\%x&=r \\
   P &= kx+r \\
   kx+r &\equiv0\ (mod\ P) \\
   kr^{-1}+x^{-1} &\equiv0\ (mod\ P) \\
   x^{-1} &\equiv-kr^{-1}\ (mod\ P) 
   \end{aligned}
$$

![image-20210126223810625](/Image/A1.Data_Structure-photo/image-20210126223810625-1611674126158.png)

![image-20210126223819648](/Image/A1.Data_Structure-photo/image-20210126223819648-1611674126158.png)




![image-20210126223842372](/Image/A1.Data_Structure-photo/image-20210126223842372-1611674126158.png)

```cpp
#define MAX_N 1000000
#define P 100007
#define base 13
int H[MAX_N + 5];
int K[MAX_N + 5];
int inv[P];
char s[MAX_N + 5];

void init() {
    inv[1] = 1;
    for (int i = 2; i < P; ++i) {
        inv[i] = ((-(P / i) * inv[P % i]) % P + P ) % P;
    }
    K[0] = 1;
    for (int i = 1; i <= MAX_N; ++i) {
        K[i] = (K[i - 1] * base) % P;
    }
    for (int i = 1; s[i]; ++i) {
        H[i] = (H[i - 1] + K[i] * s[i]) % P;
    }
    return ;
}

int getH(int l, int r) {
    return ((H[r] - H[l - 1]) % P * inv[K[l]] % P + P ) % P;
}

int is_same(int i, int j, int n) {
    for (int k = 0; k < n; ++i) {
        if (s[i + k] - s[j + k]) return false;
    }
    return true;
}

```







## 4.5. äºŒã€shift_and ç®—æ³•



 1. ç¬¬ä¸€æ­¥å¯¹æ¨¡å¼ä¸²åšç‰¹æ®Šå¤„ç†ï¼ŒæŠŠæ¯ä¸€ç§å­—ç¬¦å‡ºç°çš„ä½ç½®ï¼Œè½¬æ¢æˆç›¸åº”çš„äºŒè¿›åˆ¶ç¼–ç 
  2. åç»­åŒ¹é…çš„è¿‡ç¨‹ä¸­è·Ÿæ¨¡å¼ä¸²ä¸€æ¯›é’±å…³ç³»éƒ½æ²¡æœ‰
  3. $p_i = (p_{i-1}<<1 | 1) \& d[s_i]$
  4. $p_i$ç¬¬ j ä½äºŒè¿›åˆ¶ä¸º1ï¼Œä»£è¡¨å½“å‰ä½ç½®ä¸ºç»“å°¾ï¼Œå¯ä»¥åŒ¹é…æˆåŠŸæ¨¡å¼ä¸²çš„ç¬¬ j ä½      

 ![image-20210126223755896](/Image/A1.Data_Structure-photo/image-20210126223755896-1611674126158.png)

![image-20210126231420260](/Image/A1.Data_Structure-photo/image-20210126231420260.png)

   

### 4.5.1. code

```cpp
#define MAX_N 1000
#define TEST(func, a, b) { \
    printf("TEST %s(%s, %s) = %d\n", #func, a, b, func(a, b)); \
}
char text[MAX_N + 5], pattern[MAX_N + 5];

int brute_force(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    for (int i = 0, I = len1 - len2 + 1; i < I; i++) {
        int j = 0;
        for (; t[j]; j++) {
            if (t[j] == s[i + j]) continue;
            break;
        }
        if (!t[j]) return i;
    }
    return -1;
}

int sunday(char *s, char *t) {
    int ind[128] = {0};
    int len1 = strlen(s);
    int len2 = strlen(t);
    //len2 + 1æ˜¯å› ä¸ºæ²¡å‡ºç°è¿‡ï¼Œåä¸€ä½æ˜¯i+len2, æ‰€ä»¥ä» i + len2 + 1åŒ¹é…
    for (int i = 0; i < 128; i++) ind[i] = len2 + 1;
    for (int i = 0; t[i]; i++) ind[t[i]] = len2 - i;
    for (int i = 0, I = len1 - len2 + 1; i < I;) {
        int flag = 1;
        for (int j = 0; j < len2; j++) {
            if (t[j] == s[i + j]) continue;
            i += ind[s[i + len2]];
            flag = 0;
            break;
        }
        if (flag) return i;
    }
    return -1;
}

int shift_and(char *s, char *t) {
    int code[128] = {0};
    int len = 0;
    for (len = 0; t[len]; len++) {
        code[t[len]] |= (1 << len);
    }
    int p = 0;
    for (int i = 0; s[i]; i++) {
        p = (p << 1 | 1) & code[s[i]];
        if (p & (1 << (len - 1))) return i - len + 1;
    }
    return -1;
}

int kmp(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    int *next = (int *)malloc(sizeof(int) * len2);
    next[0] = -1;
    for (int i = 1, j = -1; i < len2; i++) {
        while (j != -1 && t[j + 1] != t[i]) j = next[j];
        if (t[j + 1] == t[i]) j += 1;
        next[i] = j;
    }
    for (int i = 0, j = -1; s[i]; i++) {
        while (j != -1 && t[j + 1] != s[i]) j = next[j];
        if (t[j + 1] == s[i]) j += 1;
        if (t[j + 1] == 0) return i - len2 + 1;
    }
    free(next);
    return -1;
}

int main() {
    scanf("%s%s", text, pattern);
    TEST(brute_force, text, pattern);
    TEST(kmp, text, pattern);
    TEST(sunday, text, pattern);
    TEST(shift_and, text, pattern);
    return 0;
}
```

### 4.5.2. oj-275

```cpp
#define MAX_N 1000000
#define P 9973
#define P1 100007
#define base 13
#define base1 103
long long H[MAX_N + 5];
long long H1[MAX_N + 5];
long long K[MAX_N + 5];
long long K1[MAX_N + 5];
long long inv[P];
long long inv1[P1];
char s[MAX_N + 5];

void init() {
    inv[1] = 1;
    inv1[1] = 1;
    for (long long i = 2; i < P; i++) {
        inv[i] = ((-(P / i) * inv[P % i]) % P + P) % P;
        inv1[i] = ((-(P1 / i) * inv1[P1 % i]) % P1 + P1) % P1;
    }
    K[0] = 1;
    K1[0] = 1;
    for (long long i = 1; i <= MAX_N; i++) {
        K[i] = (K[i - 1] * base) % P;
        K1[i] = (K1[i - 1] * base1) % P1;
    }
    H[0] = 0;
    H1[0] = 0;
    for (long long i = 1; s[i]; i++) {
        H[i] = (H[i - 1] + K[i] * s[i]) % P;
        H1[i] = (H1[i - 1] + K1[i] * s[i]) % P1;
    }
    return ;
}

long long getH(long long l, long long r) {
    return ((H[r] - H[l - 1]) % P * inv[K[l]] % P + P) % P;
}

long long getH1(long long l, long long r) {
    return ((H1[r] - H1[l - 1]) % P1 * inv1[K1[l]] % P1 + P1) % P1;
}

int main() {
    scanf("%s", s + 1);
    long long m, l1, l2, r1, r2;
    init();
    scanf("%lld", &m);
    for (long long i = 0; i < m; i++) {
        scanf("%lld%lld%lld%lld", &l1, &r1, &l2, &r2);
        if (getH(l1, r1) == getH(l2, r2) && getH1(l1, r1) == getH1(l2, r2)) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }
    return 0;
}
```





#### 4.5.2.1. [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        string ans;
        for (int l = 0; l < n; ++l) {
            for (int i = 0; i + l < n; ++i) {
                int j = i + l;
                if (l == 0) {
                    dp[i][j] = 1;
                } else if (l == 1) {
                    dp[i][j] = (s[i] == s[j]);
                } else {
                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
                }
                if (dp[i][j] && l + 1 > ans.size()) {
                    ans = s.substr(i, l + 1);
                }
            }
        }
        return ans;
    }
};

```



#### 4.5.2.2. HZOJ-278-å¾ªç¯å­—ç¬¦ä¸².cpp

```cpp
using namespace std;
#define MAX_N 1000000
char str[MAX_N + 5];
int nxt[MAX_N + 5];
int ans[MAX_N + 5];

void get_next(char *str, int *nxt) {
    int j = -1;
    nxt[0] = -1;
    for (int i = 1; str[i]; i++) {
        while (j != -1 && str[j + 1] != str[i]) j = nxt[j];
        if (str[j + 1] == str[i]) j += 1;
        nxt[i] = j;
    }
    return ;
}

int main() {
    int n;
    cin >> n;
    cin >> str;
    get_next(str, nxt);
    for (int i = 0; i < n; i++) {
        if (nxt[i] == -1 || i - nxt[i] != ans[nxt[i]]) {
            ans[i] = i + 1;
        } else {
            ans[i] = ans[nxt[i]];
        }
    }
    for (int i = 0; i < n; i++) {
        if (ans[i] == i + 1) continue;
        cout << i + 1 << " " << (i + 1) / ans[i] << endl;
    }
    return 0;
}
```

#### 4.5.2.3. HZOJ-281-å‰ç¼€ç»Ÿè®¡

```cpp
using namespace std;
#define MAX_N 1000000

struct Node {
    int flag;
    int next[26];
} tree[MAX_N + 5];
int root = 1, cnt = 1;
char str[MAX_N + 5];

int getNode() { return ++cnt; }
void insert(const char *str) {
    int p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a';
        if (tree[p].next[ind] == 0) tree[p].next[ind] = getNode();
        p = tree[p].next[ind];
    }
    tree[p].flag += 1;
    return ;
}

int query(const char *str) {
    int p = root, cnt = 0;
    for (int i = 0; str[i] && p; i++) {
        p = tree[p].next[str[i] - 'a'];
        cnt += tree[p].flag;
    }
    return cnt;
}
```

#### 4.5.2.4. HZOJ-282-æœ€å¤§äº¦æˆ–å’Œ

      1. æ€è€ƒï¼šå¦‚ä½•ä½¿å¾—å¼‚æˆ–ç»“æœå°½å¯èƒ½å¤§
      2. ç»“è®ºï¼šå‚ä¸å¼‚æˆ–è¿ç®—çš„ä¸¤ä¸ªæ•°å­—ï¼Œå‚ä¸å¼‚æˆ–è¿ç®—çš„æ¯ä¸€ä½å°½å¯èƒ½ä¸åŒ
      3. é—®é¢˜è½¬æ¢ä¸ºï¼šç¡®å®šä¸€ä¸ªæ•°å­—çš„æƒ…å†µä¸‹ï¼Œæ‰¾åˆ°ä»é«˜ä¸ºåˆ°ä½ä½ä¸å½“å‰æ•°å­—å°½é‡ä¸åŒçš„å¦å¤–ä¸€ä¸ªæ•°å­—
      4. æŠŠæ¯ä¸ªæ•°å­—çœ‹æˆä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ï¼Œæ’å…¥åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œé‡‡ç”¨è´ªå¿ƒç­–ç•¥è¿›è¡Œé€‰æ‹©

  

















```cpp
#define MAX_N 320000
#define BASE 30

struct Node {
    int num;
    int next[2];
} tree[MAX_N + 5];
int root = 1, cnt = 1;
int arr[(MAX_N >> 5 )+ 5];
inline int getNode() { return ++cnt; }
void insert(int num) {
    int p = root;
    for (int i = BASE; i >= 0; --i) {
        int ind = !!((1 << i) & num);
        if (tree[p].next[ind] == 0) tree[p].next[ind] = getNode();
        p = tree[p].next[ind];
    }
    tree[p].num = num;
    return ;
}

int query(int num) {
    int p = root;
    for (int i = BASE; i >= 0; i--) {
        int ind = !!((1 << i) & num);
        int rind = !ind;
        if (tree[p].next[rind]) p = tree[p].next[rind];
        else p = tree[p].next[ind];
    }
    return num ^ tree[p].num;
}

int main() {
    int n, ans = 0;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> arr[i], insert(arr[i]);
    for (int i = 0; i < n; i++) {
        ans = max(ans, query(arr[i]));
    }
    cout << ans << endl;
    return 0;
}
```



# 5. ==å­—å…¸æ ‘==

åç§°ï¼štrieï¼Œ å­—å…¸æ ‘ï¼Œå•è¯æŸ¥æ‰¾æ ‘

ä½œç”¨ï¼šå•è¯æŸ¥æ‰¾ï¼Œå­—ç¬¦ä¸²æ’åº

      1. ä¹Ÿå«åšï¼šå‰ç¼€ç´¢å¼•æ ‘
      2. æŠŠæ¯ä¸ªå­—ç¬¦ä¸²æŒ‰ç…§å‰ç¼€çš„é¡ºåºæ’å…¥åˆ°æ ‘å½¢ç»“æ„ä¸­
      3. å­—å…¸æ ‘å¯ä»¥ç”¨äºå­—ç¬¦ä¸²çš„æ’åºï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$

å­—å…¸æ ‘ç­‰ä»·äºå•è¯è¡¨

![image-20210126235307421](/Image/A1.Data_Structure-photo/image-20210126235307421-1623756908422.png)

9 < 11 å­—å…¸åº:09 < 11 ->æ–‡ä»¶å¤¹å‘½åæ’åº

çº¢è‰²èŠ‚ç‚¹å¯åšç»“å°¾ï¼Œç‹¬ç«‹æˆè¯ï¼Œè¾¹ä»£è¡¨å­—æ¯

æ¯”è¾ƒæ“ä½œçš„æ—¶é—´ä¸‹é™ä¸ºO(nlogn);

å­—å…¸åºæ’åºå•è¯ï¼šä¸ºO(n); 

å°ç‚¹ï¼šç³»ç»Ÿå‘½åæ˜¯1,2,3ï¼Œ...10ç›´æ¥æ’å‰ï¼Œå­—å…¸åº

è®¡ç®—æœºï¼šå­¦ä¹ ä¿¡æ¯çš„è¡¨ç¤º

æ“ä½œç³»ç»Ÿï¼šå¦‚ä½•è¡¨ç¤ºæ–‡ä»¶ï¼Œé…ç½®æ–‡ä»¶ï¼Œ

è®¡ç®—æœºç½‘ç»œï¼šå¦‚ä½•åˆç†å°è£…ä¿¡æ¯ï¼Œå¦‚ä½•ä¿è¯ï¼Œåè®®

- 

```cpp
#define BASE 26
#define BASE_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

inline int code(char ch) {
    return ch - BASE_LETTER;
}

void insert(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();
        p = p->next[code(str[i])];
    }
    p->flag = 1;
    return ;
}

int query(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        p = p->next[code(str[i])];
        if (p == NULL) return 0;
    }
    return p->flag;
}

void output(Node *root, int k, char *buff) {
    if (root == NULL) return ;
    if (root->flag) printf("%s\n", buff);
    for (int i = 0; i < BASE; i++) {
        buff[k] = BASE_LETTER + i;
        buff[k + 1] = '\0';
        output(root->next[i], k + 1, buff);
    }
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    char str[1000];
    int n;
    Node *root = getNewNode();
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    output(root, 0, str);
    while (~scanf("%s", str)) {
        printf("query %s, result = %s\n", str, query(root, str) ? "Yes" : "No");
    }
    return 0;
}
```

æŒ‡é’ˆå˜é‡-8å­—èŠ‚(sizeof(int *))



# 6. ==åŒæ•°ç»„å­—å…¸æ ‘==

## 6.1. ä¼ ç»Ÿå­—å…¸æ ‘çš„ç¼ºç‚¹

1. å®Œå…¨äºŒå‰æ ‘ï¼Œå®é™…å­˜å‚¨ç»“æ„æ˜¯è¿ç»­æ•°ç»„ç©ºé—´ï¼Œæ€ç»´é€»è¾‘ç»“æ„æ˜¯æ ‘å‹çš„
2. å®Œå…¨äºŒå‰æ ‘ï¼ŒèŠ‚çœäº†å¤§é‡çš„å­˜å‚¨è¾¹çš„ç©ºé—´
3. ä¼˜åŒ–æ€æƒ³ï¼šè®°å½•å¼ æ”¹ è®¡ç®—å¼
4. $n$ ä¸ªèŠ‚ç‚¹çš„å­—å…¸æ ‘ï¼Œæœ‰æ•ˆä½¿ç”¨ $n-1$ æ¡è¾¹ï¼Œæµªè´¹äº† $(k-1)*n+1$ æ¡è¾¹çš„å­˜å‚¨ç©ºé—´
5. å‚è€ƒå®Œå…¨äºŒå‰æ ‘çš„ä¼˜ç‚¹ï¼Œæå‡ºäº†åŒæ•°ç»„å­—å…¸æ ‘



## 6.2. åŒæ•°ç»„å­—å…¸æ ‘

1. é¡¾åæ€ä¹‰ï¼Œä¸¤ä¸ªæ•°ç»„ä»£è¡¨ä¸€æ£µå­—å…¸æ ‘ç»“æ„
2. base æ•°ç»„ä¿¡æ¯ä¸å­èŠ‚ç‚¹ç¼–å·ç›¸å…³ï¼Œbase + i å°±æ˜¯ç¬¬ i ä¸ªå­èŠ‚ç‚¹ç¼–å·
3. check æ•°ç»„ä¿¡æ¯è´Ÿè´£åšã€äº²å­é‰´å®šã€‘ï¼Œcheck æ•°ç»„ä¸­ç”¨æ­£è´Ÿè¡¨ç¤ºæ˜¯å¦ç‹¬ç«‹æˆè¯
4. ä¸æ“…é•¿è¿›è¡ŒåŠ¨æ€æ’å…¥æ“ä½œ
5. ä¸€æ¬¡å»ºç«‹ï¼Œç»ˆèº«ä½¿ç”¨
6. ä¸ºäº†æ–¹ä¾¿ï¼ŒåŸºäºæ™®é€šå­—å…¸æ ‘å®ç°çš„åŒæ•°ç»„å­—å…¸æ ‘
7. å¢åŠ äº† fail æ•°ç»„ï¼Œå¯ä»¥å®ŒæˆåŸºäºåŒæ•°ç»„å­—å…¸æ ‘çš„ AC è‡ªåŠ¨æœº
8. è¶…å°è§„æ¨¡å®éªŒç»“æœï¼šåŒæ•°ç»„å­—å…¸æ ‘å‹ç¼©æ•ˆç‡æ˜¯ 25 å€
9. éå¸¸æ–¹ä¾¿çš„è¾“å‡ºåˆ°æ–‡ä»¶ä¸­ï¼Œè¿›è¡Œæœºå™¨ä¹‹é—´çš„å…±äº«
10. è¯¾åä½œä¸šï¼šåˆ©ç”¨çœŸå®æ•°æ®é›†ï¼Œæµ‹è¯•åŒæ•°ç»„å­—å…¸æ ‘çš„å‹ç¼©æ•ˆç‡
11. baseå€¼å¯ä»¥ç›¸åŒ,baseçš„å­èŠ‚ç‚¹çš„å€¼æ‰é‡è¦,ä¸å¯ä»¥å†²çª



## 6.3. äºŒå‰å­—å…¸æ ‘

1. è®¡ç®—æœºä¸­æ‰€æœ‰ä¿¡æ¯éƒ½æ˜¯äºŒè¿›åˆ¶å­˜å‚¨çš„
2. ä»»ä½•ä¿¡æ¯éƒ½å¯ä»¥çœ‹æˆä¸€ä¸ªäºŒè¿›åˆ¶ä¸²
3. æ’å…¥äºŒè¿›åˆ¶ä¸²çš„å­—å…¸æ ‘ï¼Œå°±æ˜¯äºŒå‰å­—å…¸æ ‘
4. äºŒå‰å­—å…¸æ ‘å¯ä»¥å­˜å‚¨ä»»æ„ä¿¡æ¯
5. èŠ‚çœç©ºé—´ï¼Œæµªè´¹æ—¶é—´ï¼Œæœ¬è´¨ï¼šæ—¶é—´æ¢ç©ºé—´çš„ç®—æ³•æ€ç»´
6. å“ˆå¼—æ›¼ç¼–ç  + äºŒå‰å­—å…¸æ ‘ å¯èƒ½æ›´é…å“¦ï¼Œæ—¢èŠ‚çœäº†ç©ºé—´ï¼Œåˆåœ¨æœ€å¤§é™åº¦ä¸ŠèŠ‚çœäº†æŸ¥æ‰¾æ—¶é—´



ä¸ç§¯è·¬æ­¥ï¼Œæ— ä»¥è‡³åƒé‡Œã€‚ä¸ç§¯å°æµï¼Œæ— ä»¥æˆæ±Ÿæµ·ã€‚



**å»ºè®®ï¼š**å¤šçœ‹å‡ æœ¬åŸºæœ¬çš„ç®—æ³•ä¹¦ã€ã€æ•°è®ºåŸºç¡€ã€‘ã€å¤šæ¥è§¦ç¦»æ•£å‹æ•°å­¦æ€ç»´



å­—å…¸æ ‘å¶å­èŠ‚ç‚¹æµªè´¹ç©ºé—´è¿‡å¤§

è®°å½•å¼è½¬è®¡ç®—å¼

### 6.3.1. åŒæ•°ç»„å­—å…¸æ ‘

![image-20201017104134948](/Image/A1.Data_Structure-photo/image-20201017104134948.png)


**==ä¿¡æ¯çš„ç­‰ä»·==**

åªæ˜¯ä¿®æ”¹äº†å­—å…¸æ ‘çš„è¡¨ç¤ºæ–¹å¼---è®¡ç®—æœºæœ¬è´¨å°±æ˜¯ä¿¡æ¯çš„è¡¨ç¤º

åŒæ•°ç»„å­—å…¸æ ‘æ˜¯ç¦»æ•£æ„å»ºçš„ï¼Œä¸å¤ªæ”¯æŒåŠ¨æ€æ’å…¥ï¼Œå…¶å®å®ƒæ˜¯å­—å…¸æ–‡ä»¶->å»ºç«‹å¯¹åº”å­—å…¸æ ‘->è½¬ä¸ºç›¸åº”åŒæ•°ç»„å­—å…¸æ ‘

çˆ¶èŠ‚ç‚¹ä¸å­èŠ‚ç‚¹çš„å…³ç³»çš„è®¡ç®—å¼è¡¨ç¤ºï¼š

- base[]ï¼šè®¡ç®—çˆ¶å­èŠ‚ç‚¹çš„è¾¹çš„ä¸­é—´é‡

  â€‹	fatherçš„ç¬¬iä¸ªå­©å­(iæ˜¯å­—ç¬¦ç¼–ç ) ï¼š child_i = base[father] + i;

- check[]ï¼šè®°å½•æ¯ä¸ªå­èŠ‚ç‚¹çš„çœŸæ­£çˆ¶èŠ‚ç‚¹, ä»¥åŠæ˜¯å¦ç‹¬ç«‹æˆè¯(æ­£è´Ÿ)

  â€‹	check[child_i] = father;

  â€‹	check[child_i] = -father; è´Ÿæ•°é¢å¤–ä»£è¡¨ç‹¬ç«‹æˆè¯

  â€‹	ä¸å¯è®°å½•0å·ï¼Œä»1å·å¼€å§‹ï¼›ç›¸åº”èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸å¯ä¸º0å·

  â€‹	åˆå§‹check[]ä¸º0ï¼Œä»£è¡¨æœªå ç”¨ï¼Œä¸€æ—¦è®°å½•ä¸€å®šé0ï¼›

- base[child_i] = 

è®°å½•æ›´å¤šçš„ä¿¡æ¯ï¼Œå¯é€šè¿‡å°è£…ç»“æ„ä½“ï¼Œå¤šä¸ªæ•°ç»„

### 6.3.2. äºŒå‰å­—å…¸æ ‘+å“ˆå¤«æ›¼ç¼–ç 

ç¼–ç ï¼šæ ¹æ®é—®é¢˜åœºæ™¯æ¥ç­‰ä»·ä¿¡æ¯è¡¨ç¤ºã€‚

å“ˆå¤«æ›¼ç¼–ç ï¼šå°†ä¿¡æ¯è¡¨ç¤ºä¸ºæœ€çŸ­

å›ç­”ï¼š

- å“ˆå¤«æ›¼ç¼–ç ç®—å‡ºï¼šéœ€è¦çš„ä¿¡æ¯ï¼Œç»Ÿè®¡é—®é¢˜åœºæ™¯ä¸‹çš„æ¦‚ç‡ï¼›

- å¯¹ä¸­æ–‡å­—ç¬¦é›†ç¼–ç ï¼šä¸€ä¸ªä¸­æ–‡å è‹¥å¹²ç¼–ç ï¼Œå¯¹æ¯ä¸ªå­—èŠ‚ç¼–ç 

### 6.3.3. åŸºäºå­—å…¸æ ‘çš„ AC è‡ªåŠ¨æœº

```cpp
/*************************************************************************
   > File Name: 12.double_array_trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: ä¸‰  8/21 14:14:38 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DATrie {
    int *base, *check;
    int root, size;
} DATrie;

DATrie *getDATrie(int n) {
    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);
    tree->root = 1;
    tree->size = n;
    tree->base = (int *)calloc(sizeof(int), n);
    tree->check = (int *)calloc(sizeof(int), n);
    tree->check[tree->root] = 1;
    return tree;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int getBaseValue(Node *root, DATrie *tree) {
    int base = 0, flag;
    do {
        flag = 1;
        base += 1;
        for (int i = 0; i < BASE; i++) {
            if (root->next[i] == NULL) continue;
            if (tree->check[base + i] == 0) continue;
            flag = 0;
            break;
        }
    } while (!flag);
    return base;
}

int buildDATrie(int ind, Node *root, DATrie *tree) {
    int base = tree->base[ind] = getBaseValue(root, tree);
    int ans = ind;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree->check[base + i] = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        int temp = buildDATrie(base + i, root->next[i], tree);
        if (temp > ans) ans = temp;
    }
    if (root->flag) tree->check[ind] = -tree->check[ind];
    return ans;
}

int query(DATrie *tree, const char *str) {
    int p = tree->root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;
        p = tree->base[p] + ind;
    }
    return tree->check[p] < 0;
}

void clearDA(DATrie *tree) {
    if (tree == NULL) return ;
    free(tree->base);
    free(tree->check);
    free(tree);
    return ;
}

int main() {
    int n, cnt1 = 1, cnt2;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    while (n--) {
        scanf("%s", str);
        cnt1 += insert(root, str);
    }
    DATrie *tree = getDATrie(cnt1 * BASE + 5);
    cnt2 = buildDATrie(tree->root, root, tree) + 1;
    while (~scanf("%s", str)) {
        printf("search %s, result = %s\n", str, query(tree, str) ? "YES" : "NO");
    }
    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;
    printf("Trie memory : %d Bytes\n", mem1);
    printf("Double Array Trie memory : %d Bytes\n", mem2);
    printf("memory rate : %.4lf%%\n", 1.0 * mem2 / mem1 * 100);
    clearDA(tree);
    clear(root);
    return 0;
}
```

### 6.3.4. åŸºäºåŒæ•°ç»„å­—å…¸æ ‘çš„ AC è‡ªåŠ¨æœº

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BASE 26
#define BEGIN_LETTER 'a'
#define max(a, b) ((a) > (b) ? (a) : (b))
#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)

typedef struct DANode {
    int base, check, fail;
    char *str;
} DANode;

typedef struct Node {
    int flag;
    char *str;
    struct Node *next[BASE];
} Node, *Trie;

int node_cnt = 0;

Node *get_new_node() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    node_cnt += 1;
    return p;
}

void clear(Trie root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    if (root->flag) free(root->str);
    free(root);
    return ;
}

Node *insert(Trie root, const char *str) {
    if (root == NULL) root = get_new_node();
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = get_new_node();
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return root;
}

int get_base(Node *node, DANode *data) {
    int base = 2, flag = 0;
    while (!flag) {
        flag = 1;
        for (int i = 0; i < BASE; i++) {
            if (node->next[i] == NULL) continue;
            if (data[base + i].check == 0) continue;
            flag = 0;
            break;
        }
        base += (!flag);
    }
    return base;
}

int build(Node *node, DANode *data, int ind) {
    if (node == NULL) return 0;
    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;
    int max_ind = ind;
    data[ind].base = get_base(node, data);
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        data[data[ind].base + i].check = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        int temp = build(node->next[i], data, data[ind].base + i);
        max_ind = max(max_ind, temp);
    }
    return max_ind;
}

void build_ac(DANode *data) {
    #define MAX_N 100000
    int *queue = (int *)malloc(sizeof(int) * MAX_N);
    int head = 0, tail = 0;
    data[1].fail = 0;
    queue[tail++] = 1;
    while (head < tail) {
        int ind = queue[head++];
        for (int i = 0; i < BASE; i++) {
            if (!has_child(data, ind, i)) continue;
            int p = data[ind].fail;
            while (p && !has_child(data, p, i)) p = data[p].fail;
            if (p == 0) p = 1;
            else p = data[p].base + i;
            data[data[ind].base + i].fail = p;
            queue[tail++] = data[ind].base + i;
        }
    }
    return ;
    #undef MAX_N
}

void search_ac(DANode *data, const char *str) {
    int p = 1;
    for (int i = 0; str[i]; i++) {
        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;
        if (p == 0) p = 1;
        else p = data[p].base + str[i] - BEGIN_LETTER;
        int q = p;
        while (q) {
            if (data[q].check < 0) printf("find string : %s\n", data[q].str);
            q = data[q].fail;
        }
    }
    return ;  
}

void output_da(DANode *data, int n) {
    for (int i = 1; i <= n; i++) {
        if (i - 1 && i % 5 == 1) printf("\n");
        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);
    }
    printf("\n");
    return ;
}

int main() {
    Trie root = NULL;
    #define INSERT_CNT 5
    root = insert(root, "hai");
    root = insert(root, "zei");
    root = insert(root, "ha");
    root = insert(root, "ab");
    root = insert(root, "ehz");
    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));
    int da_cnt = build(root, data, 1);
    build_ac(data);
    output_da(data, da_cnt);
    search_ac(data, "sasherhs");
    #undef INSERT_CNT 
    return 0;
}
```



### 6.3.5. kaikeiba

```cpp
/*************************************************************************
	> File Name: 1.double_array_trie.cpp
	> Author: huguang
	> Mail: hug@haizeix.com
	> Created Time: 
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;

#define BASE 26
#define MSG_LEVEL 2
#define DEBUG_LEVEL 1
#define INFO_LEVEL 2

#define LOG(level, frm, args...) { \
    if (level >= MSG_LEVEL) { \
        printf(frm,##args); \
    } \
}

#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args)
#define LOG_INFO(args...) LOG(INFO_LEVEL, args)

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DANode {
    int base, check, fail;
} DANode;

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {
            cnt += 1;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear_trie(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;
    int base = get_base_value(root, tree, ind);
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {
        int a = transform_double_array_trie(root->next[i], tree, base + i);
        if (a > max_ind) max_ind = a;
    }
    return max_ind;
}

void dump_double_array_trie(DANode *tree, int n) {
    LOG_INFO("%d\n", n);
    for (int i = 0; i <= n; i++) {
        LOG_INFO("%d %d %d\n", tree[i].base, tree[i].check, tree[i].fail);
    }
    return ;
}

void build_ac_base_double_array_trie(DANode *tree, int max_ind) {
    int *que = (int *)malloc(sizeof(int) * (max_ind + 5));
    int head, tail;
    head = tail = 0;
    tree[1].fail = 0;
    for (int i = 0; i < BASE; i++) {
        int child_ind = tree[1].base + i;
        if (abs(tree[child_ind].check) != 1) continue;
        tree[child_ind].fail = 1;
        que[tail++] = child_ind;
    }
    while (head < tail) {
        int p = que[head++];
        for (int i = 0; i < BASE; i++) {
            int c = tree[p].base + i, k = tree[p].fail;
            if (abs(tree[c].check) != p) continue;
            while (k && abs(tree[tree[k].base + i].check) != k) k = tree[k].fail;
            if (k == 0) k = 1;
            if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;
            tree[c].fail = k;
            que[tail++] = c;
        }
    }
    free(que);
    return ;
}

int main() {
    int n, cnt = 1;
    char str[1000];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    LOG_DEBUG("trie(%lu Byte), double array trie(%lu Byte)\n", s1, s2);
    LOG_DEBUG("rate : %.2lf\n", 1.0 * s2 / s1);
    for (int i = 0; i <= max_ind; i++) {
        LOG_DEBUG("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1) % 5 == 0) LOG_DEBUG("\n");
    }
    LOG_DEBUG("\n");
    build_ac_base_double_array_trie(tree, max_ind);
    dump_double_array_trie(tree, max_ind);
    free(tree);
    clear_trie(root);
    return 0;
}
```





### 6.3.6. AC è‡ªåŠ¨æœºçš„é€’å½’å»ºç«‹

## 6.4.  

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode* fail, *father;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->fail = NULL;
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
            p->childs[buffer[i] - BASE]->father = p;
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    #define next childs
    #define Node TrieNode
    if (node == NULL) return ;
    if (node->fail == NULL) build_automaton(node->father);
    for (int i = 0; i < SIZE; i++) {
        if (node->next[i] == NULL) continue;
        if (node->next[i]->fail) continue;
        Node *p = node->fail, *pre_p = node;
        while (p && p->next[i] == NULL) {
            if (p->fail == NULL) build_automaton(p->father);
            pre_p = p;
            p = p->fail;
        }
        if (p == NULL) p = pre_p;
        else p = p->next[i];
        node->next[i]->fail = p;
        build_automaton(node->next[i]);
    }
    return ;
    #undef next
    #undef Node
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        while (p && p->childs[str[0] - 'a'] == NULL) p = p->fail;
        if (p == NULL) p = ac_tree;
        else p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        str++;
    }
    return ret;
}

int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```

### 6.4.1. AC è‡ªåŠ¨æœºçš„çº¿ç´¢åŒ–

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode *fail;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));
    int head = 0, tail = 0;
    queue[tail++] = node;
    while (head < tail) {
        TrieNode *now = queue[head++];
        for (int i = 0; i < SIZE; i++) {
            if (now->childs[i] == NULL) {
                if (now != node) now->childs[i] = now->fail->childs[i];
                continue;
            }
            TrieNode *p = (now->fail ? now->fail->childs[i] : node);
            if (p == NULL) p = node;
            now->childs[i]->fail = p;
            queue[tail++] = now->childs[i];
        }
    }
    free(queue);
    return ;
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        if (p == NULL) p = ac_tree;
        str++;
    }
    return ret;
}
int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    printf("insert done\n");
    fflush(stdout);
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```



# 7. ==å¤šæ¨¡åŒ¹é…é—®é¢˜==

1. æœ‰å¤šä¸ªæ¨¡å¼ä¸²çš„åŒ¹é…é—®é¢˜ï¼Œå°±æ˜¯å¤šæ¨¡åŒ¹é…é—®é¢˜
2. Step1ï¼šå¤šä¸ªæ¨¡å¼ä¸²ï¼Œå»ºç«‹æˆä¸€æ£µå­—å…¸æ ‘
3. Step2ï¼šå’Œæ–‡æœ¬ä¸²çš„æ¯ä¸€ä½å¯¹é½åŒ¹é…ï¼Œæ¨¡æ‹Ÿæš´åŠ›åŒ¹é…ç®—æ³•çš„è¿‡ç¨‹



## 7.1. AC è‡ªåŠ¨æœºçš„æ€æƒ³

1. å½“åŒ¹é…æˆåŠŸæ–‡æœ¬ä¸²ä¸­çš„ she æ—¶ï¼Œä¹Ÿå°±æ„å‘³ç€åç»­ä¸€å®šä¼šåŒ¹é…æˆåŠŸ he
2. she å¯¹åº”äº†å­—å…¸æ ‘ä¸­çš„èŠ‚ç‚¹ Pï¼Œhe å¯¹åº”äº†å­—å…¸æ ‘ä¸­çš„èŠ‚ç‚¹Q
3. P å’Œ Q å°±æ˜¯ç­‰ä»·åŒ¹é…èŠ‚ç‚¹ï¼Œå¦‚æœä» P å¼•å‡ºä¸€æ¡è¾¹æŒ‡å‘ Qï¼Œå°±å¯ä»¥åŠ é€ŸåŒ¹é…è¿‡ç¨‹
4. åœ¨ P ä¸‹é¢æŸ¥æ‰¾èŠ‚ç‚¹çš„æ“ä½œï¼Œç­‰ä»·äºåœ¨ Q ä¸‹é¢æŸ¥æ‰¾èŠ‚ç‚¹çš„æ“ä½œ
5. è¿™æ¡ç­‰ä»·å…³ç³»è¾¹ï¼Œé€šå¸¸åœ¨ AC è‡ªåŠ¨æœºä¸Šå«åš ã€Fail æŒ‡é’ˆã€‘ç­‰ä»·åŒ¹é…æŒ‡é’ˆ
6. AC è‡ªåŠ¨æœº = Trie + Fail æŒ‡é’ˆ
7. å­èŠ‚ç‚¹çš„ Fail æŒ‡é’ˆæ˜¯éœ€è¦å‚ç…§çˆ¶èŠ‚ç‚¹çš„ FailæŒ‡é’ˆä¿¡æ¯çš„ï¼Œæœ€ç®€å•çš„å»ºç«‹æ–¹å¼ï¼Œå°±æ˜¯é‡‡ç”¨ã€å±‚åºéå†ã€‘
8. æ²¡åšä¼˜åŒ–çš„ AC è‡ªåŠ¨æœºï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª NFAï¼ˆéç¡®å®šå‹æœ‰ç©·çŠ¶æ€è‡ªåŠ¨æœºï¼‰
9. é€šä¿—ç†è§£ï¼šæ ¹æ®å½“å‰çŠ¶æ€ pï¼Œä»¥åŠè¾“å…¥å­—ç¬¦ cï¼Œæ— æ³•é€šè¿‡ä¸€æ­¥æ“ä½œç¡®å®šçŠ¶æ€
10. ç¬¬äºŒç§ç†è§£ï¼šå½“å‰çŠ¶æ€ï¼Œå¹¶ä¸ä»£è¡¨å”¯ä¸€çŠ¶æ€ã€‚

**AC è‡ªåŠ¨æœºä¼˜åŒ–ï¼š**ä½¿ç”¨è·¯å¾„å‹ç¼©æ€æƒ³ï¼Œä½¿çŠ¶æ€è½¬ç§»æ—¶å¯ä»¥ä¸€æ­¥è·³è½¬åˆ°ç›®æ ‡çŠ¶æ€ã€‚

ä¼˜åŒ–ä»¥åçš„ AC è‡ªåŠ¨æœºï¼Œæ›´åƒ DFAï¼ˆç¡®å®šæ€§æœ‰ç©·çŠ¶æ€è‡ªåŠ¨æœºï¼‰ã€‚

![image-20210127193634993](/Image/A1.Data_Structure-photo/image-20210127193634993.png)

![image-20210127193826398](/Image/A1.Data_Structure-photo/image-20210127193826398.png)

![image-20210217201415813](/Image/A1.Data_Structure-photo/image-20210217201415813.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE], *fail;
} Node;

typedef struct Queue {
    Node **data;
    int head, tail, size;
} Queue;

Queue *init_queue(int n) {
    Queue *q = (Queue *)calloc(sizeof(Queue), 1);
    q->data = (Node **)malloc(sizeof(Node *) * n);
    q->tail = q->head = 0;
    return q;
}

Node *front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->head == q->tail;
}

void push(Queue *q, Node *node) {
    q->data[q->tail++] = node;
    return ;
}

void pop(Queue *q) {
    if (empty(q)) return ;
    q->head++;
}

void clear_queue(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *node) {
    if (node == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(node->next[i]);
    }
    free(node);
    return ;
}

void build_ac(Node *root, int n) {
    Queue *q = init_queue(n + 10);
    root->fail = NULL;
    push(q, root);
    while (!empty(q)) {
        Node *now_node = front(q);
        pop(q);
        for (int i = 0; i < BASE; i++) {
            if (now_node->next[i] == NULL) continue;
            Node *p = now_node->fail;
            while (p && p->next[i] == NULL) p = p->fail;
            if (p == NULL) now_node->next[i]->fail = root;
            else now_node->next[i]->fail = p->next[i];
            push(q, now_node->next[i]);
        }
    }
    return ;
}

int match(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        while (p && p->next[ind] == NULL) p = p->fail;
        if (p == NULL) p = root;
        else p = p->next[ind];
        Node *q = p;
        while (q) cnt += q->flag, q = q->fail;
    }
    return cnt;
}

int main() {
    Node *root = getNewNode();
    int n, cnt = 0;
    char str[1000];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    // build ac
    build_ac(root, cnt);
    scanf("%s", str);
    // match ac
    printf("match word cnt : %d\n", match(root, str));
    return 0;
}
```



## 7.2. é¢„ä¹ èµ„æ–™ï¼šã€æ•°æ®ç»“æ„ã€‘> å­—ç¬¦ä¸²ç»Ÿè®¡

1. AC è‡ªåŠ¨æœºè£¸é¢˜

2. è§£é¢˜çš„å…³é”®ï¼Œåœ¨äºå¦‚ä½•ç»´æŠ¤æ¯ä¸€ä¸ªå•è¯çš„è®¡æ•°é‡

3. ä½¿ç”¨å¹¼å„¿å›­å¿…çŸ¥å¿…ä¼šçš„æŒ‡é’ˆæŠ€å·§ç»´æŠ¤çš„

4. **èˆ¹é•¿ç¿»è½¦ï¼š**é¢˜ç›®æ•°æ®ä¸­ç»™å‡ºçš„å•è¯ä¼šæœ‰é‡å¤

   



### 7.2.1. å­˜å‚¨ä»»æ„ç±»å‹çš„æ ˆ

```cpp
/*************************************************************************
   > File Name: 15.any_stack.h
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: ä¸‰  2/28 10:49:10 2018
 ************************************************************************/

#ifndef _15_ANY_STACK_H
#define _15_ANY_STACK_H

#include <stdlib.h>
#include <string.h>

#define STACK_OK 1
#define STACK_ERROR 0

typedef struct Stack {
    char *data;
    int data_size;
    int size, top;
} Stack;

#define init_stack(n, T) (__init_stack(n, sizeof(T)))
#define push_stack(s, data) (__push_stack(s, (char *)(data)))
#define top_stack(s, T) ((T *)(__top_stack(s)))

Stack *__init_stack(int n, int data_size) {
    Stack *s = (Stack *)malloc(sizeof(Stack) * 1);
    s->data = (char *)malloc(n * data_size);
    s->data_size = data_size;
    s->size = n;
    s->top = -1;
    return s;
}

int __push_stack(Stack *s, char *data) {
    if (s->size - 1 == s->top) {
        return STACK_ERROR;
    }
    s->top += 1;
    memcpy(s->data + s->top * s->data_size, data, s->data_size);
    return STACK_OK;
}

int empty_stack(Stack *s) {
    return s->top == -1;
}

char *__top_stack(Stack *s) {
    if (empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->data_size;
}

int pop_stack(Stack *s) {
    if (empty_stack(s)) {
        return STACK_ERROR;
    }
    s->top -= 1;
    return STACK_OK;
}

void clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}

#endif
```

### 7.2.2. äºŒå‰æ ‘å‰åºéå†ï¼ˆéé€’å½’ï¼‰

```cpp
/*************************************************************************
   > File Name: 14.binary_non_recursive.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: ä¸‰  2/28 10:26:37 2018
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "15.any_stack.h"

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int data) {
    Node *p = (Node *)malloc(sizeof(Node) * 1);
    p->data = data;
    p->lchild = p->rchild=  NULL;
    return p;
}

Node *init_binary_tree() {
    Node *root = getNewNode(1);
    root->lchild = getNewNode(3);
    root->rchild = getNewNode(6);
    root->lchild->rchild = getNewNode(9);
    root->rchild->rchild = getNewNode(11);
    root->rchild->lchild = getNewNode(14);
    root->lchild->rchild->lchild = getNewNode(17);
    return root;
}

void __pre_order(Node *root) {
    // status = 0
    if (root == NULL) return ; // status = 100
    printf("%d\n", root->data); // status = 1
    __pre_order(root->lchild); // status = 2
    __pre_order(root->rchild); // status = 3
    return ; // status = 100
}

typedef struct PreOrderArgs {
    Node *root;
    int status;
} PreOrderArgs;

PreOrderArgs *getNewArgs(Node *root) {
    PreOrderArgs *p = (PreOrderArgs *)malloc(sizeof(PreOrderArgs) * 1);
    p->root = root;
    p->status = 0;
    return p;
}

void pre_order(Node *root) {
    Stack *s = init_stack(100, PreOrderArgs);
    PreOrderArgs *temp_args = getNewArgs(root), *p_args;
    push_stack(s, temp_args);
    while (!empty_stack(s)) {
        p_args = top_stack(s, PreOrderArgs);
        switch (p_args->status) {
            case 0: {
                if (p_args->root == NULL) {
                    p_args->status = 100;
                } else {
                    p_args->status = 1;
                }
            } break;
            case 1: {
                printf("%d\n", p_args->root->data);
                p_args->status = 2;
            } break;
            case 2: {
                temp_args->root = p_args->root->lchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 3;
            } break;
            case 3: {
                temp_args->root = p_args->root->rchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 100;
            } break;
            case 100: {
                pop_stack(s);
            } break;
        }
    }
    free(temp_args);
    clear_stack(s);
    return ;
}



int main() {
    Node *root = init_binary_tree();
    pre_order(root);
    __pre_order(root);
    return 0;
}
```

### 7.2.3. å¿«é€Ÿæ’åºï¼ˆéé€’å½’ï¼‰



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MC(T, n) ((T *)malloc(sizeof(T) * n))

#define init_stack(s, n, T) (__init_stack(s, n, sizeof(T)))
#define push_stack(s, value) ({ \
    __typeof(value) __temp = (value); \
    __push_stack(s, (const char *)(&(__temp))); \
})

#define empty_stack(s) (__empty_stack(s))
#define pop_stack(s) (__pop_stack(s))
#define top_stack(s, T) (*((T *)__top_stack(s)))
#define clear_stack(s) (__clear_stack(s))
#define swap(a, b) { \
    __typeof(a) __temp = (a); \
    (a) = (b); (b) = (__temp); \
}
#define ERROR 0
#define OK 1

typedef struct Stack {
    char *data;
    int top, size;
    int value_size;
} Stack;

void __init_stack(Stack *s, int n, int value_size);
int __push_stack(Stack *s, const char *value);
int __empty_stack(Stack *s);
int __pop_stack(Stack *s);
char *__top_stack(Stack *s);
void __clear_stack(Stack *s);

typedef struct Node {
    int val;
    struct Node *lchild, *rchild;
} Node;

Node *init(int val) {
    Node *p = MC(Node, 1);
    p->val = val;
    p->lchild = p->rchild = NULL;
    return p;
}

typedef struct QuickSortArgs {
    int *arr;
    int l, r;
    int x;
    int status;
} QuickSortArgs;

int __quick_sort(int *arr, int l, int r) {
    // 0 : if (r <= l) return ;
    int x, y, z;
    x = l, y = r, z = arr[l];
    while (x < y) {
        while (x < y && arr[y] >= z) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] <= z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    return x;
    // 2: quick_sort(arr, l, x - 1);
    // 3 : quick_sort(arr, x + 1, r);
    // 4 : return ;
}

void init_quick_sort_args(QuickSortArgs *qsa, int *arr, int l, int r, int status) {
    qsa->arr = arr;
    qsa->l = l;
    qsa->r = r;
    qsa->status = 0;
    return ;
}

void quick_sort(int *arr, int n) {
    Stack *s = MC(Stack, 1);
    init_stack(s, 1000, QuickSortArgs);
    QuickSortArgs qsa;
    init_quick_sort_args(&qsa, arr, 0, n - 1, 0);
    push_stack(s, qsa);
    while (!empty_stack(s)) {
        QuickSortArgs *tqsa = &top_stack(s, QuickSortArgs);
        switch (tqsa->status) {
            case 0:
                if (tqsa->r <= tqsa->l) {
                    tqsa->status = 4;
                } else {
                    tqsa->status = 1;
                }
                break;
            case 1:
                tqsa->x = __quick_sort(tqsa->arr, tqsa->l, tqsa->r);
                tqsa->status = 2;
                break;
            case 2:
                init_quick_sort_args(&qsa, arr, tqsa->l, tqsa->x - 1, 0);
                push_stack(s, qsa);
                tqsa->status = 3;
                break;
            case 3:
                init_quick_sort_args(&qsa, arr, tqsa->x + 1, tqsa->r, 0);
                push_stack(s, qsa);
                tqsa->status = 4;
                break;
            case 4:
                pop_stack(s);
                break;
            default:
                printf("ERROR\n");
                break;
        }
    }
    return ;
}

int main() {
    int arr[10] = {9, 7, 5, 4, 2 ,1 ,3, 10, 6, 8};
    quick_sort(arr, 10);
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
void __init_stack(Stack *s, int n, int value_size) {
    s->data = (char *)malloc(value_size * n);
    s->top = -1;
    s->size = n;
    s->value_size = value_size;
    return ;
}

int __push_stack(Stack *s, const char *value) {
    if (s->top == s->size - 1) {
        return ERROR;
    }
    ++(s->top);
    memcpy(s->data + s->top * s->value_size, value, s->value_size);
    return OK;
}

int __empty_stack(Stack *s) {
    return s->top == -1;
}

int __pop_stack(Stack *s) {
    if (__empty_stack(s)) {
        return ERROR;
    }
    --(s->top);
    return OK;
}

char *__top_stack(Stack *s) {
    if (__empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->value_size;
}

void __clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}
```



# 8. ==å¹¶æŸ¥é›†==



æ ¹èŠ‚ç‚¹ï¼šå…¨é›†

å­èŠ‚ç‚¹ï¼šå­é›†

![image-20201018110356663](/Image/A1.Data_Structure-photo/image-20201018110356663.png)

æŒ‰å°ºå¯¸(æ­£è§„è¯´æ³•å«åšç§©)è¿›è¡Œå¹³è¡¡ï¼ŒæŒ‰ç§©ä¼˜åŒ–

![image-20201018110407696](/Image/A1.Data_Structure-photo/image-20201018110407696.png)

è¾…ä»¥è·¯å¾„å‹ç¼©åï¼Œæ ‘ç»“æ„ä¼šé«˜åº¦æ‰å¹³åŒ–ã€‚

![image-20201018110431340](/Image/A1.Data_Structure-photo/image-20201018110431340.png)

![image-20201018110438419](/Image/A1.Data_Structure-photo/image-20201018110438419.png)



ç¦»æ•£åŒ–--é‡æ˜ å°„(map)



æ ¹èŠ‚ç‚¹æœ‰ç‰¹æ®Šæ„ä¹‰çš„å¹¶æŸ¥é›†ï¼Œå¸¦æƒå¹¶æŸ¥é›†

ç”¨å¹¶æŸ¥é›†å»ç»´æŠ¤ç¼–å·ï¼Œä¸€ä¸ªæ”¾åœ¨å¦ä¸€ä¸ªå»ºç«‹å…³ç³»http://oj.haizeix.com/problem/324

ç”¨å¹¶æŸ¥é›†å»ç»´æŠ¤æœ€è¿‘çš„ä¸€ä¸ªç©ºä½ç½®ï¼Œhttp://oj.haizeix.com/problem/323

### 8.0.4. quick-union

```cpp
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    //if (u->size[fa] < u->size[fb]) swap(fa, fb);
    u->father[fb] = fa;
    //u->size[fa] += u->size[fb];
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->father);
    free(u->size);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No"); break;
        }
    }
    clear(u);
    return 0;
}

```

### 8.0.5. HZOJ-72-çŒœæ‹³.cpp

![image-20201022132834261](/Image/A1.Data_Structure-photo/image-20201022132834261.png)

0:xä¸yå¹³æ‰‹

1:xè¾“ç»™y

2:xèµ¢y



```cpp
/*************************************************************************
   > File Name: 72.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: ä¸‰  8/21 20:47:24 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 10000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; i++) fa[i] = i; 
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 3;
        return fa[x] = root;
    }
    void merge(int a, int b, int c) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        val[aa] = (c + val[b] - val[a] + 3) % 3;
        return ;
    }
};

UnionSet u;

void read(int &n, int &m) {
    cin >> n >> m;
    u.init(n);
    return ;
}

int main() {
    int n, m;
    read(n, m);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            u.merge(b, c, 2);
        } else {
            if (u.get(b) != u.get(c)) {
                cout << "Unknown" << endl;
            } else {
                switch ((u.val[b] - u.val[c] + 3) % 3) {
                    case 0: cout << "Tie" << endl; break;
                    case 1: cout << "Loss" << endl; break;
                    case 2: cout << "Win" << endl; break;
                }
            }
        }
    }
    return 0;
}
```

### 8.0.6. HZOJ-73-æ¹–æ³Š.cpp

```cpp
 
/*************************************************************************
   > File Name: 73.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å››  8/22 14:19:28 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 1000
#define MAX_M 1000000
#define ind(i, j) ((i) * (m) + (j) + 1)
char g[MAX_N + 5][MAX_N + 5];

struct UnionSet {
    int fa[MAX_M + 5];
    void init(int n) {
        for (int i = 0; i <= n; i++) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

UnionSet u;

int main() {
    int n, m;
    cin >> n >> m;
    u.init(n * m);
    for (int i = 0; i < n; i++) {
        cin >> g[i];
        for (int j = 0; j < m; j++) {
            if (g[i][j] == 'X') continue;
            if (i && g[i - 1][j] == 'O') u.merge(ind(i, j), ind(i - 1, j));
            if (j && g[i][j - 1] == 'O') u.merge(ind(i, j), ind(i, j - 1));
            if (i == 0 || i == n - 1) u.merge(ind(i, j), 0);
            if (j == 0 || j == m - 1) u.merge(ind(i, j), 0);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (g[i][j] == 'X') continue;
            if (u.get(ind(i, j)) - u.get(0)) ans += 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 8.0.7. ç¨‹åºè‡ªåŠ¨åˆ†æ

ç¦»æ•£åšæ³•ï¼šæ ¹æ®ç›¸ç­‰å»ºç«‹å¹¶æŸ¥é›†ï¼Œåˆ¤æ–­ä¸ç­‰

```
#define MAX_N 1000000
struct UnionSet {
    int fa[(MAX_N << 1) + 5];
    void init(int n) {
        while (n--) fa[n + 1] = n + 1;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

UnionSet u;

struct Data {
    int e, i, j;
} arr[MAX_N + 5];

void solve() {
    map<int, int> ind;
    int cnt = 0;
    int n;
    cin >> n;
    u.init(2 * n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i].i >> arr[i].j >> arr[i].e;
        if (ind.find(arr[i].i) == ind.end()) ind[arr[i].i] = (++cnt);
        if (ind.find(arr[i].j) == ind.end()) ind[arr[i].j] = (++cnt);
        arr[i].i = ind[arr[i].i];
        arr[i].j = ind[arr[i].j];
    }
    for (int i = 0; i < n; i++) {
        if (arr[i].e == 0) continue;
        u.merge(arr[i].i, arr[i].j);
    }
    int flag = 1;
    for (int i = 0; i < n && flag; i++) {
        if (arr[i].e == 1) continue;
        flag = (u.get(arr[i].i) != u.get(arr[i].j));
    }
    cout << (flag ? "YES" : "NO") << endl;
    return ;
}

int main() {
    int tcase;
    cin >> tcase;
    while (tcase--) solve();
    return 0;
}
```

### 8.0.8. Supermarket

>  è¶…å¸‚é‡Œæœ‰NNä¸ªå•†å“. ç¬¬iiä¸ªå•†å“å¿…é¡»åœ¨ä¿è´¨æœŸ(ç¬¬didiå¤©)ä¹‹å‰å–æ‰, è‹¥å–æ‰å¯è®©è¶…å¸‚è·å¾—pipiçš„åˆ©æ¶¦.æ¯å¤©åªèƒ½å–ä¸€ä¸ªå•†å“.ç°åœ¨ä½ è¦è®©è¶…å¸‚è·å¾—æœ€å¤§çš„åˆ©æ¶¦.

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 10000

struct Data {
    int p, d;
} arr[MAX_N + 5];
 
struct UnionSet {
    int fa[MAX_N + 5];
    void init(int n) {
        for (int i = 0; i <= n; ++i) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    //æ ¹èŠ‚ç‚¹ä»£è¡¨å½“å‰èŠ‚ç‚¹å‰é¢ç¬¬ä¸€ä¸ªç©ºä½ç½®
    //å‰é¢åšå„¿å­
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

bool cmp(const Data &a, const Data &b) {
    return a.p > b.p;
}

UnionSet u;

int solve(int n) {
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].p >> arr[i].d;
    }
    sort(arr, arr + n, cmp);
    u.init(MAX_N);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (u.get(arr[i].d) == 0) continue;
        ans += arr[i].p;
        int day = u.get(arr[i].d);
        //è®©dayä½œä¸ºday-1çš„å­é›†ï¼Œdayè¢«å ç”¨
        u.merge(day, day - 1);
    }
    cout << ans << endl;
    return 0;
}

int main() {
    int n;
    while (cin >> n) solve(n);
    return 0;
}

```







### 8.0.9. é“¶æ²³è‹±é›„ä¼ è¯´

>  æœ‰ä¸€ä¸ªåˆ’åˆ†æˆNNåˆ—çš„æ˜Ÿé™…æˆ˜åœºï¼Œå„åˆ—ä¾æ¬¡ç¼–å·ä¸º1,2,â€¦,N1,2,â€¦,Nã€‚æœ‰NNè‰˜æˆ˜èˆ°ï¼Œä¹Ÿä¾æ¬¡ç¼–å·ä¸º1,2,â€¦,N1,2,â€¦,N, å…¶ä¸­ç¬¬iiå·æˆ˜èˆ°å¤„äºç¬¬iiåˆ—ã€‚
>
>  æœ‰Mæ¡æŒ‡ä»¤ï¼Œæ¯æ¡æŒ‡ä»¤æ ¼å¼ä¸ºä»¥ä¸‹ä¸¤ç§ä¹‹ä¸€ï¼š
>
>  M i jï¼Œè¡¨ç¤ºç¬¬iiå·æˆ˜èˆ°æ‰€åœ¨åˆ—çš„å…¨éƒ¨æˆ˜èˆ°ä¿æŒåŸæœ‰é¡ºåºï¼Œæ¥åœ¨ç¬¬jjå·æˆ˜èˆ°æ‰€åœ¨åˆ—çš„å°¾éƒ¨ã€‚
>
>  C i jï¼Œè¡¨ç¤ºè¯¢é—®ç¬¬iiå·æˆ˜èˆ°ä¸ç¬¬jjå·æˆ˜èˆ°å½“å‰æ˜¯å¦å¤„äºåŒä¸€åˆ—ä¸­ï¼Œå¦‚æœåœ¨åŒåˆ—ä¸­ï¼Œä»–ä»¬ä¹‹é—´é—´éš”äº†å¤šå°‘è‰˜æˆ˜èˆ°ã€‚

```cpp
/*************************************************************************
	> File Name: oj-324.cpp
	> Author: wei 
	> Mail: 1931248856@qq.com
	> Created Time: 2020å¹´10æœˆ21æ—¥ æ˜ŸæœŸä¸‰ 17æ—¶53åˆ†12ç§’
 ************************************************************************/

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 500000

struct Unionset {
    int fa[MAX_N + 5], size[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; ++i) {
            fa[i] = i;
            size[i] = 1;
            val[i] = 0;
        }
        return ;
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        return fa[x] = root;
    }
    void merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        val[aa] = size[bb];
        size[bb] += size[aa];
        return ;
    }
};

Unionset u;

int main() {
    int n;
    scanf("%d", &n);
    u.init(n);
    char str[10];
    for (int i = 0; i < n; ++i) {
        int a, b;
        scanf("%s%d%d", str, &a, &b);
        switch (str[0]) {
            case 'M' : u.merge(a, b); break;
            case 'C' : {
                if (u.get(a) != u.get(b)) {
                    printf("-1\n");
                } else {
                    printf("%d\n", abs(u.val[a] - u.val[b]) - 1);
                }
            } break;
        }
    }

    return 0;
}

```

### 8.0.10. HZOJ-325-ä»£ç æ¼”ç¤º



![image-20210131134715524](/Image/A1.Data_Structure-photo/image-20210131134715524.png)

a



```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
using namespace std;
#define MAX_N 5000

struct Data {
    int l, r;
    string s;
} arr[MAX_N + 5];

set<int> ind_s;
map<int ,int> ind;
int cnt = 0;

struct UnionSet {
    int father[MAX_N << 1 + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; ++i) {
            father[i] = i;
            val[i] = 0;
        }
        return ;
    }
    
    int get(int x) {
        if (father[x] == x) return x;
        int root = get(father[x]);
        val[x] += val[father[x]];
        val[x] %= 2;
        return father[x] = root;
    }
    
    int merge(int a, int b, int c) {
        int fa = get(a), fb = get(b);
        if (fa == fb) {
            return (val[a] - val[b] - c) % 2 == 0;
        }
        father[fa] = father[fb];
        val[fa] = (c + val[b] - val[a] + 2) % 2;
        return 1;
    }
};

UnionSet u;

int main() {
    int l, q;
    cin >> l >> q;
    for (int i = 0; i < q; ++i) {
        cin >> arr[i].l >> arr[i].r >> arr[i].s;
        arr[i].r += 1;
        ind_s.insert(arr[i].l);
        ind_s.insert(arr[i].r);
    }

    for (auto cur : ind_s) {
        ind[cur] = ++cnt;
    }

    u.init(cnt);
    for (int i = 0; i < q; ++i) {
        arr[i].l = ind[arr[i].l];
        arr[i].r = ind[arr[i].r];
        if (u.merge(arr[i].l, arr[i].r, arr[i].s == "odd")) continue;
        cout << i << endl;
        return 0;
    }
    cout << q << endl;
    return 0;
}

```

### 8.0.11. HZOJ-326-é£Ÿç‰©é“¾

![image-20210131145149668](/Image/A1.Data_Structure-photo/image-20210131145149668.png)

a

```cpp
using namespace std;
#define MAX_N 50000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5], n;
    void init(int n) {
        this->n = n;
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
            val[i] = 0;
        }
        return ;
    }
    int get(int x) {
        if (fa[x] == x) return x;
        int ret = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 3;
        return fa[x] = ret;
    }
    int merge(int a, int b, int c) {
        if (a > n || b > n) return 0;
        int aa = get(a), bb = get(b);
        if (aa == bb) {
            return (val[a] - val[b] - c) % 3 == 0;
        }
        fa[aa] = bb;
        val[aa] = ((c - val[a] + val[b]) % 3 + 3) % 3;
        return 1;
    }
} u;

int main() {
    int n, m, a, b, c, ans = 0;
    cin >> n >> m;
    u.init(n);
    while (m--) {
        cin >> c >> a >> b;
        c -= 1;
        if (!u.merge(a, b, c)) ans += 1;
    }
    cout << ans << endl;
    return 0;
}
```













### 8.0.12. HZOJ-327-å…³æŠ¼ç½ªçŠ¯.cpp



```cpp
 
/*************************************************************************
   > File Name: 327.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: æ—¥ 11/24 14:36:55 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 20000
#define MAX_M 100000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; i++) fa[i] = i, val[i] = 0;
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 2;
        return fa[x] = root;
    }
    bool merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) {
            return (val[a] + val[b]) % 2;
        }
        fa[aa] = bb;
        val[aa] = (3 + val[b] - val[a]) % 2;
        return true;
    }
};

struct Data {
    int i, j, c;
} arr[MAX_M + 5];

UnionSet u;

int main() {
    int n, m;
    cin >> n >> m;
    u.init(n);
    for (int i = 0; i < m; i++) {
        cin >> arr[i].i >> arr[i].j >> arr[i].c;
    }
    sort(arr, arr + m, [](const Data &a, const Data &b) {
        return a.c > b.c;
    });
    int ans = 0;
    for (int i = 0; i < m; i++) {
        if (!u.merge(arr[i].i, arr[i].j)) {
            ans = arr[i].c;
            break;
        }
    }
    cout << ans << endl;
    return 0;
}

```





### 8.0.13. [128. æœ€é•¿è¿ç»­åºåˆ—](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> ç»™å®šä¸€ä¸ªæœªæ’åºçš„æ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾å‡ºæ•°å­—è¿ç»­çš„æœ€é•¿åºåˆ—ï¼ˆä¸è¦æ±‚åºåˆ—å…ƒç´ åœ¨åŸæ•°ç»„ä¸­è¿ç»­ï¼‰çš„é•¿åº¦

```cpp
/*************************************************************************
   > File Name: 128.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: æ—¥ 11/24 18:46:05 2019
 ************************************************************************/

class UnionSet {
public :
    vector<int> fa, size;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) {
            fa.push_back(i);
            size.push_back(1);
        }
        return ;
    }
    int get(int x) {
        return (fa[x] = (fa[x] == x ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        size[bb] += size[aa];
        return ;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        u.init(nums.size());
        unordered_map<int, int> ht;
        for (int i = 0; i < nums.size(); i++) {
            int k = nums[i];
            if (ht.find(k) != ht.end()) continue;
            if (ht.find(k - 1) != ht.end()) {
                u.merge(i, ht[k - 1]);
            }
            if (ht.find(k + 1) != ht.end()) {
                u.merge(i, ht[k + 1]);
            }
            ht[k] = i;
        }
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            ans = max(ans, u.size[i]);
        }
        return ans;
    }
    UnionSet u;
};
```

```cpp
class Solution
{
    public:
        //AC - 24ms - bottom-up method;
        int longestConsecutive(vector<int>& nums) 
        {
            int maxCount = 0, lCount = 0, rCount = 0;
            unordered_map<int, int> count_map;
            for(int i = 0; i < nums.size(); ++i)
            {
                if(!count_map[nums[i]])
                {
                    int lCount = count_map[nums[i]-1];
                    int rCount = count_map[nums[i]+1];
                    int sum = lCount+rCount+1;
                    count_map[nums[i]] = count_map[nums[i]-lCount] = count_map[nums[i]+rCount] = sum;
                    maxCount = max(maxCount, sum);
                }
            }
            return maxCount;
        }

        //AC - 20ms - blood spreading into two directions;
        int longestConsecutive(vector<int>& nums)
        {
            unordered_set<int> set(nums.begin(), nums.end());
            int ret = 1;
            for(auto &n: nums)
            {
                if(!set.count(n)) continue;
                set.erase(n);
                int pre=n-1, next=n+1;
                while(set.count(pre)) set.erase(pre--);
                while(set.count(next)) set.erase(next++);
                ret = max(ret, next-pre-1);
            }
            return ret;
        }
};

```



### 8.0.14. [130. è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode-cn.com/problems/surrounded-regions/)

```cpp

class Solution {
public:
    int dir[4][2] = {0,1 , 1, 0, 0, -1, -1, 0};
    struct node {
        int x, y;
    };
    void bfs(int sx, int sy, vector<vector<int>> &check, vector<vector<char>> &board) {
                int n = board.size(), m = board[0].size();
                queue<node> que;
                que.push((node){sx, sy});
                check[sx][sy] = 1;
                while (!que.empty()) {
                    node temp = que.front();
                    que.pop();
                    for (int i = 0; i < 4; ++i) {
                        int x = temp.x + dir[i][0];
                        int y = temp.y + dir[i][1];
                        if (x < 0 || y < 0 || x >= n || y >= m || check[x][y] || board[x][y] == 'X') continue;
                        check[x][y] = 1;
                        que.push((node){x, y});
                    }     
                }
    }
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        if (n == 0) return ;
        int m = board[0].size();
        vector<vector<int>> check(n, vector<int>(m, 0));
        for (int i  = 0; i < m; ++i) {
            if (board[0][i] == 'X' || check[0][i]) continue;
            bfs(0, i, check, board);
        }
        for (int i  = 0; i < m; ++i) {
            if (board[n - 1][i] == 'X' || check[n - 1][i]) continue;
            bfs(n - 1, i, check, board);
        }
        for (int i  = 1; i < n - 1; ++i) {
            if (board[i][0] == 'X' || check[i][0]) continue;
            bfs(i,0, check, board);
        }
        for (int i  = 1; i < n - 1; ++i) {
            if (board[i][m - 1] == 'X' || check[i][m - 1]) continue;
            bfs(i,m - 1, check, board);
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (check[i][j]) board[i][j] = 'O';
                else board[i][j] = 'X';
            }
        }
        return ;

    }
```

# 9. #

```cpp
/*************************************************************************
   > File Name: 130.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: æ—¥ 11/24 19:46:48 2019
 ************************************************************************/

class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if (board.size() == 0) return ;
        if (board[0].size() == 0) return ;
        n = board.size();
        m = board[0].size();
        u.init(n * m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;
                if (i && board[i - 1][j] == 'O')
                    u.merge(ind(i, j), ind(i - 1, j));
                if (j && board[i][j - 1] == 'O')
                    u.merge(ind(i, j), ind(i, j - 1));
                if (i == 0 || i + 1 == n)
                    u.merge(ind(i, j), 0);
                if (j == 0 || j + 1 == m)
                    u.merge(ind(i, j), 0);
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;
                if (u.get(ind(i, j)) == u.get(0)) continue;
                board[i][j] = 'X';
            }
        }
        return ;
    }
    int ind(int i, int j) {
        return i * m + j + 1;
    }
    int n, m;
    UnionSet u;
};
```

### 9.0.15. Leetcode-200[å²›å±¿æ•°é‡](https://leetcode-cn.com/problems/number-of-islands/description/)

ç»™ä½ ä¸€ä¸ªç”± `'1'`ï¼ˆé™†åœ°ï¼‰å’Œ `'0'`ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚

å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚

```cpp
è¾“å…¥ï¼šgrid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
è¾“å‡ºï¼š1
```

```cpp
/*************************************************************************
   > File Name: 200.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å››  5/23 19:08:07 2019
 ************************************************************************/

#define MC(T, n) (T *)malloc(sizeof(T) * (n))
#define CC(T, n) (T *)calloc(sizeof(T), (n))

typedef struct UnionSet {
    int *fa;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = MC(UnionSet, 1);
    u->fa = MC(int, n + 1);
    u->n = n;
    for (int i = 1; i <= n; i++) u->fa[i] = i;
    return u;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->fa);
    free(u);
    return ;
}

int get(UnionSet *u, int x) {
    if (u->fa[x] == x) return x;
    return u->fa[x] = get(u, u->fa[x]);
}

void merge(UnionSet *u, int a, int b) {
    u->fa[get(u, a)] = get(u, b);
}

int numIslands(char** grid, int n, int *M) {
    if (n == 0) return 0;
    int m = M[0];
    #define ind(i, j) ((i) * (m) + (j) + 1)
    UnionSet *u = init(n * m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == '0') continue;
            if (i - 1 >= 0 && grid[i - 1][j] == '1')
                merge(u, ind(i, j), ind(i - 1, j));
            if (j - 1 >= 0 && grid[i][j - 1] == '1')
                merge(u, ind(i, j), ind(i, j - 1));
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == '0') continue;
            ans += (get(u, ind(i, j)) == ind(i, j));
        }
    }
    clear(u);
    return ans;
}
```



### 9.0.16. LC-547

```cpp
class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        int n = M.size();
        u.init(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (M[i][j] == 0) continue;
                u.merge(i, j);
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) ans += (u.get(i) == i);
        return ans;
    }
    UnionSet u;
};
```

### 9.0.17. Leetcode-684

```cpp
class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        u.init(n);
        vector<int> ret;
        for (int i = 0; i < n; i++) {
            vector<int> &e = edges[i];
            if (u.get(e[0]) == u.get(e[1])) {
                ret = e;
                break;
            }
            u.merge(e[0], e[1]);
        }
        return ret;
    }
    UnionSet u;
};
```



### 9.0.18. [685. å†—ä½™è¿æ¥ II](https://leetcode-cn.com/problems/redundant-connection-ii/)

1. `æœ‰ç¯` ï¼šæ„æˆç¯å½¢æ•°å­—1è¿åˆ°2,2è¿åˆ°3,3è¿åˆ°1å°±æ˜¯ä¸ªç¯
2. `å†²çª `ï¼šä¸€ä¸ªç‚¹æœ‰ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹

- æœ‰ç¯æ— å†²çª [[1,2],[2,3],[3,1]]
- æœ‰ç¯æœ‰å†²çª [[1,2],[2,3],[3,1],[4,2]]
- æ— ç¯æœ‰å†²çª [[1,2],[1,3],[2,3]]

> åœ¨æœ¬é—®é¢˜ä¸­ï¼Œæœ‰æ ¹æ ‘æŒ‡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ‰å‘å›¾ã€‚è¯¥æ ‘åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„åç»§ã€‚æ¯ä¸€ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œé™¤äº†æ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚
>
> è¾“å…¥ä¸€ä¸ªæœ‰å‘å›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€Nä¸ªèŠ‚ç‚¹ (èŠ‚ç‚¹å€¼ä¸é‡å¤1, 2, ..., N) çš„æ ‘åŠä¸€æ¡é™„åŠ çš„è¾¹æ„æˆã€‚é™„åŠ çš„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹åŒ…å«åœ¨1åˆ°Nä¸­é—´ï¼Œè¿™æ¡é™„åŠ çš„è¾¹ä¸å±äºæ ‘ä¸­å·²å­˜åœ¨çš„è¾¹ã€‚
>
> ç»“æœå›¾æ˜¯ä¸€ä¸ªä»¥è¾¹ç»„æˆçš„äºŒç»´æ•°ç»„ã€‚ æ¯ä¸€ä¸ªè¾¹ çš„å…ƒç´ æ˜¯ä¸€å¯¹ [u, v]ï¼Œç”¨ä»¥è¡¨ç¤ºæœ‰å‘å›¾ä¸­è¿æ¥é¡¶ç‚¹ u å’Œé¡¶ç‚¹ v çš„è¾¹ï¼Œå…¶ä¸­ u æ˜¯ v çš„ä¸€ä¸ªçˆ¶èŠ‚ç‚¹

è¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€ N ä¸ªèŠ‚ç‚¹ (èŠ‚ç‚¹å€¼ä¸é‡å¤ 1, 2, ..., N) çš„æ ‘åŠä¸€æ¡é™„åŠ çš„è¾¹æ„æˆã€‚é™„åŠ çš„è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹åŒ…å«åœ¨ 1 åˆ° N ä¸­é—´ï¼Œè¿™æ¡é™„åŠ çš„è¾¹ä¸å±äºæ ‘ä¸­å·²å­˜åœ¨çš„è¾¹ã€‚

è¿™è¯´æ˜é¢˜ç›®ä¸­çš„å›¾åŸæœ¬æ˜¯æ˜¯ä¸€æ£µæ ‘ï¼Œåªä¸è¿‡åœ¨ä¸å¢åŠ èŠ‚ç‚¹çš„æƒ…å†µä¸‹å¤šåŠ äº†ä¸€æ¡è¾¹ï¼

è¿˜æœ‰ è‹¥æœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¿”å›æœ€åå‡ºç°åœ¨ç»™å®šäºŒç»´æ•°ç»„çš„ç­”æ¡ˆã€‚è¿™è¯´æ˜åœ¨ä¸¤å¤©è¾¹éƒ½å¯ä»¥åˆ é™¤çš„æƒ…å†µä¸‹ï¼Œè¦åˆ é¡ºåºé åçš„ï¼

é‚£ä¹ˆæœ‰å¦‚ä¸‹ä¸‰ç§æƒ…å†µï¼Œå‰ä¸¤ç§æƒ…å†µæ˜¯å‡ºç°å…¥åº¦ä¸º 2 çš„ç‚¹ï¼Œå¦‚å›¾ï¼š

![685.å†—ä½™è¿æ¥II1.png](/Image/A1.Data_Structure-photo/1600316277-YhGBBy-685.å†—ä½™è¿æ¥II1.png)

ä¸”åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹å…¥åº¦ä¸º 2ï¼Œä¸ºä»€ä¹ˆä¸çœ‹å‡ºåº¦å‘¢ï¼Œå‡ºåº¦æ²¡æœ‰æ„ä¹‰ï¼Œä¸€é¢—æ ‘ä¸­éšä¾¿ä¸€ä¸ªçˆ¶èŠ‚ç‚¹å°±æœ‰å¤šä¸ªå‡ºåº¦ã€‚

ç¬¬ä¸‰ç§æƒ…å†µæ˜¯æ²¡æœ‰å…¥åº¦ä¸º 2 çš„ç‚¹ï¼Œé‚£ä¹ˆå›¾ä¸­ä¸€å®šå‡ºç°äº†æœ‰å‘ç¯ï¼ˆæ³¨æ„è¿™é‡Œå¼ºè°ƒæ˜¯æœ‰å‘ç¯ï¼ï¼‰

å¦‚å›¾ï¼š

![685.å†—ä½™è¿æ¥II2.png](/Image/A1.Data_Structure-photo/1600316290-fCDJSg-685.å†—ä½™è¿æ¥II2.png)



```cpp
class Solution {
private:
    static const int N = 1010; // å¦‚é¢˜ï¼šäºŒç»´æ•°ç»„å¤§å°çš„åœ¨3åˆ°1000èŒƒå›´å†…
    int father[N];
    int n; // è¾¹çš„æ•°é‡
    // å¹¶æŸ¥é›†åˆå§‹åŒ–
    void init() {
        for (int i = 1; i <= n; ++i) {
            father[i] = i;
        }
    }
    // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // å°†v->u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›†
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
    // åœ¨æœ‰å‘å›¾é‡Œæ‰¾åˆ°åˆ é™¤çš„é‚£æ¡è¾¹ï¼Œä½¿å…¶å˜æˆæ ‘
    vector<int> getRemoveEdge(const vector<vector<int>>& edges) {
        init(); // åˆå§‹åŒ–å¹¶æŸ¥é›†
        for (int i = 0; i < n; i++) { // éå†æ‰€æœ‰çš„è¾¹
            if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œå°±æ˜¯è¦åˆ é™¤çš„è¾¹
                return edges[i];
            }
            join(edges[i][0], edges[i][1]);
        }
        return {};
    }

    // åˆ ä¸€æ¡è¾¹ä¹‹ååˆ¤æ–­æ˜¯ä¸æ˜¯æ ‘
    bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
        init(); // åˆå§‹åŒ–å¹¶æŸ¥é›†
        for (int i = 0; i < n; i++) {
            if (i == deleteEdge) continue;
            if (same(edges[i][0], edges[i][1])) { // æ„æˆæœ‰å‘ç¯äº†ï¼Œä¸€å®šä¸æ˜¯æ ‘
                return false;
            }
            join(edges[i][0], edges[i][1]);
        }
        return true;
    }
public:

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int inDegree[N] = {0}; // è®°å½•èŠ‚ç‚¹å…¥åº¦
        n = edges.size(); // è¾¹çš„æ•°é‡
        for (int i = 0; i < n; i++) {
            inDegree[edges[i][1]]++; // ç»Ÿè®¡å…¥åº¦
        }
        vector<int> vec; // è®°å½•å…¥åº¦ä¸º2çš„è¾¹ï¼ˆå¦‚æœæœ‰çš„è¯å°±ä¸¤æ¡è¾¹ï¼‰
        // æ‰¾å…¥åº¦ä¸º2çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹ï¼Œæ³¨æ„è¦å€’å™ï¼Œå› ä¸ºä¼˜å…ˆè¿”å›æœ€åå‡ºç°åœ¨äºŒç»´æ•°ç»„ä¸­çš„ç­”æ¡ˆ
        for (int i = n - 1; i >= 0; i--) {
            if (inDegree[edges[i][1]] == 2) {
                vec.push_back(i);
            }
        }
        // å¤„ç†å›¾ä¸­æƒ…å†µ1 å’Œ æƒ…å†µ2
        // å¦‚æœæœ‰å…¥åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯ä¸¤æ¡è¾¹é‡Œåˆ ä¸€ä¸ªï¼Œçœ‹åˆ å“ªä¸ªå¯ä»¥æ„æˆæ ‘
        if (vec.size() > 0) {
            if (isTreeAfterRemoveEdge(edges, vec[0])) {
                return edges[vec[0]];
            } else {
                return edges[vec[1]];
            }
        }
        // å¤„ç†å›¾ä¸­æƒ…å†µ3
        // æ˜ç¡®æ²¡æœ‰å…¥åº¦ä¸º2çš„æƒ…å†µï¼Œé‚£ä¹ˆä¸€å®šæœ‰æœ‰å‘ç¯ï¼Œæ‰¾åˆ°æ„æˆç¯çš„è¾¹è¿”å›å°±å¯ä»¥äº†
        return getRemoveEdge(edges);

    }
};
```





```cpp
/*************************************************************************
   > File Name: 685.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: æ—¥ 11/24 21:23:30 2019
 ************************************************************************/

class UnionSet {
public:
    vector<int> fa;
    int cnt;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
        cnt = n;
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        cnt -= (get(a) != get(b));
        fa[get(a)] = get(b);
    }
};

class Solution {
public:

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> indeg(n + 1), outdeg(n + 1), father(n + 1);
        for (int i = 0; i < n; i++) {
            indeg[edges[i][1]] += 1;
            outdeg[edges[i][0]] += 1;
            father[edges[i][1]] = edges[i][0];
        }
        int flag = 0;
        for (int i = 1; i <= n; i++) {
            if (indeg[i] <= 1) continue;
            flag = i;
            break;
        }
        if (flag) {
            for (int i = n - 1; i >= 0; i--) {
                if (edges[i][1] - flag) continue;
                u.init(n);
                for (int j = 0; j < n; j++) {
                    if (i == j) continue;
                    u.merge(edges[j][0], edges[j][1]);
                }

                if (u.cnt != 1) {
                    continue;
                }
                return edges[i];
            }
        }
        queue<int> q;
        vector<int> ret;
        for (int i = 1; i <= n; i++) {
            if (outdeg[i]) continue;
            q.push(i);
        }
        while (!q.empty()) {
            int ind = q.front();
            q.pop();
            outdeg[father[ind]] -= 1;
            if (outdeg[father[ind]] == 0) q.push(father[ind]);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (outdeg[edges[i][0]] && outdeg[edges[i][1]]) {
                ret = edges[i];
                break;
            }
        }
        return ret;
    }
    UnionSet u;
};
```

### 9.0.19. [é™¤æ³•æ±‚å€¼](https://leetcode-cn.com/problems/evaluate-division/description/)

ç»™ä½ ä¸€ä¸ªå˜é‡å¯¹æ•°ç»„ `equations` å’Œä¸€ä¸ªå®æ•°å€¼æ•°ç»„ `values` ä½œä¸ºå·²çŸ¥æ¡ä»¶ï¼Œå…¶ä¸­ `equations[i] = [Ai, Bi]` å’Œ `values[i]` å…±åŒè¡¨ç¤ºç­‰å¼ `Ai / Bi = values[i]` ã€‚æ¯ä¸ª `Ai` æˆ– `Bi` æ˜¯ä¸€ä¸ªè¡¨ç¤ºå•ä¸ªå˜é‡çš„å­—ç¬¦ä¸²ã€‚

å¦æœ‰ä¸€äº›ä»¥æ•°ç»„ `queries` è¡¨ç¤ºçš„é—®é¢˜ï¼Œå…¶ä¸­ `queries[j] = [Cj, Dj]` è¡¨ç¤ºç¬¬ `j` ä¸ªé—®é¢˜ï¼Œè¯·ä½ æ ¹æ®å·²çŸ¥æ¡ä»¶æ‰¾å‡º `Cj / Dj = ?` çš„ç»“æœä½œä¸ºç­”æ¡ˆã€‚

è¿”å› **æ‰€æœ‰é—®é¢˜çš„ç­”æ¡ˆ** ã€‚å¦‚æœå­˜åœ¨æŸä¸ªæ— æ³•ç¡®å®šçš„ç­”æ¡ˆï¼Œåˆ™ç”¨ `-1.0` æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚å¦‚æœé—®é¢˜ä¸­å‡ºç°äº†ç»™å®šçš„å·²çŸ¥æ¡ä»¶ä¸­æ²¡æœ‰å‡ºç°çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿéœ€è¦ç”¨ `-1.0` æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚

**æ³¨æ„ï¼š**è¾“å…¥æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ä½ å¯ä»¥å‡è®¾é™¤æ³•è¿ç®—ä¸­ä¸ä¼šå‡ºç°é™¤æ•°ä¸º 0 çš„æƒ…å†µï¼Œä¸”ä¸å­˜åœ¨ä»»ä½•çŸ›ç›¾çš„ç»“æœã€‚



**ç¤ºä¾‹ 1ï¼š**

```cpp
è¾“å…¥ï¼šequations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
è¾“å‡ºï¼š[6.00000,0.50000,-1.00000,1.00000,-1.00000]
è§£é‡Šï¼š
æ¡ä»¶ï¼ša / b = 2.0, b / c = 3.0
é—®é¢˜ï¼ša / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
ç»“æœï¼š[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

# 10. ==æ ‘çŠ¶æ•°ç»„==

## 10.1. ä¸€ã€å‰ç¼€å’Œä¸å·®åˆ†

1. åŸæ•°ç»„ï¼š${a_1, a_2,a_3,....,a_n}$
2. å‰ç¼€å’Œï¼š$S_i=\sum_{k=1}^{k=i}{a_i}$ï¼Œ$a_i=S_i-S_{i-1}$
3. å·®åˆ†æ•°ç»„ï¼š$X_i=a_i-a_{i-1}$
4. X æ•°ç»„æ˜¯ a æ•°ç»„çš„å·®åˆ†æ•°ç»„ï¼Œa æ•°ç»„æ˜¯ S æ•°ç»„çš„å·®åˆ†æ•°ç»„
5. S æ•°ç»„æ˜¯ a æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„ï¼Œa æ•°ç»„æ˜¯ X æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„
6. å‰ç¼€å’Œæ•°ç»„ä»¥åŠå·®åˆ†æ•°ç»„ï¼Œå¹¶æ²¡æœ‰å¢åŠ ä¿¡æ¯ï¼Œåªæ˜¯ä¿¡æ¯çš„å¦å¤–ä¸€ç§è¡¨ç¤ºå½¢å¼
7. å‰ç¼€å’Œæ•°ç»„ç”¨æ¥ä¼˜åŒ–åŒºé—´å’Œæ“ä½œ
8. å·®åˆ†æ•°ç»„ç”¨æ¥ä¼˜åŒ–åŒºé—´ä¿®æ”¹æ“ä½œ



### 10.1.1. é—®é¢˜1ï¼šåŸæ•°ç»„åŒºé—´å’Œæ“ä½œ

a æ•°ç»„ä¸Šçš„æ“ä½œï¼š$O(n)$

S æ•°ç»„ä¸Šçš„æ“ä½œï¼š$O(1)ï¼ŒS_i - S_{j-1}=a[j,i]åŒºé—´å’Œ$



### 10.1.2. é—®é¢˜2ï¼šåŸæ•°ç»„åŒºé—´å…ƒç´ ä¿®æ”¹ï¼ˆåŠ æ³•ï¼‰

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



a æ•°ç»„æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

X æ•°ç»„æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

![image-20210131164748767](/Image/A1.Data_Structure-photo/image-20210131164748767.png)

## 10.2. äºŒã€æ ‘çŠ¶æ•°ç»„

1. lowbit å‡½æ•°æ±‚æ•°å­— iï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æœ€ä½1æ‰€åœ¨çš„ä½æƒ
2. lowbit(x) = x & -x
3. æ ‘çŠ¶æ•°ç»„æœ¬è´¨ä¸Šæ˜¯å¯¹å‰ç¼€å’Œæ•°ç»„çš„ä¸€ç§ä¼˜åŒ–ï¼Œä¸»è¦ä½“ç°åœ¨å•ç‚¹ä¿®æ”¹æ“ä½œä¸Š
4. å‰ç¼€å’ŒæŸ¥è¯¢ $O(logn)$ï¼Œå•ç‚¹ä¿®æ”¹$O(logn)$
5. ç›¸æ¯”äºæœ€æ™®é€šçš„å‰ç¼€å’Œæ•°ç»„ï¼ŒæŸ¥è¯¢æ–¹é¢å˜å·®ï¼Œå•ç‚¹ä¿®æ”¹æ“ä½œå˜å¥½ï¼Œç»¼åˆæ—¶é—´å¤æ‚åº¦å˜å¥½
6. æŸ¥è¯¢çš„æ—¶å€™ï¼Œå‘å‰ç»Ÿè®¡ï¼Œ$i$ çš„å‰ä¸€ä½ $i-lowbit(i)$
7. ä¿®æ”¹çš„æ—¶å€™ï¼Œå‘åä¿®æ”¹ï¼Œ$i$ çš„åä¸€ä½ $i + lowbit(i)$
8. lowbit(i):C[i]ä»£è¡¨å‰lowbit[i]é¡¹çš„å’Œ



## 10.3. ä¸‰ã€æµ·è´¼ OJ-329-å¼±åŒ–çš„æ•´æ•°é—®é¢˜

### 10.3.1. å¼•å…¥å·®åˆ†æ•°ç»„

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



å¼•å…¥å·®åˆ†æ•°ç»„ Xï¼Œå°†åŸæ•°ç»„ a ä¸Šçš„åŒºé—´åŠ æ“ä½œï¼Œè½¬æ¢æˆ X æ•°ç»„ä¸Šçš„ä¸¤æ¬¡ã€å•ç‚¹æ“ä½œã€‘

å¯¹äºæŸ¥è¯¢åŸæ•°ç»„ a[i] çš„å€¼ï¼Œç­‰ä»·äºæŸ¥è¯¢ X æ•°ç»„å‰ i ä½çš„ã€å‰ç¼€å’Œã€‘



### 10.3.2. ç»“è®º

ç”±äºï¼Œæ—¢è¦ç»´æŠ¤ã€å‰ç¼€å’Œã€‘ï¼Œåˆè¦è¿›è¡Œã€å•ç‚¹ä¿®æ”¹ã€‘ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„



![image-20210131164801074](/Image/A1.Data_Structure-photo/image-20210131164801074.png)



## 10.4. å››ã€æµ·è´¼ OJ-330-åŠ å¼ºçš„æ•´æ•°é—®é¢˜

### 10.4.1. å¼•å…¥å·®åˆ†æ•°ç»„

å‚è€ƒ HZOJ-329 çš„è§£æ³•ï¼Œä¸»è¦ä¸ºäº†ç»´æŠ¤åŸæ•°ç»„ä¸Šçš„åŒºé—´ä¿®æ”¹æ“ä½œ

 "C a b c"è¡¨ç¤ºç»™[a, b]åŒºé—´ä¸­çš„å€¼å…¨éƒ¨å¢åŠ c (-10000 â‰¤ c â‰¤ 10000)ã€‚

 "Q a b" è¯¢é—®[a, b]åŒºé—´ä¸­æ‰€æœ‰å€¼çš„å’Œã€‚

### 10.4.2. åŸæ•°ç»„ä¸Šçš„åŒºé—´å’Œé—®é¢˜è½¬åŒ–

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$

$Query(l, r) = S(r) - S(l - 1)$ï¼Œé‡ç‚¹åˆ†æ S æ€ä¹ˆæ±‚ï¼Œä¼šæ±‚ Sï¼Œä¸‡äº‹å¤§å‰

$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k*X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k*X_k}$

è®¾$Y_i = i \times X_i$

$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$



### 10.4.3. ç»“è®º

$S_i$ å¯ä»¥é€šè¿‡ç»´æŠ¤ X ä¸ Y ä¸¤ä¸ªåºåˆ—çš„å‰ç¼€å’Œå¾—åˆ°

æ‰€ä»¥å¯ä»¥é€šè¿‡ç»´æŠ¤ä¸¤ä¸ªä¸å·®åˆ†æ•°ç»„ X ç›¸å…³çš„å‰ç¼€å’Œæ•°ç»„ï¼Œä»è€Œå¾—åˆ°åŸæ•°ç»„ a çš„å‰ç¼€å’Œå€¼

éœ€è¦ç»´æŠ¤ä¸¤ä¸ªï¼šæ ‘çŠ¶æ•°ç»„

![image-20210131164827184](/Image/A1.Data_Structure-photo/image-20210131164827184.png)



```cpp
long long c[2][MAX_N + 5];

void add(long long k, long long i, long long x, long long n) {
    while (i <= n) {
        c[k][i] += x;
        i += lowbit(i);
    }    
    return ;
}

long long query(long long k, long long i) {
    long long sum = 0;
    while (i) {
        sum += c[k][i];
        i -= lowbit(i);
    }
    return sum;
}

long long S(long long i) {
    return (i + 1) * query(0, i) - query(1, i);
}

void modify(long long i, long long x, long long n) {
    add(0, i, x, n);
    add(1, i, i * x, n);
    return ;
}
```





```cpp
#define MAX_N 100000
int c[MAX_N + 5];
inline int lowbit(int x) { return x & (-x); }
void add(int x, int val, int n) {
    while (x <= n) c[x] += val, x += lowbit(x);
}
int query(int x) {
    int sum = 0;
    while (x) sum += c[x], x -= lowbit(x);
    return sum;
}

int main() {
    int n, m, pre = 0, now;
    char str[10];
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> now;
        add(i, now - pre, n);
        pre = now;
    }
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str;
        switch (str[0]) {
            case 'C': {
                int a, b, c;
                cin >> a >> b >> c;
                add(a, c, n);
                add(b + 1, -c, n);
            } break;
            case 'Q': {
                int x;
                cin >> x;
                cout << query(x) << endl;
            }
        }
    }
    return 0;
}
```

## 10.5. ä¸€ã€æµ·è´¼ OJ-331-ä¸¢å¤±çš„å¥¶ç‰›

> æœ‰*ğ‘›*nåªå°åŠ¨ç‰©ï¼Œæ¯åªéƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ç¼–å·ï¼Œåˆ†åˆ«ä»11åˆ°*ğ‘›*nã€‚ç°åœ¨ä»–ä»¬ä»å·¦åˆ°å³ä¾æ¬¡æ’åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œé¡ºåºæ˜¯ä¹±çš„ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬åªçŸ¥é“æ¯ä¸ªä½ç½®å‰é¢æœ‰å‡ ä¸ªæ¯”ä»–å°çš„æ•°ã€‚è¯·ä½ æ ¹æ®ç»™å‡ºçš„ä¿¡æ¯è®¡ç®—å‡ºæ¯ä¸ªä½ç½®ä¸Šçš„æ•°æ˜¯å¤šå°‘

1. ç†è§£æ ‡è®°æ•°ç»„ï¼Œæ ‡è®°æ•°ç»„è®°å½•çš„æ˜¯æ¯ä¸€ä¸ªä¸‹æ ‡çŸ¥å¦å¯ç”¨ï¼Œå¯ç”¨ä¸º1ï¼Œä¸å¯ç”¨ä¸º0
2. æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬ä»åå‘å‰ï¼Œä¾æ¬¡ç¡®å®šæ¯ä¸€å¤´å¥¶ç‰›çš„ç¼–å·
3. ä¾‹å¦‚ï¼Œå½“å‰å¥¶ç‰›æ¯”ä»–å‰é¢çš„2ä¸ªå¥¶ç‰›ç¼–å·å¤§çš„è¯ï¼Œå½“å‰å¥¶ç‰›çš„ç¼–å·å°±æ˜¯å½“å‰å‰©ä½™å¯ç”¨ç¼–å·ä¸­çš„ç¬¬ä¸‰å¤§çš„ç¼–å·
4. å¦‚ä½•æ‰¾åˆ°å¯ç”¨çš„ç¬¬ x å¤§çš„ç¼–å·ï¼Œå¯ä»¥åœ¨æ ‡è®°æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„ä¸ŠåšäºŒåˆ†æŸ¥æ‰¾
5. è®¾è®¡åˆ°æ ‡è®°æ•°ç»„çš„å‰ç¼€å’Œç»´æŠ¤å’Œå•ç‚¹æ›´æ–°ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„
6. æ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$

```cpp
int n;
int ind[MAX_N + 5];
int cnt[MAX_N + 5];

void read() {
    cin >> n;
    ind[1] = 0;
    for (int i = 2; i <= n; ++i) cin >> cnt[i];
    for (int i = 1; i <= n; ++i) {
        add(i, 1, n);
    }
    return ;
}

int binary_search(int n, int x) {
    int head = 1, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (query(mid, n) < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

void solve() {
    for (int i = n; i >= 1; --i) {
        ind[i] = binary_search(n, cnt[i] + 1);
        add(ind[i], -1, n);
    }
    return ;
}

void output() {
    for (int i = 1; i <= n; ++i) {
        cout << ind[i] << endl;
    }
    return ;
}
```





ç›¸ä¼¼é—®é¢˜ï¼šæµ·è´¼ OJ-332-ä¹°ç¥¨



## 10.6. äºŒã€æµ·è´¼ OJ-328-æ¥¼å…°å›¾è…¾

1. æ±‚åœ¨å½“å‰ä½ç½®ä¹‹å‰ï¼Œå°äºå½“å‰ä½ç½®å€¼çš„å…ƒç´ æ•°é‡ï¼Œå½“å‰å…ƒç´ å€¼è®°ä¸º Xï¼Œå…ƒç´ æ•°é‡è®°ä¸º aï¼Œå…ƒç´ ä½ç½®è®°ä¸º i
2. å‰é¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯ $a$
3. åé¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯$X - a - 1$
4. å‰é¢å¤§äº $X$ çš„å…ƒç´ æ•°é‡ $i - a - 1$
5. åé¢å¤§äºX çš„å…ƒç´ æ•°é‡$n-X-i+a+1$
6. è§£é¢˜å…³é”®ï¼šå‰é¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯ $a$
7. æ ‡è®°æ•°ç»„ï¼Œè®°å½•å½“å‰ä½ç½®ä¹‹å‰æœ‰å“ªäº›å…ƒç´ å‡ºç°è¿‡ï¼Œå‡ºç°è¿‡æ ‡è®°ä¸º 1ï¼Œå¦åˆ™æ ‡è®°ä¸º 0
8. $a$ ç­‰äºæ ‡è®°æ•°ç»„åœ¨ $X$ ä½ç½®ä¹‹å‰çš„å‰ç¼€å’Œ
9. å¯¹äºæ ‡è®°æ•°ç»„çš„å•ç‚¹ä¿®æ”¹åŠå‰ç¼€å’ŒæŸ¥è¯¢ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„



```cpp
void solve(long long &x, long long &y) {
    x = y = 0;
    for (long long i = 1; i <= n; ++i) {
        long long a1 = query(val[i], n);
        long long a2 = val[i] - a1 - 1;
        long long b1 = i - a1 - 1;
        long long b2 = n - val[i] - b1;
        x += b1 * b2;
        y += a1 * a2;
        add(val[i], 1, n);
    }  
}
```





## 10.7. ä¸‰ã€æµ·è´¼ OJ-333-åŒºé—´æœ€å¤§å­æ®µå’Œ

1. çº¿æ®µæ ‘æœ‰ç‚¹ç‚¹å„¿éš¾åº¦çš„é¢˜ç›®
2. æ¯ä¸ªèŠ‚ç‚¹ï¼šåŒºé—´å’Œå€¼ï¼Œæœ€å¤§å­æ®µå’Œå€¼ï¼Œå·¦ä¾§æœ€å¤§å­æ®µå’Œï¼Œå³ä¾§æœ€å¤§å­æ®µå’Œ
3. ç‰¹æ®Šæ€§è´¨ï¼šé€’å½’éå†æ—¶ï¼Œæ˜¯æŒ‰ç…§ä¸‹æ ‡é¡ºåºå¾—åˆ°çš„æ¯ä¸€ä¸ªæŸ¥è¯¢åŒºé—´å†…çš„çº¿æ®µæ ‘çš„èŠ‚ç‚¹
4. $|â‘ â‘¡â‘¢â‘£â‘¤|$ï¼Œå°±æ˜¯æŒ‰ç…§â‘ â‘¡â‘¢â‘£â‘¤çš„é¡ºåºéå†å¾—åˆ°çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹
5. ä»£ç æœ‰ç‚¹å„¿å¤æ‚ï¼Œå­¦ä¼šäº†ï¼Œä»£ç æ€ç»´ä¼šæ›´ä¸Šä¸€å±‚æ¥¼

## 10.8.  

```cpp
#define MAX_N 500000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define SUM(ind) tree[ind].sum
#define MAX(ind) tree[ind].m
#define LMAX(ind) tree[ind].lm
#define RMAX(ind) tree[ind].rm

struct node {
    int sum, m, lm, rm;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 3, cnt = 4, ans = 0, temp = 1;
int arr[MAX_N + 5];
inline int getNode() { return cnt++; }

void UP(int a, int b, int c) {
    SUM(a) = SUM(b) + SUM(c);
    LMAX(a) = max(LMAX(b), SUM(b) + LMAX(c));
    RMAX(a) = max(RMAX(c), SUM(c) + RMAX(b));
    MAX(a) = max(MAX(b), MAX(c));
    MAX(a) = max(MAX(a), RMAX(b) + LMAX(c));
    return ;
}

void UP(int ind) {
    UP(ind, lc(ind), rc(ind));
}

void build(int ind, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    lc(ind) = getNode();
    rc(ind) = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = y;
        
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, l, mid);
    else modify(rc(ind), x, y, mid + 1, r);
    UP(ind);
    return ;
}

void query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        if (x == l) tree[ans] = tree[ind];
        else {
            UP(temp, ans, ind);
            swap(temp, ans);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) query(lc(ind), x, y, l, mid);
    if (y > mid) query(rc(ind), x, y, mid + 1, r);
    return ;
}

ostream &operator<<(ostream &out, node &a) {
    out << (&a - tree) << " : " << a.sum << " " << a.m << " " << a.lm << " " << a.rm;
    out << "(" << a.lind << "," << a.rind << ")";
    return out;
}

void output(int n) {
    for (int i = root; i < root + 2 * n - 1; i++) {
        cout << tree[i] << endl;
    }
    cout << "---------" << endl;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            if (b > c) swap(b, c);
            query(root, b, c, 1, n);
            cout << MAX(ans) << endl;
        } else {
            modify(root, b, c, 1, n);
        }
        //output(n);
    }
    return 0;
}
```

# 11. ==çº¿æ®µæ ‘==

çº¿æ®µæ ‘â€”å…³é”®è¯
å®Œå…¨äºŒå‰æ ‘:çº¿æ®µæ ‘ç¨‹åºå®ç°æ—¶å€™çš„å®é™…å­˜å‚¨ç»“æ„
åŒºé—´:çº¿æ®µæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æ‰€ç»´æŠ¤çš„èŒƒå›´
å‘ ä¸Š æ›´ æ–°:ç”¨ä¸¤ä¸ªå­èŠ‚ç‚¹çš„ä¿¡æ¯æ›´æ–°æœ¬èŠ‚ç‚¹çš„ä¿¡æ¯
ä¸‹ æ²‰ æ ‡ è®°:å°†æœ¬èŠ‚ç‚¹çš„æ‡’æƒ°æ ‡è®°æ›´æ–°ç»™ä¸¤ä¸ªå­èŠ‚ç‚¹
å£è¯€:ä¸‹æ²‰å‘ç”Ÿåœ¨é€’å½’ä¹‹å‰,å‘ä¸Šå‘ç”Ÿåœ¨é€’å½’ä¹‹å

## 11.1. ä¸€ã€é—®é¢˜èƒŒæ™¯

1. å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ˆåŸºç¡€ç‰ˆï¼‰
2. åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ˆè¿›é˜¶ç‰ˆï¼‰
3. å•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ˆç”¨ä¸ç€çº¿æ®µæ ‘ï¼‰
4. åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ˆæ˜¯ç¬¬äºŒç§æƒ…å†µçš„ç‰¹ä¾‹ï¼‰



## 11.2. äºŒã€åŸºç¡€ç‰ˆçº¿æ®µæ ‘

1. çº¿æ®µæ ‘æ˜¯å¯¹äºä¸€ç»´åºåˆ—çš„ä¸€ç§ç»´æŠ¤ç»“æ„

2. é‡‡ç”¨çš„åˆ†æ²»çš„æ€æƒ³ï¼Œå°†æ€»åŒºé—´åˆ†æˆå·¦å³ä¸¤éƒ¨åˆ†ï¼Œä¸€ç›´è¿›è¡Œä¸‹å»ï¼Œç›´åˆ°åŒºé—´ä¸­åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ­¢

3. çº¿æ®µæ ‘çš„å¶å­ç»“ç‚¹ï¼Œä»£è¡¨äº†åŸåºåˆ—ä¸­çš„å•ä¸ªä½ç½®çš„å€¼

4. å¦‚æœé‡‡ç”¨å®Œå…¨äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„çš„è¯ï¼Œæœ€èµ·ç éœ€è¦ $4n$ çš„å­˜å‚¨ç©ºé—´

5. å½“é¢å¯¹åŒºé—´ä¿®æ”¹çš„æ—¶å€™ï¼ŒåŸºç¡€ç‰ˆçš„çº¿æ®µæ ‘æ•ˆç‡ä¸Šè¿˜ä¸å¦‚ç›´æ¥åœ¨ä¸€ç»´åºåˆ—ä¸Šä¿®æ”¹

6. åªé€‚ç”¨äºå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

   ```cpp
   #define MAX_N 10000
   #define lc(ind) (ind << 1)
   #define rc(ind) (ind << 1 | 1)
   
   struct node {
       int sum;
   } tree[(MAX_N << 2) + 5];
   int root = 1;
   int arr[MAX_N + 5];
   
   void UP(int ind) {
       tree[ind].sum = max(tree[lc(ind)].sum, tree[rc(ind)].sum);
       return ;
   }
   
   void build(int ind, int l, int r) {
       if (l == r) {
           tree[ind].sum = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build(lc(ind), l, mid);
       build(rc(ind), mid + 1, r);
       UP(ind);
       return ;
   }
   
   void modify(int ind, int x, int y, int l, int r) {
       if (l == r) {
           tree[ind].sum = y;
           return ;
       }
       int mid = (l + r) >> 1;
       if (x <= mid) modify(lc(ind), x, y, l, mid);
       else modify(rc(ind), x, y, mid + 1, r);
       UP(ind);
       return ;
   }
   
   int query(int ind, int x, int y, int l, int r) {
       if (x <= l && r <= y) {
           return tree[ind].sum;
       }
       int ans = 0x80000000, mid = (l + r) >> 1;
       if (x <= mid) ans = max(ans, query(lc(ind), x, y, l, mid));
       if (y > mid) ans = max(ans, query(rc(ind), x, y, mid + 1, r));
       return ans;
   }
   
   int main() {
       int n, m;
       cin >> n >> m;
       for (int i = 1; i <= n; i++) cin >> arr[i];
       build(root, 1, n);
       for (int i = 0; i < m; i++) {
           int a, b, c;
           cin >> a >> b >> c;
           if (a == 1) modify(root, b, c, 1, n);
           else {
               cout << query(root, b, c, 1, n) << endl;
           }
       }
       return 0;
   }
   ```

   ```cpp
   #define MAX_N 10000
   struct {
       int max_num;
       int l, r;
   } tree[MAX_N << 2];
   int arr[MAX_N + 5];
   
   void update(int ind) {
       tree[ind].max_num = max(tree[ind << 1].max_num, tree[ind << 1 | 1].max_num);
       return ;
   }
   
   void build_tree(int ind, int l, int r) {
       tree[ind].l = l, tree[ind].r = r;
       if (l == r) {
           tree[ind].max_num = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build_tree(ind * 2, l, mid);
       build_tree(ind * 2 + 1, mid + 1, r);
       update(ind);
       return ;
   }
   
   void modify(int ind, int k, int val) {
       if (tree[ind].l == tree[ind].r) {
           tree[ind].max_num = val;
           return ;
       }
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (k <= mid) {
           modify(ind << 1, k, val);
       } else {
           modify(ind << 1 | 1, k, val);
       }
       update(ind);
       return ;
   }
   
   int query(int ind, int x, int y) {
       if (tree[ind].l >= x && tree[ind].r <= y) {
           return tree[ind].max_num;
       }
       int ans = INT_MIN;
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (mid >= x) {
           ans = max(ans, query(ind << 1, x, y));
       }
       if (mid < y) {
           ans = max(ans, query(ind << 1 | 1, x, y));
       }
       return ans;
   }
   ```

   

   



## 11.3. ä¸‰ã€è¿›é˜¶ç‰ˆçº¿æ®µæ ‘

1. ä¼˜åŒ–æ‰äº†ä»£ç å®ç°ä¸­çš„ï¼šlï¼Œrã€‚åŒºé—´å˜é‡
2. å¯ä»¥ç”¨äºåŒºé—´æ›´æ–°ï¼ŒåŒºé—´æŸ¥è¯¢
3. å¢åŠ äº†æ‡’æ ‡è®°ï¼Œè¾¾åˆ°èƒ½å¤ŸåŒºé—´æ›´æ–°çš„ç›®çš„
4. æ‡’æ ‡è®°æ˜¯éœ€è¦å‘ä¸‹ä¸‹æ²‰çš„
5. æ ‡è®°ä¸‹æ²‰å‘ç”Ÿåœ¨é€’å½’ä¹‹å‰ï¼Œå‘ä¸Šæ›´æ–°å‘ç”Ÿåœ¨å…·æœ‰ä¿®æ”¹æ“ä½œçš„é€’å½’ä¹‹å

```cpp
#define MAX_N 10000
#define define_mid long long mid = (l + r) >> 1

long long flag = 0;
struct {
    long long sum, tag;
} tree[MAX_N << 2];
long long arr[MAX_N + 5];

void update(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    return ;
}

void down(long long ind, long long l, long long r) {
    if (tree[ind].tag) {
        long long val = tree[ind].tag;
        define_mid;
        tree[ind << 1].sum += val * (mid - l + 1);
        tree[ind << 1].tag += val;
        tree[ind << 1 | 1].sum += val * (r - mid);
        tree[ind << 1 | 1].tag += val;
        tree[ind].tag = 0;
    }
    return ;
}

void build_tree(long long ind, long long l, long long r) {
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    define_mid;
    build_tree(ind << 1, l, mid);
    build_tree(ind << 1 | 1, mid + 1, r);
    update(ind);
    return ;
}

void modify(long long ind, long long l, long long r, long long x, long long y, long long val) {
    flag && printf("modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, val, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        tree[ind].sum += val * (r - l + 1);
        tree[ind].tag += val;
        return ;
    }
    down(ind, l, r);
    define_mid;
    if (mid >= x) {
        modify(ind << 1, l, mid, x, y, val);
    }
    if (mid < y) {
        modify(ind << 1 | 1, mid + 1, r, x, y, val);
    }
    update(ind);
    return ;
}

long long query(long long ind, long long l, long long r, long long x, long long y) {
    flag && printf("query(%lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    down(ind, l, r);
    define_mid;
    long long ans = 0;
    if (mid >= x) {
        ans += query(ind << 1, l, mid, x, y);
    }
    if (mid < y) {
        ans += query(ind << 1 | 1, mid + 1, r, x, y);
    }
    return ans;
}

int main() {
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (long long i = 1; i <= n; i++) {
        scanf("%lld", arr + i);
    }
    build_tree(1, 1, n);
    long long a, b, c, d;
    for (long long i = 0; i < m; i++) {
        scanf("%lld%lld%lld", &a, &b, &c);
        switch (a) {
            case 1: {
                scanf("%lld", &d);
                modify(1, 1, n, b, c, d);
            } break;
            case 2: {
                if (b > c) {
                    printf("0\n");
                    break;
                }
                printf("%lld\n", query(1, 1, n, b, c));
            } break;
        }
    }
    return 0;
}
```





```cpp
#define MAX_N 10000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define tag(ind) tree[ind].tag
#define sum(ind) tree[ind].sum
#define cnt(ind) tree[ind].cnt

struct node {
    long long sum, tag, cnt;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 0, cnt = 1;
long long arr[MAX_N + 5];
int getNode() { return cnt++; }

void DOWN(int ind) {
    if (tag(ind)) {
        tag(lc(ind)) += tag(ind);
        tag(rc(ind)) += tag(ind);
        sum(lc(ind)) += tag(ind) * cnt(lc(ind));
        sum(rc(ind)) += tag(ind) * cnt(rc(ind));
        tag(ind) = 0;
    }
    return ;
}

void UP(int ind) {
    tree[ind].sum = tree[lc(ind)].sum + tree[rc(ind)].sum;
}

void build(int ind, int l, int r) {
    tree[ind].cnt = (r - l + 1);
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    tree[ind].lind = getNode();
    tree[ind].rind = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, long long d, int l, int r) {
    if (x <= l && r <= y) {
        tree[ind].tag += d;
        tree[ind].sum += d * tree[ind].cnt;
        return ;
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, d, l, mid);
    if (y > mid) modify(rc(ind), x, y, d, mid + 1, r);
    UP(ind);
    return ;
}

long long query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        return sum(ind);
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    long long ans = 0;
    if (x <= mid) ans += query(lc(ind), x, y, l, mid);
    if (y > mid) ans += query(rc(ind), x, y, mid + 1, r);
    return ans;
}
```





### 11.3.1. HZOJ224 å¤åˆçº¿æ®µæ ‘

```cpp
#define MAX_N 100000
struct Node {
    long long sum, t1, t2;
} tree[(MAX_N << 2) + 5];
long long a[MAX_N + 5];
long long n, m, p;

void mul_tag(long long ind, long long x) {
    tree[ind].sum *= x;
    tree[ind].sum %= p;
    tree[ind].t1 *= x;
    tree[ind].t1 %= p;
    tree[ind].t2 *= x;
    tree[ind].t2 %= p;
    return ;
}

void add_tag(long long ind, long long x, long long n) {
    tree[ind].sum += x * n;
    tree[ind].sum %= p;
    tree[ind].t2 += x;
    tree[ind].t2 %= p;
    return ;
}

void UP(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    tree[ind].sum %= p; 
    return ;
}

void DOWN(long long ind, long long l, long long r) {
    if (tree[ind].t1 - 1 || tree[ind].t2) {
        long long a = tree[ind].t1, b = tree[ind].t2;
        long long mid = (l + r) >> 1;
        mul_tag(ind << 1, a);
        mul_tag(ind << 1 | 1, a);
        add_tag(ind << 1, b, mid - l + 1);
        add_tag(ind << 1 | 1, b, r - mid);
        tree[ind].t1 = 1;
        tree[ind].t2 = 0;
    }
    return ;
}

void build(long long ind, long long l, long long r) {
    tree[ind].t1 = 1; tree[ind].t2 = 0;
    if (l == r) {
        tree[ind].sum = a[l];
        return ;
    }
    long long mid = (l + r) >> 1;
    build(ind << 1, l, mid);
    build(ind << 1 | 1, mid + 1, r);
    UP(ind);
    return ;
}

void modify(long long ind, long long flag, long long x, long long y, long long val, long long l, long long r) {
    if (x <= l && r <= y) {
        if (flag == 0) {
            mul_tag(ind, val);
        } else {
            add_tag(ind, val, r - l + 1);
        }
        return ;
    }
    long long mid = (l + r) >> 1;
    DOWN(ind, l, r);
    if (x <= mid) modify(ind << 1, flag, x, y, val, l, mid);
    if (y > mid) modify(ind << 1 | 1, flag, x, y, val, mid + 1, r);
    UP(ind);
    return ;
}

long long query(long long ind, long long x, long long y, long long l, long long r) {
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    long long mid = (l + r) >> 1;
    long long ans = 0;
    DOWN(ind, l, r);
    if (x <= mid) ans += query(ind << 1, x, y, l, mid);
    ans %= p;
    if (y > mid) ans += query(ind << 1 | 1, x, y, mid + 1, r);
    ans %= p;
    UP(ind);
    return ans;
}

int main() {
    cin >> n >> m >> p;
    for (long long i = 1; i <= n; i++) cin >> a[i];
    build(1, 1, n);
    long long op, x, y, k;
    for (long long i = 0; i < m; i++) {
        cin >> op >> x >> y;
        switch (op) {
            case 1: 
            case 2: {
                cin >> k;
                modify(1, op - 1, x, y, k, 1, n);
            } break;
            case 3: {
                cout << query(1, x, y, 1, n) << endl;
            } break;
        }
    }
    return 0;
}
```





ä¹  é¢˜ ä½œ ä¸š
Luogu P3372 Luogu P3373
Luogu P3924 Luogu P1047
Luogu P1168 Luogu P1204
Luogu P1276 Luogu P1438
Luogu P1442 Luogu P1471
Luogu P1531 Luogu P1533
Luogu P1558 Luogu P1637
Luogu P1816 Luogu P25

# 12. ==äºŒå‰æ’åºæ ‘==



## 12.1. ä¸€ã€æ€§è´¨

1. å·¦å­æ ‘ < æ ¹èŠ‚ç‚¹
2. å³å­æ ‘ > æ ¹èŠ‚ç‚¹
3. ä¸­åºéå†çš„ç»“æœï¼Œæ˜¯ä¸€ä¸ªæœ‰åºåºåˆ—

æ•°æ®ç»“æ„ï¼Œå°±æ˜¯å®šä¹‰ä¸€ç§æ€§è´¨ï¼Œå¹¶ä¸”ç»´æŠ¤è¿™ç§æ€§è´¨ã€‚

1. äºŒå‰æ ‘ä¸­ï¼Œç¬¬ i å±‚æœ€å¤šæœ‰$ 2^{i-1}$ ä¸ªç»“ç‚¹ã€‚
2. å¦‚æœäºŒå‰æ ‘çš„æ·±åº¦ä¸º Kï¼Œé‚£ä¹ˆæ­¤äºŒå‰æ ‘æœ€å¤šæœ‰ $2^K-1$ ä¸ªç»“ç‚¹ã€‚
3. äºŒå‰æ ‘ä¸­ï¼Œç»ˆç«¯ç»“ç‚¹æ•°ï¼ˆå¶å­ç»“ç‚¹æ•°ï¼‰ä¸º n0ï¼Œåº¦ä¸º 2 çš„ç»“ç‚¹æ•°ä¸º n2ï¼Œåˆ™ n0=n2+1

## 12.2. äºŒã€æ’å…¥æ“ä½œ

1. æ’å…¥çš„æ–°èŠ‚ç‚¹ï¼Œä¸€å®šä¼šåšä¸ºå¶å­ç»“ç‚¹



## 12.3. ä¸‰ã€åˆ é™¤æ“ä½œ

1. åˆ é™¤åº¦ä¸º0çš„èŠ‚ç‚¹ï¼Œç›´æ¥åˆ é™¤
2. åˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹ï¼ŒæŠŠã€å­¤å„¿å­æ ‘ã€æŒ‚åˆ°å…¶çˆ¶èŠ‚ç‚¹ä¸Šé¢å»
3. åˆ é™¤åº¦ä¸º2çš„èŠ‚ç‚¹ï¼Œå¯ä»¥è½¬åŒ–æˆåˆ é™¤åº¦ä¸º1çš„èŠ‚ç‚¹



å¯¹äºåº¦ä¸º2çš„èŠ‚ç‚¹ï¼š

1. å‰é©±ï¼šå·¦å­æ ‘æœ€å¤§å€¼
2. åç»§ï¼šå³å­æ ‘æœ€å°å€¼



## 12.4. å››ã€éšå ‚ç»ƒä¹ 

1. æ’å…¥é¡ºåºä¼šå½±å“æœ€ç»ˆçš„æ ‘å½¢ç»“æ„
2. ä¸åŒçš„æ ‘å½¢ç»“æ„ï¼ŒæŸ¥æ‰¾æ•ˆç‡ä¸åŒ



å¹³å‡æŸ¥æ‰¾æ•ˆç‡ï¼šèŠ‚ç‚¹æŸ¥æ‰¾æ¬¡æ•°çš„æœŸæœ›å€¼ï¼Œ$\frac{æ€»æ¬¡æ•°}{èŠ‚ç‚¹æ•°é‡}$ï¼Œå‡è®¾æ¯ä¸ªèŠ‚ç‚¹ç­‰æ¦‚ç‡çš„è¢«æŸ¥æ‰¾



## 12.5. äº”ã€æ‰©å±•å†…å®¹

1. äºŒå‰æ’åºæ ‘çš„åˆ é™¤ä»£ç ä¼˜åŒ–
   1. åˆ é™¤æ‰å¤„ç†åº¦ä¸º0çš„ä»£ç é€»è¾‘ï¼Œä¸å½±å“ä»£ç æ•´ä½“åŠŸèƒ½
2. å¦‚ä½•è§£å†³==æ’å==ç›¸å…³çš„æ£€ç´¢éœ€æ±‚
   1. ä¿®æ”¹äºŒå‰æ’åºæ ‘çš„ç»“æ„å®šä¹‰ï¼Œå¢åŠ  size å­—æ®µï¼Œè®°å½•æ¯æ£µæ ‘çš„èŠ‚ç‚¹æ•°é‡
   2. $k = LS - 1$ï¼Œæ ¹èŠ‚ç‚¹å°±æ˜¯æ’åç¬¬ k ä½çš„å…ƒç´ 
   3. $k \le LS$ï¼Œæ’åç¬¬ k ä½çš„å…ƒç´ åœ¨å·¦å­æ ‘ä¸­
   4. $k \gt LSï¼Œsearch_k(root->rchild, k - LS - 1)$
3. è§£å†³ Top-K é—®é¢˜ï¼ˆæ‰¾åˆ°å°äºç¬¬ k ä½çš„æ‰€æœ‰å…ƒç´ ï¼‰
   1. æ ¹èŠ‚ç‚¹å°±æ˜¯ç¬¬ k ä½å…ƒç´ çš„è¯ï¼Œå°±æŠŠå·¦å­æ ‘ä¸­çš„å€¼å…¨éƒ¨è¾“å‡ºå‡ºæ¥
   2. ç¬¬ k ä½åœ¨å·¦å­æ ‘ä¸­ï¼Œå‰ k ä½å…ƒç´ å…¨éƒ½åœ¨å·¦å­æ ‘ä¸­
   3. ç¬¬ k ä½åœ¨å³å­æ ‘ä¸­ï¼Œè¯´æ˜æ ¹èŠ‚ç‚¹å’Œå·¦å­æ ‘ä¸­çš„å…ƒç´ ï¼Œéƒ½æ˜¯å‰ k ä½å…ƒç´ é‡Œé¢çš„å€¼
4. äºŒå‰æ’åºæ ‘å’Œå¿«é€Ÿæ’åºçš„å…³ç³»
   1. äºŒå‰æ’åºæ ‘æ˜¯å¿«é€Ÿæ’åºåœ¨æ€ç»´é€»è¾‘ç»“æ„å±‚é¢ç”¨çš„æ•°æ®ç»“æ„
   2. æ€è€ƒ1ï¼šå¿«é€Ÿæ’åºçš„æ—¶é—´å¤æ‚åº¦å’ŒäºŒå‰æ’åºæ ‘å»ºæ ‘æ—¶é—´å¤æ‚åº¦ä¹‹é—´çš„å…³ç³»
   3. æ€è€ƒ2ï¼šå¿«é€Ÿé€‰æ‹©ç®—æ³•å’ŒäºŒå‰æ’åºæ ‘ä¹‹é—´çš„å…³ç³»
   4. ç¨‹åº=ç®—æ³•+æ•°æ®ç»“æ„



æ‰€è°“ç®—æ³•è®¾è®¡åŠåˆ†æèƒ½åŠ›ï¼šåˆ†ç±»è®¨è®ºåŠå½’çº³æ€»ç»“çš„èƒ½åŠ›



```cpp
#include <stdio.h>
#include <stdlib.h>
#define KEY(n) (n ? n->key : 0)
#define SIZE(n) (n ? n->size : 0)
#define L(n) (n ? n->lchild : NULL)

typedef struct Node {
    int key, size;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->size = 1;
    p->lchild = p->rchild = NULL;
    return p;
}

void update_size(Node *root) {
    root->size = SIZE(root->lchild) + SIZE(root->rchild) + 1;
    return ;
}

int search(Node *root, int val) {
    if (root == NULL) return 0;
    if (root->key == val) return 1;
    if (val < root->key) return search(root->lchild, val);
    return search(root->rchild, val);
}

int search_k(Node *root, int k) {
    if (root == NULL) return -1;
    if (SIZE(L(root)) == k - 1) return root->key;
    if (k <= SIZE(L(root))) {
        return search_k(root->lchild, k);
    }
    return search_k(root->rchild, k - SIZE(L(root)) - 1);
}

Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    update_size(root);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NULL) return NULL;
    if (key < root->key) {
        root->lchild = erase(root->lchild, key);
    } else if (key > root->key) {
        root->rchild = erase(root->rchild, key);
    } else {
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    update_size(root);
    return root;
}

void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void print(Node *root) {
    printf("(%d[%d], %d, %d)\n", 
           KEY(root), SIZE(root), 
           KEY(root->lchild), KEY(root->rchild)
    );
    return ;
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    print(root);
    output(root->rchild);
    return ;
}

void output_k(Node *root, int k) {
    if (k == 0 || root == NULL) return ;
    if (k <= SIZE(L(root))) {
        output_k(root->lchild, k);
    } else {
        output(root->lchild);
        print(root);
        output_k(root->rchild, k - SIZE(L(root)) - 1);
    }
    return ;
}

int main() {
    int op, val;
    Node *root =  NULL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 0: printf("search %d, result : %d\n", val, search(root, val)); break;
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
            case 3: {
                printf("search k = %d, result : %d\n", 
                    val, search_k(root, val)); 
            } break;
            case 4: { 
                printf("output top-%d elements\n", val);
                output_k(root, val); 
                printf("------------\n");
            } break;
        }
        if (op == 1 || op == 2) {
            output(root);
            printf("------------\n");
        }
    }
    return 0;
}
```





Leetcode 110
Leetcode 669



# 13. ==AVL æ ‘==

- å­¦ä¹ é‡ç‚¹

1. å¹³è¡¡äºŒå‰æ ‘æ’åºæ ‘ï¼Œæœ¬è´¨ä¸Šä¹Ÿæ˜¯äºŒå‰æ’åºæ ‘ï¼Œæ‰€ä»¥æ‹¥æœ‰äºŒå‰æ’åºæ ‘çš„æ‰€æœ‰æ€§è´¨
2. å¹³è¡¡äºŒå‰æ ‘æ’åºæ ‘çš„å­¦ä¹ é‡ç‚¹ï¼Œåœ¨äºå¹³è¡¡æ¡ä»¶ä»¥åŠå¹³è¡¡è°ƒæ•´çš„ç›¸å…³å­¦ä¹ 



## 13.1. äºŒã€æ€§è´¨

1. å¹³è¡¡æ¡ä»¶ï¼šå·¦å³å­æ ‘é«˜åº¦å·®ä¸è¶…è¿‡ 1

2. AVL æ ‘æ”¹è¿›çš„æ˜¯èŠ‚ç‚¹æ•°é‡çš„ä¸‹é™

   $ H \le SIZE(H) \le 2^H - 1 $

   $low(H - 2) + low(H - 1) + 1 \le SIZE(H) \le 2^H - 1$

   $low(1) =  1, low(2) = 2, low(3) = 4, low(4)  = 7, æ–æ³¢é‚£å¥‘æ•°åˆ—:1.618^n$



## 13.2. å››ã€å¹³è¡¡è°ƒæ•´ç­–ç•¥

1. å‘ç”Ÿåœ¨å›æº¯é˜¶æ®µçš„ï¼Œç¬¬ä¸€ä¸ªå¤±è¡¡èŠ‚ç‚¹å¤„
2. ç†è§£å¹³è¡¡è°ƒæ•´ç­–ç•¥çš„å…³é”®åœ¨äºï¼šåˆ†ææ¸…æ¥šå››ç§æƒ…å†µä¸‹ï¼ŒABCD å››æ£µå­æ ‘æ ‘é«˜çš„å…³ç³»
3. LLï¼Œå¤§å³æ—‹
4. LRï¼Œå…ˆå°å·¦æ—‹ï¼Œå†å¤§å³æ—‹
5. RLï¼Œå…ˆå°å³æ—‹ï¼Œå†å¤§å·¦æ—‹
6. RRï¼Œå¤§å·¦æ—‹

![image-20210205152153712](/Image/A1.Data_Structure-photo/image-20210205152153712.png)

![image-20210205152314037](/Image/A1.Data_Structure-photo/image-20210205152314037.png)



## 13.3. äº”ã€ä»£ç æ¼”ç¤º

1. æ’å…¥å’Œåˆ é™¤ä»¥åï¼Œæ³¨æ„é‡æ–°è®¡ç®—æ ‘é«˜å­—æ®µ
2. å¼•å…¥äº† NIL é˜¶æ®µï¼Œä»£æ›¿ NULLï¼ŒNULL ä¸å¯è®¿é—®ï¼ŒNIL æ˜¯ä¸€ä¸ªæ˜¯å®é™…èŠ‚ç‚¹ï¼Œå¯è®¿é—®



```cpp
#define H(root) (root)->h
#define K(root) (root)->key
#define L(root) (root)->lchild
#define R(root) (root)->rchild

typedef struct Node {
    int key, h;
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {
    NIL->key = NIL->h = 0;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->h = 1;
    p->lchild = p->rchild = NIL;
    return p;
}

void update_height(Node *root) {
    root->h = (H(L(root)) > H(R(root)) ? H(L(root)) : H(R(root))) + 1;
    return ;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *maintain(Node *root) {
    if (abs(H(L(root)) - H(R(root))) <= 1) return root;
    if (H(L(root)) > H(R(root))) {
        if (H(R(L(root))) > H(L(L(root)))) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (H(L(R(root))) > H(R(R(root)))) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    return root;
}

Node *insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    update_height(root);
    return maintain(root);
}

Node *predeccessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) {
        root->lchild = erase(root->lchild, key);
    } else if (root->key < key) {
        root->rchild = erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return maintain(root);
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("(%d, %d, %d)\n", K(root), K(L(root)), K(R(root)));
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    #define MAX_OP 20
    Node *root = NIL;
    for (int i = 0; i < MAX_OP; i++) {
        int val = rand() % 100;
        root = insert(root, val);
    }
    output(root);
    int val;
    while (~scanf("%d", &val)) {
        root = erase(root, val);
        printf("erase %d from AVL tree\n", val);
        output(root);
    }
    return 0;
}
```





# 14. SBæ ‘

SB æ ‘ :åç§°:Size Balanced æ ‘

æ¯æ£µå­æ ‘çš„å¤§å°ä¸å°äºå…¶å…„å¼Ÿçš„å­æ ‘å¤§å°

æ€§è´¨:
	Size(left) >= Size(right->left)
	Size(left) >= Size(right->right)
	Size(right) >= Size(left->left)
	Size(right) >= Size(left->right)
ä¼˜ç‚¹:
ç”±äºå¯¹æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„èŠ‚ç‚¹æ•°é‡åšäº†é™åˆ¶,æ‰€ä»¥æ•´æ£µæ ‘ä¸ä¼šé€€åŒ–æˆä¸€ä¸ªé“¾è¡¨

![image-20210205152513580](/Image/A1.Data_Structure-photo/image-20210205152513580.png)

æ€è€ƒ:
1ã€é«˜åº¦ä¸º H çš„ BS æ ‘,æ‰€åŒ…å«çš„èŠ‚ç‚¹æ•°é‡åœ¨ä»€ä¹ˆèŒƒå›´ä¹‹å†…?
2ã€é«˜åº¦ä¸º H çš„ SB æ ‘,æ‰€åŒ…å«çš„èŠ‚ç‚¹æ•°é‡åœ¨ä»€ä¹ˆèŒƒå›´ä¹‹å†…?


ï¼­aintain (T) ç”¨äºä¿®å¤ä»¥ T ä¸ºæ ¹çš„ SBT ã€‚ç”±äºæ€§è´¨(a)å’Œ(b)æ˜¯å¯¹ç§°çš„ï¼Œä¸‹é¢ä»…è®¨è®ºå¯¹æ€§è´¨(a)çš„ä¿®å¤ã€‚

### 14.0.1. Case 1: s[ Left[ Left[ T ] ]>s[ Right[ T ] ] 

åœ¨ä¸‹å›¾ä¸­ï¼Œå°±æ˜¯è¯´ s[A]>s[R]

![img](/Image/A1.Data_Structure-photo/20131129202211734)

é¦–å…ˆæ‰§è¡Œå³æ—‹ï¼ˆRight-Rotate (T)ï¼‰å¯å¾—

![img](/Image/A1.Data_Structure-photo/20131129203355843)

æœ‰å¯èƒ½æ—‹è½¬åçš„æ ‘ä»ç„¶ä¸æ˜¯SBT,éœ€è¦å†æ¬¡æ‰§è¡ŒMaintain(T)

ç”±äºLçš„å³å„¿å­å‘ç”Ÿäº†å˜åŒ–ï¼Œå› æ­¤éœ€è¦æ‰§è¡ŒMaintain(L)

ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ç§æƒ…å†µå…ˆæ‰§è¡Œä¸€æ¬¡Right-Rotate (T)ï¼Œæ¥ç€æ‰§è¡ŒMaintain (T) ä¿è¯Tä¸ºSBTï¼Œç„¶åæ‰§è¡ŒMaintain(L)ï¼Œä¿è¯Lä¸ºSBT

### 14.0.2. Case 2: s[ right[ left[ t ] ]>s[ right[ t ] ]  

åœ¨ä¸‹å›¾ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´ s[B]>s[R]

![img](/Image/A1.Data_Structure-photo/20131129203745125)

å…ˆæ‰§è¡Œå·¦æ—‹Left-Rotate(L)ã€‚å¦‚ä¸‹å›¾

![img](/Image/A1.Data_Structure-photo/20131129203857906)

æ‰§è¡Œå³æ—‹Right-Rotate(T)ï¼Œå¦‚ä¸‹å›¾ï¼š

![img](/Image/A1.Data_Structure-photo/20131129203924718)

æ¥ç€æ‰§è¡ŒMaintain (L) å’ŒMaintain (T)ï¼Œæ¥ä¿è¯Lå’ŒTæ˜¯SBT

åŒç†æ‰§è¡ŒMaintain (B)



# 15. ==çº¢é»‘æ ‘ï¼ˆä¸Šï¼‰==

## 15.1. ä¸€ã€å¹³è¡¡æ¡ä»¶

1. èŠ‚ç‚¹éé»‘æ—¢çº¢
2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²
3. å¶å­ï¼ˆNILï¼‰ç»“ç‚¹æ˜¯é»‘è‰²
4. çº¢è‰²èŠ‚ç‚¹ä¸‹é¢æ¥ä¸¤ä¸ªé»‘è‰²èŠ‚ç‚¹
5. ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹è·¯å¾„ä¸Šï¼Œé»‘è‰²èŠ‚ç‚¹æ•°é‡ç›¸åŒ



### 15.1.1. å¹³è¡¡æ¡ä»¶çš„è®¤è¯†

ç¬¬4æ¡å’Œç¬¬5æ¡æ¡ä»¶ï¼Œæ³¨å®šäº†ï¼Œçº¢é»‘æ ‘ä¸­æœ€é•¿è·¯å¾„æ˜¯æœ€çŸ­è·¯å¾„çš„é•¿åº¦çš„ 2 å€ã€‚

æœ¬è´¨ä¸Šï¼Œçº¢é»‘æ ‘ä¹Ÿæ˜¯é€šè¿‡æ ‘é«˜æ¥æ§åˆ¶å¹³è¡¡çš„ã€‚

çº¢é»‘æ ‘æ¯” AVL æ ‘æ ‘é«˜æ§åˆ¶æ¡ä»¶è¦æ›´æ¾æ•£ï¼Œçº¢é»‘æ ‘åœ¨å‘ç”ŸèŠ‚ç‚¹æ’å…¥å’Œåˆ é™¤ä»¥åï¼Œå‘ç”Ÿè°ƒæ•´çš„æ¦‚ç‡ï¼Œæ¯” AVL æ ‘è¦æ›´å°ã€‚



## 15.2. äºŒã€å­¦ä¹ è¯€çª

1. ç†è§£çº¢é»‘æ ‘çš„æ’å…¥è°ƒæ•´ï¼Œè¦ç«™åœ¨==ç¥–çˆ¶èŠ‚ç‚¹==å‘ä¸‹è¿›è¡Œè°ƒæ•´
2. ç†è§£çº¢é»‘æ ‘çš„åˆ é™¤è°ƒæ•´ï¼Œè¦ç«™åœ¨==çˆ¶èŠ‚ç‚¹==å‘ä¸‹è¿›è¡Œè°ƒæ•´
3. æ’å…¥è°ƒæ•´ï¼Œä¸»è¦å°±æ˜¯ä¸ºäº†è§£å†³åŒçº¢æƒ…å†µ
4. æ–°æ’å…¥çš„èŠ‚ç‚¹ä¸€å®šæ˜¯çº¢è‰²ï¼Œæ’å…¥é»‘è‰²èŠ‚ç‚¹ä¸€å®šä¼šäº§ç”Ÿå†²çªï¼Œè¿åæ¡ä»¶5ï¼Œæ’å…¥çº¢è‰²èŠ‚ç‚¹ï¼Œä¸ä¸€å®šäº§ç”Ÿå†²çª
5. æŠŠæ¯ä¸€ç§æƒ…å†µï¼Œæƒ³è±¡æˆä¸€æ£µå¤§çš„çº¢é»‘æ ‘ä¸­çš„å±€éƒ¨å­æ ‘
6. å±€éƒ¨è°ƒæ•´çš„æ—¶å€™ï¼Œä¸ºäº†ä¸å½±å“å…¨å±€ï¼Œè°ƒæ•´å‰åçš„è·¯å¾„ä¸Šé»‘è‰²èŠ‚ç‚¹æ•°é‡ç›¸åŒ



## 15.3. ä¸‰ã€æ’å…¥ç­–ç•¥

1. å”å”èŠ‚ç‚¹ä¸ºçº¢è‰²çš„æ—¶å€™ï¼Œä¿®æ”¹ä¸‰å…ƒç»„å°å¸½å­ï¼Œæ”¹æˆçº¢é»‘é»‘
2. å”å”èŠ‚ç‚¹ä¸ºé»‘è‰²çš„æ—¶å€™ï¼Œå‚è€ƒ AVL æ ‘çš„å¤±è¡¡æƒ…å†µï¼Œåˆ†æˆ $LL,LR,RL,RR$, å…ˆå‚è€ƒ AVL æ ‘çš„æ—‹è½¬è°ƒæ•´ç­–ç•¥ï¼Œç„¶åå†ä¿®æ”¹ä¸‰å…ƒç»„çš„é¢œè‰²ï¼Œæœ‰ä¸¤ç§è°ƒæ•´ç­–ç•¥ï¼šçº¢è‰²ä¸Šæµ®ï¼Œçº¢è‰²ä¸‹æ²‰ã€‚
3. ä¸¤å¤§ç±»æƒ…å†µï¼ŒåŒ…å« 8 ç§å°æƒ…å†µ

![image-20210204204513136](/Image/A1.Data_Structure-photo/image-20210204204513136.png)

å¤„ç†åŠæ³•:1å’Œ20ä¿®æ”¹æˆé»‘è‰²,15ä¿®æ”¹æˆçº¢è‰²(æ‰€è°“çš„çº¢è‰²ä¸Šé¡¶)

![image-20210204204553104](/Image/A1.Data_Structure-photo/image-20210204204553104.png)

å¤„ç†ç†åŠæ³•:å¤§å³(å·¦)æ—‹,20è°ƒæ•´æˆçº¢è‰²,15è°ƒæ•´æˆé»‘è‰²,å³å¯æå®šé—®é¢˜

åªæœ‰17ä¸ç¡®å®š

å…¶ä½™æƒ…å†µå‡å¯ä»¥è°ƒæ•´æˆä¸ºæƒ…å†µäºŒå¯å¤„ç†ç†çš„æƒ…å†µ,æ‰€ä»¥å°±ä¸å•ç‹¬è®¨è®ºäº†ã€‚



## 15.4. å››ã€ä»£ç æ¼”ç¤º

1. æ’å…¥è°ƒæ•´ï¼Œå‘æ­£åœ¨é€’å½’çš„å›æº¯é˜¶æ®µ
2. æ’å…¥è°ƒæ•´ä»£ç ä¸­ï¼Œä½¿ç”¨ goto è¯­å¥ï¼Œ8è¡Œä»£ç ï¼Œå˜æˆäº†4è¡Œ
3. å¤„ç†æ ¹èŠ‚ç‚¹ä¸€å®šæ˜¯é»‘è‰²ï¼Œé€šè¿‡ä»£ç å°è£…ï¼Œ$insert->\_\_insert$



# 16. ==çº¢é»‘æ ‘ï¼ˆä¸‹ï¼‰==

## 16.1. ä¸€ã€åˆ é™¤è°ƒæ•´å‘ç”Ÿçš„å‰æ

1. åˆ é™¤çº¢è‰²èŠ‚ç‚¹ï¼Œä¸ä¼šå¯¹çº¢é»‘æ ‘çš„å¹³è¡¡äº§ç”Ÿå½±å“
2. åº¦ä¸º1çš„é»‘è‰²èŠ‚ç‚¹ï¼Œå”¯ä¸€å­å­©å­ï¼Œä¸€å®šæ˜¯çº¢è‰²
3. åˆ é™¤åº¦ä¸º1çš„é»‘è‰²èŠ‚ç‚¹ï¼Œä¸ä¼šäº§ç”Ÿåˆ é™¤è°ƒæ•´
4. åˆ é™¤åº¦ä¸º0çš„é»‘è‰²èŠ‚ç‚¹ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªåŒé‡é»‘çš„ NIL èŠ‚ç‚¹
5. åˆ é™¤è°ƒæ•´ï¼Œå°±æ˜¯ä¸ºäº†å¹²æ‰åŒé‡é»‘ï¼ˆé»‘è‰²ä¸Šæµ®ï¼‰



## 16.2. äºŒã€åˆ é™¤è°ƒæ•´

1. åŒé‡é»‘èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œå…„å¼ŸèŠ‚ç‚¹ä¸‹é¢çš„ä¸¤ä¸ªå­èŠ‚ç‚¹ä¹Ÿæ˜¯é»‘è‰²ï¼Œçˆ¶èŠ‚ç‚¹å¢åŠ ä¸€é‡é»‘è‰²ï¼ŒåŒé‡é»‘ä¸å…„å¼ŸèŠ‚ç‚¹ï¼Œåˆ†åˆ«å‡å°‘ä¸€é‡é»‘è‰²ã€‚

2. å…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²ï¼Œå¹¶ä¸”ï¼Œå…„å¼ŸèŠ‚ç‚¹ä¸­æœ‰çº¢è‰²å­èŠ‚ç‚¹
   1. Rï¼ˆå…„å¼Ÿï¼‰Rï¼ˆå³å­èŠ‚ç‚¹ï¼‰ï¼Œå·¦æ—‹ï¼Œæ–°æ ¹æ”¹æˆåŸæ ¹çš„é¢œè‰²ï¼Œå°†æ–°æ ¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæ”¹æˆé»‘è‰²
   2. Rï¼ˆå…„å¼Ÿï¼‰Lï¼ˆå·¦å­èŠ‚ç‚¹ï¼‰ï¼Œå…ˆå°å³æ—‹ï¼Œå¯¹è°ƒæ–°æ ¹ä¸åŸæ ¹çš„é¢œè‰²ï¼Œè½¬æˆä¸Šä¸€ç§æƒ…å†µ
   3. LL åŒç† RR
   4. LR åŒç† RL

3. å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰²ï¼Œé€šè¿‡æ—‹è½¬ï¼Œè½¬å˜æˆå…„å¼ŸèŠ‚ç‚¹æ˜¯é»‘è‰²çš„æƒ…å†µ

![image-20210204204629813](/Image/A1.Data_Structure-photo/image-20210204204629813.png)

å¤„ç†åŠæ³•:brother è°ƒæ•´ä¸ºçº¢è‰²,x å‡å°‘ä¸€é‡é»‘è‰²,father å¢åŠ ä¸€é‡é»‘è‰²

é»‘è‰²ä¸Šæµ®ï¼šæ ¹èŠ‚ç‚¹ç›´æ¥å¹²æ‰

![image-20210204204703406](/Image/A1.Data_Structure-photo/image-20210204204703406.png)

![image-20210204230645450](/Image/A1.Data_Structure-photo/image-20210204230645450.png)

å¤„ç†åŠæ³•:brother å³(å·¦)æ—‹,51å˜é»‘,72å˜çº¢,è½¬æˆå¤„ç†æƒ…å†µä¸‰

![image-20210204204736229](/Image/A1.Data_Structure-photo/image-20210204204736229.png)

![image-20210204230035628](/Image/A1.Data_Structure-photo/image-20210204230035628.png)

å¤„ç†åŠæ³•:father å·¦(å³)æ—‹,ç”±äºæ— æ³•ç¡®å®š48çš„é¢œè‰²,æ‰€ä»¥38æ”¹æˆé»‘è‰²,51æ”¹æˆ38çš„é¢œè‰²,x å‡å°‘
ä¸€é‡é»‘è‰²,72æ”¹æˆé»‘è‰²

28ï¼Œ72ï¼Œ64ï¼Œ85ç¡®å®š

![image-20210204231107195](/Image/A1.Data_Structure-photo/image-20210204231107195.png)

å…„å¼ŸèŠ‚ç‚¹æ˜¯çº¢è‰²æƒ…å†µï¼šå·¦(å³)æ—‹ï¼Œæ–°æ ¹å˜é»‘ï¼Œæ—§æ ¹å˜çº¢

## 16.3. ä¸‰ã€ä»£ç æ¼”ç¤º

1. è¿›è¡Œ LR/RL ç±»å‹åˆ¤æ–­çš„æ—¶å€™ï¼Œä¸èƒ½åˆ¤æ–­ LL å­æ ‘æ˜¯å¦ä¸ºé»‘è‰²ï¼ŒLL å­æ ‘æœ‰å¯èƒ½æ˜¯ NIL èŠ‚ç‚¹ï¼Œåœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œè¯»åˆ°çš„é¢œè‰²å¯èƒ½æ˜¯åŒé‡é»‘ï¼Œå–è€Œä»£ä¹‹çš„åˆ¤æ–­æ–¹æ³•å°±æ˜¯ã€LL å­æ ‘ä¸æ˜¯çº¢è‰²ã€‘ã€‚

![image-20210205001401045](/Image/A1.Data_Structure-photo/image-20210205001401045.png)

ç©ºå¿ƒä»£è¡¨çº¢è‰²ï¼š==RED:LR 		!=RED:LL

![image-20210204235441764](/Image/A1.Data_Structure-photo/image-20210204235441764.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#define RED 0
#define BLACK 1
#define DOUBLE_BLACK 2

typedef struct Node {
    int key, color; // 0 red, 1 black, 2 double black
    struct Node *lchild, *rchild;
} Node;

Node _NIL, * const NIL = &_NIL;

__attribute__((constructor))
void init_NIL() {
    NIL->key = 0;
    NIL->lchild = NIL->rchild = NIL;
    NIL->color = BLACK;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NIL;
    p->color = RED;
    return p;
}

int hasRedChild(Node *root) {
    return root->lchild->color == RED || root->rchild->color == RED;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}

Node *insert_maintain(Node *root) {
    if (!hasRedChild(root)) return root;
    if (root->lchild->color == RED && root->rchild->color == RED) {
        if (!hasRedChild(root->lchild) && !hasRedChild(root->rchild)) return root;
        goto insert_end;
    }
    if (root->lchild->color == RED) {
        if (!hasRedChild(root->lchild)) return root;
        if (root->lchild->rchild->color == RED) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (!hasRedChild(root->rchild)) return root;
        if (root->rchild->lchild->color == RED) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
insert_end:
    root->color = RED;
    root->lchild->color = root->rchild->color = BLACK;
    return root;
}

Node *__insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) root->lchild = __insert(root->lchild, key);
    else root->rchild = __insert(root->rchild, key);
    return insert_maintain(root);
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = BLACK;
    return root;
}

Node *predeccessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
    if (root->lchild->color != DOUBLE_BLACK && root->rchild->color != DOUBLE_BLACK) return root;
    if (root->rchild->color == DOUBLE_BLACK) {
        if (root->lchild->color == RED) {
            root->color = RED;
            root->lchild->color = BLACK;
            root = right_rotate(root);
            root->rchild = erase_maintain(root->rchild);
            return root;
        }
        if (!hasRedChild(root->lchild)) {
            root->color += 1;
            root->lchild->color -= 1;
            root->rchild->color -= 1;
            return root;
        }
        if (root->lchild->lchild->color != RED) {
            root->lchild->rchild->color = BLACK;
            root->lchild->color = RED;
            root->lchild = left_rotate(root->lchild);
        }
        root->lchild->color = root->color;
        root->rchild->color -= 1;
        root = right_rotate(root);
        root->lchild->color = root->rchild->color = BLACK;
    } else {
        if (root->rchild->color == RED) {
            root->color = RED;
            root->rchild->color = BLACK;
            root = left_rotate(root);
            root->lchild = erase_maintain(root->lchild);
            return root;
        }
        if (!hasRedChild(root->rchild)) {
            root->color += 1;
            root->lchild->color -= 1;
            root->rchild->color -= 1;
            return root;
        }
        if (root->rchild->rchild->color != RED) {
            root->rchild->lchild->color = BLACK;
            root->rchild->color = RED;
            root->rchild = right_rotate(root->rchild);
        }
        root->rchild->color = root->color;
        root->lchild->color -= 1;
        root = left_rotate(root);
        root->lchild->color = root->rchild->color = BLACK;
    }
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) {
        root->lchild = __erase(root->lchild, key);
    } else if (root->key < key) {
        root->rchild = __erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            temp->color += root->color;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->lchild = __erase(root->lchild, temp->key);
        }
    }
    return erase_maintain(root);
}

Node *erase(Node *root, int key) {
    root = __erase(root, key);
    root->color = BLACK;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("%d [%d, %d] %s\n", 
        root->key, 
        root->lchild->key, 
        root->rchild->key,
        root->color ? "BLACK" : "RED"
    );
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
        }
        output(root);
    }
    return 0;
}

```

