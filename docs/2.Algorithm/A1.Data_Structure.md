---
id : A1.DataStructure
title : A1.DataStructure
typora-root-url : ../
---

# 数据结构和算法



# 1. ==栈和队列==

#### 1.0.0.1. hzoj-372-双生队列

**RMQ ( Range Minimum / Maximum Query ) 问题**是指：对于长度为 n 的数列 A，回答若干询问 RMQ (A , i , j ) ( i , j ≤ n)，返回数列A中下标在 i , j 里的**最小（大）值**，也就是说，RMQ问题是指求**区间最值**的问题。

单调队列解决固定末尾ＲＭＱ问题

```c
int a[MAX_N + 5], b[MAX_N + 5];
int main() {
    int n, p = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    int top1 = -1, top2 = -1;
    while (p < n) {
        while (top1 != -1 && a[p] < a[top1]) --top1;
        while (top2 != -1 && b[p] < b[top2]) --top2;
        a[++top1] = a[p];
        b[++top2] = b[p];
        p += 1;
    }
    cout << p << endl;
    return 0;
}

```

#### 1.0.0.2. leetcode-20-括号匹配

```c
 bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }
        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
```

```c
bool isValid(char * s){
    int len = strlen(s);
    char*stack = (char *)malloc(sizeof(char) * len);
    int top = -1, flag = 1;
    for (int i = 0; i < len; ++i) {
        switch (s[i]) {
            case '(' : 
            case '[' : 
            case '{' : 
                stack[++top] = s[i]; 
                break;
            case ')' :
                flag = (top != -1 && stack[top--] == '(' );
                break;
            case ']' :
                flag = (top != -1 && stack[top--] == '[' );
                break;
            case '}' :
                flag = (top != -1 && stack[top--] == '{');
                break;
        }
        if (!flag) return false;
    }
    return top == -1;
}
```

#### 1.0.0.3. LC-221-最大正方形-dp,单调栈

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
};


int maximalSquare(char** matrix, int matrixRowSize, int matrixColSizes) {
    int n = matrixRowSize, m = matrixColSizes;
    if (n == 0) return 0;
    int **cnt = (int **)malloc(sizeof(int *) * n);
    int *q = (int *)malloc(sizeof(int) * m);
    int head, tail, l;
    for (int i = 0; i < n; i++) cnt[i] = (int *)malloc(sizeof(int) * m);
    for (int i = 0; i < m; i++) cnt[0][i] = (matrix[0][i] == '1');
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cnt[i][j] = (matrix[i][j] == '1' ? cnt[i - 1][j] + 1 : 0);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        head = tail = 0;
        l = 0;
        for (int j = 0; j < m; j++) {
            while (tail - head > 0 && cnt[i][q[tail - 1]] > cnt[i][j]) --tail;
            q[tail++] = j;       
            while (j - l >= 0 && j - l + 1 > cnt[i][q[head]]) {
                ++l;
                if (q[head] < l) ++head;
            }
            ans = fmax(ans, (j - l + 1) * (j - l + 1));    
        }
    }
    for (int i = 0; i < n; i++) free(cnt[i]);
    free(cnt);
    free(q);
    return ans;
}
```

#### 1.0.0.4. LC-42-接雨水-单调栈

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> stk;
        int ans = 0;
        for (int i = 0; i < height.size(); ++i) {
            while (!stk.empty() && height[stk.top()] <= height[i]) {
                int cur = stk.top();
                stk.pop();
                if (stk.empty()) break;
                int width = i - stk.top() - 1;
                int h = min(height[i], height[stk.top()]) - height[cur];
                ans += width * h;
            } 
            stk.push(i);
        }
        return ans;
    }
};
```

#### 1.0.0.5. LC-102-层序遍历

#### 1.0.0.6. 示例：

二叉树：[3,9,20,null,null,15,7],

​    3
   / \
  9  20
​    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]

```cpp
int getDepth(struct TreeNode *root) {
    if (root == NULL) return 0;
    int l = getDepth(root->left), r = getDepth(root->right);
    return (l > r ? l : r) + 1;
}

void getCnt(struct TreeNode *root, int k, int *cnt) {
    if (root == NULL) return ;
    cnt[k] += 1;
    getCnt(root->left, k + 1, cnt);
    getCnt(root->right, k + 1, cnt);
    return ;
}

void getResult(struct TreeNode *root, int k, int *cnt, int **ret) {
    if (root == NULL) return ;
    ret[k][cnt[k]++] = root->val;
    getResult(root->left, k + 1, cnt, ret);
    getResult(root->right, k + 1, cnt, ret);
    return ;
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** columnSizes) {
    int depth = getDepth(root);
    int *cnt = (int *)calloc(sizeof(int), depth);
    int **ret = (int **)malloc(sizeof(int *) * depth);
    getCnt(root, 0, cnt);
    for (int i = 0; i < depth; i++) {
        ret[i] = (int *)malloc(sizeof(int) * cnt[i]);
        cnt[i] = 0;
    }
    getResult(root, 0, cnt, ret);
    *returnSize = depth;
    *columnSizes = cnt;
    return ret;
}
```

#### 1.0.0.7. 判平衡二叉树

```c
int maxDepth(struct TreeNode* root) {
    if (root == NULL) return 0;
    int d1 = maxDepth(root->left);
    int d2 = maxDepth(root->right);
    if (d1 == -2 || d2 == -2 || abs(d1 - d2) > 1) return -2;
    return fmax(d1, d2) + 1;
}

bool isBalanced(struct TreeNode* root) {
    return maxDepth(root) >= 0;
```

#### 1.0.0.8. 求路径和

```c
bool hasPathSum(struct TreeNode* root, int sum) {
    if (root == NULL) return false;
    if (root->left == 0 && root->right == NULL) return root->val == sum;
    return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
}
```

#### 1.0.0.9. 最近公共祖先

```c
struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL || root == p || root == q) {
        return root;
    }
    struct TreeNode *left = lowestCommonAncestor(root->left, p, q);
    struct TreeNode *right = lowestCommonAncestor(root->right, p, q);
    if (left && right) {
        return root;
    }
    return left ? left : right;
}
```

#### 1.0.0.10. 二叉排序搜索树

```cpp
struct TreeNode* __lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root->val == p->val) return p;
    if (root->val == q->val) return q;
    if (p->val < root->val && q->val > root->val) return root;
    if (p->val > root->val) return __lowestCommonAncestor(root->right, p, q);
    return __lowestCommonAncestor(root->left, p, q);
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    if (root == NULL) return NULL;
    if (p->val == q->val) return p;
    if (p->val > q->val) {
        struct TreeNode *temp = p;
        p = q;
        q = temp;
    }
    return __lowestCommonAncestor(root, p, q);
}
```



#### 1.0.0.11. 二叉树所有路径-haffman树

```c
int getPathCnt(struct TreeNode *root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return 1;
    return getPathCnt(root->left) + getPathCnt(root->right);
}

int getResult(struct TreeNode *root, int len, int k, char **ret, char *buff) {
    if (root == NULL) return 0;
    len += sprintf(buff + len, "%d", root->val);
    buff[len] = 0;
    if (root->left == NULL && root->right == NULL) {
        ret[k] = strdup(buff);
        return 1;
    }
    len += sprintf(buff + len, "->");
    int cnt = getResult(root->left, len, k, ret, buff);
    cnt += getResult(root->right, len, k + cnt, ret, buff);
    return cnt;
}

char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    int pathCnt = getPathCnt(root);
    char **ret = (char **)malloc(sizeof(char *) * pathCnt);
    int max_len = 10000;
    char *buff = (char *)malloc(sizeof(char) * max_len);
    getResult(root, 0, 0, ret, buff);
    free(buff);
    *returnSize = pathCnt;
    return ret;
}
```



#### 1.0.0.12. 广义表转二叉树

```cpp
Node *build(char *str, int *node_num) {
    Node *temp = NULL, *p = NULL;
    Stack *s = init_stack(strlen(str));
    int flag = 0;
    while (str[0]) {
        switch (str[0]) {
            case '(':
                push(s, temp);
                flag = 0;
                temp = NULL;
                break;
            case ')':
                p = top(s);
                pop(s);
                break;
            case ',':
                flag = 1;
                temp = NULL;
                break;
            case ' ':
                break;
            default:
                temp = getNewNode(str[0]);
                if (!empty(s) && flag == 0) {
                    top(s)->lchild = temp;
                } else if (!empty(s) && flag == 1) {
                    top(s)->rchild = temp;
                }
                ++(*node_num);
            break;
        }
        ++str;
    }
    clear_stack(s);
    if (temp && !p) p = temp;
    return p;
}

```

#### 1.0.0.13. 二叉树中序线索化

```cpp
void build_thread(Node *root) {
    if (root == NULL) return ;
    static Node *pre = NULL;
    build_thread(root->lchild);
    if (root->lchild == NULL) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    if (pre != NULL && pre->rchild == NULL) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    build_thread(root->rchild);
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == NORMAL) clear(root->lchild);
    if (root->rtag == NORMAL) clear(root->rchild);
    free(root);
    return ;
}

Node *leftMost(Node *p) {
    while (p && p->ltag == NORMAL && p->lchild) p = p->lchild;
    return p;
}

void output(Node *root) {
    Node *p = leftMost(root);
    while (p) {
        printf("%d ", p->key);
        if (p->rtag == THREAD) {
            p = p->rchild;
        } else {
            p = leftMost(p->rchild);
        }
    }
    printf("\n");
    return ;
}
```

#### 1.0.0.14. 二叉树先序线索化

```cpp
void buildThead(Node *root) {
    if (!root) return ;
    static Node *pre = nullptr;
    if (root->lchild == nullptr) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    
    if (pre != nullptr && pre->rchild == nullptr) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    if (root->ltag == NORMAL) buildThead(root->lchild);
    if (root->rtag == NORMAL) buildThead(root->rchild);
    return ;
}

void clear(Node *root) {
    if (!root) return ;
    if (root->ltag == NORMAL) clear(root->lchild);
    if (root->rtag == NORMAL) clear(root->rchild);
    free(root);
    return ;
}

Node *leftMost(Node *p) {
    while (p && p->ltag == NORMAL && p->lchild) p = p->lchild;
    return p;
}

void output(Node *root) {
    if (!root) return ;
    //Node *p = leftMost(root);
    Node *p = root;
    while (p) {
        printf("%d ", p->key);
        if (p->ltag == NORMAL) {
            p = p->lchild;
        } else {
            p = p->rchild;
        }
    }
    printf("\n");
    return ;
}

```

#### 1.0.0.15. morris遍历

```cpp
void morrisPre(Node *root) {
    if (!root) return ;
    Node *cur = root, *mostRight = nullptr;
    while (cur) {
        mostRight = cur->lchild;
        if (mostRight) {
            while (mostRight->rchild && mostRight->rchild != cur) {
                mostRight = mostRight->rchild;
            }
            if (mostRight->rchild == nullptr) {
                mostRight->rchild = cur;
                cout << cur->key << " ";
                cur = cur->lchild;
                continue;
            } else {
                mostRight->rchild =nullptr;
            }
        } else {
            cout << cur->key << " ";
        }
        cur = cur->rchild;
    }
    cout << endl;
}

void morrisIn(Node *root) {
    if (!root) return ;
    Node *cur = root, *mostRight = nullptr;
    while (cur) {
        mostRight = cur->lchild;
        if (mostRight) {
            while (mostRight->rchild && mostRight->rchild != cur) {
                mostRight = mostRight->rchild;
            }
            if (mostRight->rchild == nullptr) {
                mostRight->rchild = cur;
                cur = cur->lchild;
                continue ;
            } else {
                mostRight->rchild = nullptr;
            }
        }
        cout << cur->key << " ";
        cur = cur->rchild;
    }
    return ;
}

```





# 2. ==哈弗曼树与哈弗曼编码==

- 课程节奏

1. 直观的了解哈弗曼树与哈弗曼编码
2. 证明：哈弗曼编码是最优的变长编码



### 2.0.1. 什么是编码

'a' = 97 = $(0110\ 0001)_2$

'0' = 48 = $(0011\ 0000)_2$

注意：任何信息，在计算机中，都是二进制存储的



信息："aa00" = $01100001、01100001、00110000、00110000$

一台计算机   传输到  另外一台计算机，传输 32 个比特位

假设：计算机的网络是 32bit/s。所以用时：1 s



特定场静：只有 a,b,0,1 四种字符需要传输

海贼班编码：a:00, b: 01, 0: 10, 1: 11

"aa00" = 00001010

在带宽不变的情况下，当前只需要传输 0.25s



### 2.0.2. 定长与变长编码

1. Ascii 编码 和 特定场景下的海贼班编码，都属于定长编码
2. 对于每一个字符，编码长度相同，这就是定长编码
3. 【大家自行补充】UTF-8编码，是变长编码，UTF-16，是定长编码
4. 对于每一个字符，编码长度不相同，这就是变长编码
5. 将定长编码，看成是变长编码的特例
6. 变长编码，一定不差于定长编码



### 2.0.3. 变长编码应用场景

特定场静：

1. 只有四种字符 : ab01
2. a: 0.8, b: 0.05, 0: 0.1, 1: 0.05

平均编码长度：

$l_i$：第 i 种字符，编码长度

$p_i$：第 i 种字符，出现概率

$avg(l) = \sum{l_i}\times{p_i}$



假设，平均编码长度：1.16，估算传输100个字符，需要传输116个比特位



海贼班编码的平均编码长度：$avg(l) = 2\times\sum{p_i}=2$



新·海贼班编码：

a: 1

b: 01

0: 000

1: 001



平均编码长度：$1*0.8+2*0.05+3*0.1+3*0.05=1.35$



100个字符，传输135个比特位





## 2.1. 三、哈弗曼编码

1. 首先，统计得到每一种字符的概率
2. 将 n 个字符，建立成一棵哈弗曼树
3. 每一个字符，都落在叶子结点上，所以没有一个编码是其他编码的前缀
4. 按照左0，右1的形式，将编码读取出来



得到新编码：

a: 0 | b: 110 | 0: 10 | 1: 111

平均编码长度：$1*0.8+3*0.05+2*0.1+3*0.05=1.3$



结论：哈弗曼编码，是最优的变长编码



## 2.2. 四、公式证明

1. 首先表示平均编码长度，求解公式最优解
2. 最终，和熵与交叉熵之间的关系



```cpp
typedef struct Node {
    char ch;
    double p;
    struct Node *next[2];
} Node;

typedef struct Code {
    char ch;
    char *str;
} Code;

typedef struct Haffman_Tree {
    Node *root;
    int n;
    Code *codes;
} Haffman_Tree;

typedef struct Data {
    char ch;
    double p;
} Data;

Data arr[max_n + 5];

Node *getNewNode(Data *obj) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->ch = (obj ? obj->ch : 0);
    p->p = (obj ? obj->p : 0);
    p->next[0] = p->next[1] = NULL;
    return p;
}

Haffman_Tree *getNewTree(int n) {
    Haffman_Tree *tree = (Haffman_Tree *)malloc(sizeof(Haffman_Tree));
    tree->codes = (Code *)malloc(sizeof(Code) * n);
    tree->n = n;
    tree->root = NULL;
    return tree;
}

void insertOnce(Node **arr, int n) {
    for (int j = n; j >= 1; j--) {
        if (arr[j]->p > arr[j - 1]->p) {
            swap(arr[j], arr[j - 1]);
            continue;
        }
        break;
    }
    return ;
}

int extract_Codes(Node *root, Code *arr, int k, int l, char *buff) {
    buff[l] = 0;
    if (root->next[0] == NULL && root->next[1] == NULL) {
        arr[k].ch = root->ch;
        arr[k].str = strdup(buff);
        return 1;
    }
    int delta = 0;
    buff[l] = '0';
    delta += extract_Codes(root->next[0], arr, k + delta, l + 1, buff);
    buff[l] = '1';
    delta += extract_Codes(root->next[1], arr, k + delta, l + 1, buff);
    return delta;
}

Haffman_Tree *build(Data *arr, int n) {
    Node **nodes = (Node **)malloc(sizeof(Node *) * n);
    for (int i = 0; i < n; i++) {
        nodes[i] = getNewNode(arr + i);
    }
    for (int i = 1; i < n; i++) {
        insertOnce(nodes, i);
    }
    for (int i = n - 1; i >= 1; i--) {
        Node *p = getNewNode(NULL);
        p->next[0] = nodes[i - 1];
        p->next[1] = nodes[i];
        p->p = nodes[i - 1]->p + nodes[i]->p;
        nodes[i - 1] = p;
        insertOnce(nodes, i - 1);
    }
    char *buff = (char *)malloc(sizeof(char *) * n);
    Haffman_Tree *tree = getNewTree(n);
    tree->root = nodes[0];
    extract_Codes(tree->root, tree->codes, 0, 0, buff);
    free(nodes);
    free(buff);
    return tree;
}

int main() {
    int n;
    char str[10];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%c %lf", str, &arr[i].p);
        arr[i].ch = str[0];
    }
    Haffman_Tree *tree = build(arr, n);
    for (int i = 0; i < tree->n; i++) {
        printf("%c : %s\n", tree->codes[i].ch, tree->codes[i].str);
    }
    return 0;
}
```







## 2.3. ==优先队列-堆==

## 2.3. ==优先队列-堆==

```c
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct priority_queue {
    int *data;
    int cnt, size;
} priority_queue;

priority_queue *init(int n) {
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * (n + 1));
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {
    return q->data[1];
}
//自下而上调整
int push(priority_queue *q, int val) {
    if (q == NULL) return 0;
    if (q->cnt == q->size) return 0;
    q->cnt += 1;
    q->data[q->cnt] = val;
    int ind = q->cnt;
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
        swap(q->data[ind], q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}

int pop(priority_queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        if (temp == ind) break;
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}

void clear(priority_queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for (int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to queue\n", val);
    }
    for (int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    clear(q);
    return 0;
}
```

## 2.4. ==线性建堆法==

```c
//自上而下
void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i >= 1; i--) {
        downUpdate(arr, n, i);
    }
    for (int i = n; i > 1; i--) {
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);
    }
    return ;
}

```

![image-20201008200910691](/Image/A1.Data_Structure-photo/image-20201008200910691.png)



#### 2.4.0.1. [LC-703. 数据流中的第K大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。

你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。

示例:

int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8

```c
#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

typedef struct {
    int *data;
    int cnt, size;
} KthLargest;

void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] < arr[temp]) temp = l;
        if (r <= n && arr[r] < arr[temp]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

void upUpdate(int *arr, int ind) {
    while (ind >> 1) {
        if (arr[ind] >= arr[ind >> 1]) break;
        swap(arr[ind], arr[ind >> 1]);
        ind >>= 1;
    }
    return ;
}

int kthLargestAdd(KthLargest*, int);
KthLargest* kthLargestCreate(int k, int* nums, int numsSize) {
    KthLargest *p = (KthLargest *)malloc(sizeof(KthLargest));
    p->data = (int *)malloc(sizeof(int) * (k + 1));
    p->size = k;
    p->cnt = k - 1;
    memcpy(p->data + 1, nums, sizeof(int) * (k - 1));
    for (int i = (k - 1) >> 1; i >= 1; --i) {
        downUpdate(p->data, k - 1, i);
    }
    for (int i = k - 1; i < numsSize; i++) {
        kthLargestAdd(p, nums[i]);
    }
    return p;
}

int kthLargestAdd(KthLargest* obj, int val) {
    if (obj->cnt == obj->size) {
        if (val > obj->data[1]) {
            obj->data[1] = val;
            downUpdate(obj->data, obj->size, 1);
        }
    } else {
        obj->cnt += 1;
        obj->data[obj->cnt] = val;
        upUpdate(obj->data, obj->cnt);
    }
    return obj->data[1];
}

void kthLargestFree(KthLargest* obj) {
    if (obj == NULL) return ;
    free(obj->data);
    free(obj);
    return ;
}
```



#### 2.4.0.2. [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

如果我们可以用以下方式维护两个堆：

1. 用于存储输入数字中较小一半的最大堆
2. 用于存储输入数字的较大一半的最小堆

这样就可以访问输入中的中值：它们组成堆的顶部！

```c
typedef struct Heap {
    int *data;
    int n, size;
} Heap;

void expandHeap(Heap *h) {
    h->data = realloc(h->data, 2 * h->size * sizeof(int));
    h->size *= 2;
    return ;
}

#define swap(a, b) { \
    __typeof(a) __temp = a; \
    a = b, b = __temp; \
}

#define pushHeap(h, val, comp) { \
    if (h->size == h->n + 1) { \
        expandHeap(h); \
    } \
    h->data[++(h->n)] = val; \
    int ind = h->n; \
    while (ind != 1 && h->data[ind] comp h->data[ind >> 1]) { \
        swap(h->data[ind], h->data[ind >> 1]); \
        ind >>= 1; \
    } \
}

#define popHeap(h, comp) do { \
    if (h->n == 0) break; \
    h->data[1] = h->data[(h->n)--]; \
    int ind = 1; \
    while (ind << 1 <= h->n) { \
        int temp = ind, l = ind << 1, r = ind << 1 | 1; \
        if (h->data[l] comp h->data[temp]) temp = l; \
        if (r <= h->n && h->data[r] comp h->data[temp]) temp = r; \
        if (temp == ind) break; \
        swap(h->data[temp], h->data[ind]); \
        ind = temp; \
    } \
} while(0);

Heap *creatHeap() {
    Heap *h = (Heap *)malloc(sizeof(Heap));
    h->size = 100;
    h->data = (int *)malloc(sizeof(int) * h->size);
    h->n = 0;
    return h;
}

void clearHeap(Heap *h) {
    if (h == NULL) return ;
    free(h->data);
    free(h);
    return ;
}

typedef struct {
    Heap *min_heap, *max_heap;
} MedianFinder;

/** initialize your data structure here. */

MedianFinder* medianFinderCreate() {
    MedianFinder* m = (MedianFinder*)malloc(sizeof(MedianFinder));
    m->min_heap = creatHeap();
    m->max_heap = creatHeap();
    return m;
}

void medianFinderAddNum(MedianFinder* m, int num) {
    if (m->min_heap->n == 0 || num >= m->min_heap->data[1]) {
        pushHeap(m->min_heap, num, <);
    } else {
        pushHeap(m->max_heap, num, >);
    }
    if (m->min_heap->n - m->max_heap->n == 2) {
        pushHeap(m->max_heap, m->min_heap->data[1], >);
        popHeap(m->min_heap, <);
    }
    if (m->max_heap->n - m->min_heap->n == 2) {
        pushHeap(m->min_heap, m->max_heap->data[1], <);
        popHeap(m->max_heap, >);
    }
    return ;
}

double medianFinderFindMedian(MedianFinder* m) {
    switch (m->min_heap->n - m->max_heap->n) {
        case -1: return m->max_heap->data[1];
        case 0: return 1.0 * (m->min_heap->data[1] + m->max_heap->data[1]) / 2.0;
        case 1: return m->min_heap->data[1];
    }
    return 0.0;
}

void medianFinderFree(MedianFinder* obj) {
    if (obj == NULL) return ;
    clearHeap(obj->min_heap);
    clearHeap(obj->max_heap);
    free(obj);
    return ;
}
```

#### 2.4.0.3. LC-264 [丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/description/)

> 编写一个程序，找出第 `n` 个丑数。
>
> 丑数就是质因数只包含 `2, 3, 5` 的**正整数**。

2.优先队列 (小顶堆)
优先队列/小顶堆/大顶堆
利用优先队列有自动排序的功能
每次取出队头元素，存入队头元素*2、队头元素*3、队头元素*5
但注意，像 12 这个元素，可由 4 乘 3 得到，也可由 6 乘 2 得到，所以要注意去重
还可以更进一步采用 set 来识别有无重复

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        priority_queue <double,vector<double>,greater<double> > q;
        set<int> s;
        s.insert(1);
        vector<int> mask({2,3,5});
        double answer=1;
        for (int i=1;i<n;++i)
        {
            for (int &j:mask)
                if (s.count(answer*j)==0)
                {
                    q.push(answer*j);
                    s.insert(answer*j);
                }
            answer=q.top();
            q.pop();
        }
        return answer;
    }
};

```

3.动态规划 (三指针)
我们先模拟手写丑数的过程
1 打头，1 乘 2 1 乘 3 1 乘 5，现在是 {1,2,3,5}
轮到 2，2 乘 2 2 乘 3 2 乘 5，现在是 {1,2,3,4,5,6,10}
手写的过程和采用小顶堆的方法很像，但是怎么做到提前排序呢

小顶堆的方法是先存再排，dp 的方法则是先排再存
我们设 3 个指针 p_2,p_3,p_5
代表的是第几个数的2倍、第几个数 3 倍、第几个数 5 倍
动态方程 dp[i]=min(dp[p_2]*2,dp[p_3]*3,dp[p_5]*5)
小顶堆是一个元素出来然后存 3 个元素
动态规划则是标识 3 个元素，通过比较他们的 2 倍、3 倍、5 倍的大小，来一个一个存

```cpp
        int t1 = 0, t2 = 0, t3 = 0;
        vector<int> k(n);
        k[0] = 1;
        for (int i = 1; i < n; ++i) {
            int f1 = k[t1] * 2, f2 = k[t2] * 3, f3 = k[t3] * 5;
            k[i] = min(f1, min(f2, f3));
            if (k[i] == f1) t1++;
            if (k[i] == f2) t2++;
            if (k[i] == f3) t3++;
        }
        return k[n - 1];
```

#### 2.4.0.4. LC-23 [合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

1. 分治合并

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        return merge(lists, 0, lists.size() - 1);
    }
private :
    ListNode* merge(vector<ListNode*>& lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        ListNode dummy, *p = &dummy;
        dummy.next = nullptr;
        while (l1 || l2) {
            if (!l2 || l1 && l1->val < l2->val) {
                p->next = l1;
                p = p->next;
                l1 = l1->next;
            } else {
                p->next = l2;
                p = p->next;
                l2 = l2->next;
            }
        }
        return dummy.next;
    }
};
```

2. 使用优先队列合并

   需要维护当前每个链表没有被合并的元素的最前面一个，k个链表就最多有 k个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中

```cpp
class Solution {
public:
    typedef pair<int, ListNode *> PII;
    struct cmp {
        bool operator()(const PII &a, const PII &b) const {
          return a.first > b.first;
      }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        //return merge(lists, 0, lists.size() - 1);
        priority_queue<PII, vector<PII>, cmp> q;
        for (auto cur : lists) {
            if (cur) q.push({cur->val, cur});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto cur = q.top();
            ListNode *ptr = cur.second;
            q.pop();
            tail->next = ptr;
            tail = tail->next;
            if (ptr->next) q.push({ptr->next->val, ptr->next});
        }
        tail->next = nullptr;
        return head.next;

    }
```



#### 2.4.0.5. HZOJ-571-关系网络1.cpp

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100
int arr[MAX_N + 5][MAX_N + 5];

struct Data {
    Data(int a, int b, int c) {
        x = a, y = b, cnt = c;
    }
    int cnt, x, y;
};

struct DataCompare {
    bool operator()(const Data &a, const Data &b) const {
        if (a.cnt - b.cnt) return a.cnt < b.cnt;
        if (a.x - b.x) return a.x < b.x;
        return a.y < b.y;
    }
};

set<Data, DataCompare> s;

int main() {
    int n, x, y;
    cin >> n >> x >> y;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arr[i][j];
            if (arr[i][j]) {
                s.insert(Data(i, j, 1));
            }
        }
    }
    while (s.size()) {
        int x = s.begin()->x;
        int y = s.begin()->y;
        int cnt = s.begin()->cnt;
        s.erase(s.begin());
        for (int i = 1; i <= n; i++) {
            if (arr[y][i] != 1) continue;
            if (arr[x][i]) continue;
            arr[x][i] = cnt + 1;
            s.insert(Data(x, i, cnt + 1));
        }
    }
    cout << arr[x][y] - 1 << endl;
    return 0;
}
```

#### 2.4.0.6. HZOJ-572-有序表的最小和.cpp

#### 2.4.0.7. 题目描述

 给出两个长度为 *𝑛*n 的有序表 *𝐴*A 和 *𝐵*B，在 *𝐴*A 和 *𝐵*B 中各任取一个元素，可以得到 *𝑛*2n2 个和，求这些和中前 *𝑛*n 个最小值。

1. 双指针

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 400000
long long a[MAX_N + 5], b[MAX_N + 5];

struct Data {
    Data(long long val, long long i, long long j) : val(val), i(i), j(j) {}
    long long val, i, j;
    bool operator<(const Data &a) const {
        if (val - a.val) return val < a.val;
        if (i - a.i) return i < a.i;
        return j < a.j;
    }
};

set<Data> s;

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%lld", a + i);
    for (int i = 0; i < n; i++) scanf("%lld", b + i);
    s.insert(Data(a[0] + b[0], 0, 0));
    for (long long i = 0; i < n; i++) {
        long long val = s.begin()->val;
        long long x = s.begin()->i;
        long long y = s.begin()->j;
        s.erase(s.begin());
        printf("%lld\n", val);
        if (x + 1 < n) s.insert(Data(a[x + 1] + b[y], x + 1, y));
        if (y + 1 < n) s.insert(Data(a[x] + b[y + 1], x, y + 1));
    }
    return 0;
}
```

2.优先队列





#### 2.4.0.8. hzoj-284-超市卖货-二叉堆-并查集

> 超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.
>
> 每天只能卖一个商品.
>
> 现在你要让超市获得最大的利润.

```c
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 10000
struct Data {
    int p, d;
} a[MAX_N + 5];

bool cmp(const Data &a, const Data &b) {
    return a.d < b.d;
}

typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].p >> a[i].d;
    }
    sort(a, a + n, cmp);
    for (int i = 0; i < n; i++) {
        if (s.size() < a[i].d) {
      //插入i是为了set去重
            s.insert(PII(a[i].p, i));
        } else if (s.begin()->first < a[i].p) {
            s.erase(s.begin());
            s.insert(PII(a[i].p, i));
        }
    }
    int ans = 0;
    for (auto iter = s.begin(); iter != s.end(); iter++) {
        ans += iter->first;
        cout << iter->first << endl;
    }
    cout << ans << endl;
    return 0;
}
```

```cpp
#define MAX_N 10000

struct Data {
    int p, d;
} arr[MAX_N + 5];
 
struct UnionSet {
    int fa[MAX_N + 5];
    void init(int n) {
        for (int i = 0; i <= n; ++i) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    //根节点代表当前节点前面第一个空位置
    //前面做儿子
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

bool cmp(const Data &a, const Data &b) {
    return a.p > b.p;
}

UnionSet u;

int solve(int n) {
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].p >> arr[i].d;
    }
    sort(arr, arr + n, cmp);
    u.init(MAX_N);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (u.get(arr[i].d) == 0) continue;
        ans += arr[i].p;
        int day = u.get(arr[i].d);
        //让day作为day-1的子集，day被占用
        u.merge(day, day - 1);
    }
    cout << ans << endl;
    return 0;
}

int main() {
    int n;
    while (cin >> n) solve(n);
    return 0;
}

```

#### 2.4.0.9. hzoj-286. 数据备份

等效权值替换

反悔策略

基于选择一条电缆的情况去选择第二条电缆

![image-20210121192544196](/Image/A1.Data_Structure-photo/image-20210121192544196.png)

若要选择周围的3-4则必须选择1-2

![image-20210121192854505](/Image/A1.Data_Structure-photo/image-20210121192854505.png)

等效图的生成，反悔侧率

```cpp
#define MAX_N 100000
#define inf 0x3f3f3f

int a[MAX_N + 5];
int l[MAX_N + 5], pre[MAX_N + 5], nxt[MAX_N + 5];
typedef pair<int, int> PII;
set<PII> s;

int main() {
    int n, k;
    cin >> n >> k;
    a[0] = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        l[i] = a[i] - a[i - 1];
        pre[i] = i - 1;
        nxt[i] = i + 1 > n ? 0 : i + 1;
        s.insert(PII(l[i], i));
    }
    int sum = 0;
    while (k) {
        int t0 = s.begin()->second, t1 = pre[t0], t2 = nxt[t0];
        if (t1 == 0 || l[t0] != s.begin()->first) {
            s.erase(s.begin());
            continue;
        }
        s.erase(s.begin());
        sum += l[t0];
        k--;
        l[t0] = l[t1] + l[t2] - l[t0];
        l[t1] = l[t2] = inf;
        if (t2 == 0) continue;
        pre[t0] = pre[t1];
        nxt[t0] = nxt[t2];
        nxt[pre[t1]] = t0;
        pre[nxt[t2]] = t0;
        s.insert(PII(l[t0], t0));
    }
    cout << sum << endl;

    return 0;
}

```



#### 2.4.0.10. HZOJ-289-生日礼物.cpp

[BZOJ2288](https://www.cnblogs.com/zyfzyf/p/4114774.html)

>  李华 1818 岁生日的时候，小明给她看了一个神奇的序列 *𝐴*1,*𝐴*2,...,*𝐴**𝑁*A1,A2,...,AN。 她被允许选择不超过 *𝑀*M 个连续的部分作为自己的生日礼物。自然地，李华想要知道选择元素之和的最大值。你能帮助她吗？
>  首先连在一块的正负相同的肯定可以看成一个点，然后我们就得到了一个正负交替的数列，并且首位两项都是正数（负数去掉）

然后如果正的项数<=m，那显然我们全部选走就获得了最大权值，否则我们需要做一点牺牲。

1）不选某些正项

2）选一些负项使得相邻的正项成为1块

记所有正数之和为sum，我们需要进行上面两种操作使得sum减掉的数最小并且满足只有m块。

我们把所有数的绝对值放入一个堆，每次取最小元素x。sum'-=x

那么如果该数原来是正的，意思是不选它；

如果是负的，意思是把它两边的正数合并。

但直接这样做是不行的，我们必须保证取负的时候两边的正的必须不被取，取正的时候两边的负的不被取。

换句话说，不能选择相邻的两个数！我们成功的将此题转化成了数据备份问题。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <set>
using namespace std;
#define MAX_N 100000
long long arr[MAX_N + 5];

struct Node {
    long long val, id, f;
    long long pre, next;
    bool operator<(const Node &a) const {
        if (abs(val) - abs(a.val)) return abs(val) < abs(a.val);
        return id < a.id;
    }
} list[MAX_N + 5];

set<Node> s;

void del(long long k) {
    if (list[k].f == 0) return ;
    if (list[k].pre)  list[list[k].pre].next = list[k].next;
    if (list[k].next) list[list[k].next].pre = list[k].pre;
    list[k].f = 0;
    return ;
}

int main() {
    long long n, m, cnt = 0, sum = 0;
    cin >> n >> m;
    for (long long i = 0; i < n; i++) cin >> arr[i];
    for (long long i = 0, k = 1; i < n; k++) {
        list[k].val = 0;
        list[k].id = k;
        list[k].f = 1;
        while (i < n && arr[i] == 0) i++;
        long long val = arr[i];
        while (i < n && arr[i] * val >= 0) {
            list[k].val += arr[i++];
        }
        if (k - 1) list[k - 1].next = k;
        list[k].pre = k - 1;
        list[k].next = 0;
        if (list[k].val > 0) cnt += 1, sum += list[k].val;
        s.insert(list[k]);
    }
    while (cnt > m) {
        long long k = s.begin()->id;
        s.erase(s.begin());
        if (list[k].f == 0) continue;
        if (list[k].pre && list[k].next) {
            sum -= abs(list[k].val);
            cnt -= 1;
            list[k].val += list[list[k].pre].val;
            list[k].val += list[list[k].next].val;
            del(list[k].pre);
            del(list[k].next);
            s.insert(list[k]);
        } else {
            if (list[k].val > 0) sum -= list[k].val, cnt -= 1;
            del(k);
        }
    }
    cout << sum << endl;
    return 0;
}
```

#### 2.4.0.11. HZOJ-285 序列M小和

>   给出一个 *𝑛*∗*𝑚*n∗m 的矩阵，每行取一个元素，组成一个包含 *𝑛*n 个元素的序列，一共有 *𝑚**𝑛*mn 种序列，求出序列和最小的前 *𝑚*m 个序列的序列和。

```cpp
#define INF 0x3f3f3f3f
#define MAX_M 2000
int nums[MAX_M + 5];
//时间戳, 加负号模拟大顶堆
typedef pair<int, int> PII;

struct BigSet : set<PII> {
public :
    BigSet() : t(0) {}
    void insert(int &a) {
        this->set<PII>::insert(PII(-a, t++));
    }
    void pop() {
        erase(begin());
    }
    int top() {
        return -(begin()->first);
    }

private :
    int t;
};

BigSet s;

void extract(int m) {
    for (int i = m - 1; i >= 0; --i) {
        nums[i] = s.top();
        s.pop();
    }
}

int main() {
    int n, m, x;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> x;
        s.insert(x);
    }
    for (int i = 1; i < n; ++i) {
        extract(m);
        for (int j = 0; j < m; ++j) {
            cin >> x;
            for (int k = 0; k < m; ++k) {
                int y = x + nums[k];
                if (s.size() == m && y >= s.top()) break;
                if (s.size() == m) s.pop();
                s.insert(y);
            }
        }
    }
    extract(m);
    for (int i = 0; i < m; ++i) {
        i && cout << " ";
        cout << nums[i];
    }
    cout << endl;
    return 0;
}

```



## 2.5. ==HashTable==

```c
typedef struct Node {
    char *str;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node **data;
    int size;
} HashTable;

Node *init_node(char *str, Node *head) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n * 2;
    h->data = (Node **)calloc(h->size, sizeof(Node *));
    return h;
}

int BKDRHash(char *str) {
    int hash = 0, seed = 31;
    for (int i = 0; str[i]; ++i) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}

int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *head = h->data[ind];
    while (head && strcmp(str, head->str)) head = head->next;
    return head != NULL;
}

int insert(HashTable *h, char *str) {
    if (search(h, str)) return 0;
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}

void clear_node(Node *head) {
    if (head == NULL) return ;
    Node *p = head, *q;
    while(p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    return ;
}

void clear_hashtable(HashTable *h) {
    if (h == NULL) return ;
    for (int i = 0; i < h->size; ++i) clear_node(h->data[i]);
    free(h);
    return ;
}

int main() {
    #define max_n 1000
    HashTable *h = init_hashtable(max_n + 5);
    char *str = (char *)malloc(sizeof(char) * (max_n + 5));
    int op;
    while (~scanf("%d%s", &op, str)) {
        switch (op) {
            case 0 : 
                printf("%s insert to the HashTable = %d\n", str, insert(h, str));
            break;
            default : 
                printf("search %s from the HashTable = %d\n", str, search(h, str));
            break;
        }
    }
    clear_hashtable(h);
    #undef max_n

    return 0;
}

```

## 2.6. ==sort==



![849589-20171015223238449-2146169197](/Image/A1.Data_Structure-photo/849589-20171015223238449-2146169197.gif)

![849589-20180402133438219-1946132192](/Image/A1.Data_Structure-photo/849589-20180402133438219-1946132192.png)

Code:

```cpp
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp; \
}

#define TEST(arr, n, func, args...) {\
    int *num = (int *)malloc(sizeof(int) * n);\
    memcpy(num, arr, sizeof(int) * n);\
    output(num, n);\
    printf("%s\t= ", #func);\
    func(num, args);\
    output(num, n);\
    free(num);\
}


int insert_sort(int *arr, int n) {
    for (int i = 1; i < n; ++i) {
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; --j) {
            swap(arr[j], arr[j - 1]);
        }
    }
    return 1;
}

int bubble_sort(int *arr, int n) {
    int times = 1;
    for (int i = 1; times && i < n; ++i) {
        times = 0;
        for (int j = 0; j < n - i; ++j) {
            if (arr[j] <= arr[j + 1]) continue;
            swap(arr[j], arr[j + 1]);
            times++;
        }
    }
    return 1;
}

int merge_sort(int *arr, int l , int r) {
    if (r - l <= 1) {
        if (r - l == 1 && arr[r] < arr[l]) {
            swap(arr[r], arr[l]);
        }
        return 1;
    }
    int mid =  (l + r) >> 1;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);
    int p1 = l, p2 = mid + 1, ind = 0;
    int *tmp =  (int *)malloc(sizeof(int) * (r - l + 1));
    while (p1 <= mid || p2 <= r) {
        if (p2 > r || p1 <= mid && arr[p1] < arr[p2]) tmp[ind++] = arr[p1++];
        else tmp[ind++] = arr[p2++];
    }
    memcpy(arr + l, tmp, sizeof(int) * (r - l + 1));
    free(tmp);
    return 1;
}

int select_sort(int *arr, int n) {
    for (int i = 0; i < n - 1; ++i) {
        int ind = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[ind] <= arr[j]) continue;
            ind = j;
        }
        swap(arr[ind], arr[i]);
    }
    return 1;
}

int quick_sort(int *arr, int l, int r) {
    if (l >= r) return 0;
    int x = l, y = r, z = arr[l];
    while (x  < y) {
        while (x < y && arr[y] > z) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] < z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    quick_sort(arr, l, x - 1);
    quick_sort(arr, x + 1, r);
    return 1;
}

void output(int *arr, int n) {
    for (int i = 0; i < n; ++i) {
        printf(" %d", arr[i]);
    }
    printf("\n");
}

int *init(int n) {
    int *arr = (int *)malloc(sizeof(int) * n);
    while (n--) arr[n] = rand() % 100;
    return arr;
}

void downUpdate(int *arr, int ind, int n) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (arr[l] > arr[temp]) temp = l;
        if (r <= n && arr[r] > arr[temp]) temp = r;
        if (temp == ind ) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return ;
}

int heap_sort(int *arr, int n) {
    arr -= 1;
    for (int i = n >> 1; i > 0; --i) {
        downUpdate(arr, i, n);
    }
    for (int i = n; i > 1; --i) {
        swap(arr[i], arr[1]);
        downUpdate(arr, 1, i - 1);
    }
    return 1;
}


int main() {
    srand(time(0));
    #define max_op 20
    int *arr = init(max_op);
    TEST(arr, max_op, insert_sort, max_op);
    TEST(arr, max_op, bubble_sort, max_op);
    TEST(arr, max_op, merge_sort, 0, max_op - 1);
    TEST(arr, max_op, select_sort, max_op);
    TEST(arr, max_op, quick_sort, 0, max_op - 1);
    TEST(arr, max_op, heap_sort, max_op);
    #undef max_op
    return 0;
}

```



#### 2.6.0.12. lc-2寻找指定和

```cpp
class Solution {
public:
    typedef pair<int, int> PII;
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> ret;
        vector<PII> nums2;
        for (int i = 0; i < nums.size(); i++) {
            nums2.push_back(PII(nums[i], i));
        }
        sort(nums2.begin(), nums2.end());
        int i = 0, j = nums2.size() - 1;
        while (nums2[i].first + nums2[j].first - target) {
            if (nums2[i].first + nums2[j].first > target) --j;
            if (nums2[i].first + nums2[j].first < target) ++i;
        }
        if (nums2[i].second > nums2[j].second) swap(i, j);
        ret.push_back(nums2[i].second);
        ret.push_back(nums2[j].second);
        return ret;
    }
};
```



#### 2.6.0.13. lc-11[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/description/)

#### 2.6.0.14. [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int *map = (int *)malloc(sizeof(int) * 256);
        for (int i = 0 ; i < 256; ++i) {
            map[i] =  -1;
        }
        int ans = 0, cur = 0, pre  = -1;
        for (int i = 0; i < s.size(); ++i) {
            pre = max(pre, map[s[i]]);
            cur = i - pre;
            ans = max(ans, cur);
            map[s[i]] = i;
        }
        return ans;
    }
};


```

```c
class Solution {
public: 
    int check(string &s, int l) {
        unordered_map<char, int> m;
        int cnt = 0;
        for (int i = 0; s[i]; i++) {
            m[s[i]] += 1;
            if (m[s[i]] == 1) cnt += 1;
            if (i >= l) {
                m[s[i - l]] -= 1;
                if (m[s[i - l]] == 0) cnt -= 1;
            }
            if (cnt == l) return 1;
        }
        return 0;
    }
    
    int lengthOfLongestSubstring(string s) {
        int head = 0, tail = s.length(), mid;
        while (head < tail) {
            mid = (head + tail + 1) >> 1;
            if (check(s, mid)) head = mid;
            else tail = mid - 1;
        }
        return head;
    }
};
```

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> m;
        int pre_l = 0, ans = 0;
        for (int i = 0; s[i]; i++) {
            if (m.find(s[i]) == m.end()) pre_l += 1;
            else pre_l = min(pre_l + 1, i - m[s[i]]);
            ans = max(ans, pre_l);
            m[s[i]] = i;
        }
        return ans;
    }
};
```

#### 2.6.0.15. [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

方法一：二分查找
给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：

使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。

不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。![fig1](/Image/A1.Data_Structure-photo/4_fig1.png)

如果$A[k/2−1]<B[k/2−1]$，则比$A[k/2−1]$ 小的数最多只有 $A$ 的前$ k/2-1$个数和B的前 $k/2-1$个数，即比 $A[k/2−1]$小的数最多只有$k−2$ 个，因此 $A[k/2−1]$ 不可能是第 $k$个数，$A[0]$ 到 $A[k/2−1] $也都不可能是第$k$个数，可以全部排除

以下三种情况需要特殊处理：

如果 ${A}[k/2-1]$ 或者 $B[k/2−1]$ 越界，那么我们可以选取对应数组中的最后一个元素。**在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2**。

如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。

如果 k=1，我们只要返回两个数组首元素的最小值即可

```cpp
class Solution {
public:
    double kth(vector<int> &n1, vector<int> &n2, int k) {
        int len1 = n1.size(), len2 = n2.size();
        int t1 = 0, t2 = 0, res = 0;
        while (true) {
            if (t1 == len1) {
                res = n2[t2 + k - 1];
                break;
            }
            if (t2 == len2) {
                res = n1[t1 + k - 1];
                break;
            }
            if (k == 1) {
                res = min(n1[t1], n2[t2]);
                break;
            }
            int idx1 = min(t1 + k / 2 - 1, len1 - 1);
            int idx2 = min(t2 + k / 2 - 1, len2 - 1);
            if (n1[idx1] <= n2[idx2]) {
                k -= idx1 - t1 + 1;
                t1 = idx1 + 1;
            } else {
                k -= idx2 - t2 + 1;
                t2 = idx2 + 1;
            }
        }
        return res;
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1 = nums1.size(), len2 = nums2.size();
        int k = (len1 + len2) >> 1;
        double m1 = kth(nums1, nums2, k + 1);
        if ((len1 + len2) & 1 == 1) {
            return m1;
        }
        double m2 = kth(nums1, nums2, k);
        return (m1 + m2) / 2.0;
    }
};
```





```cpp
class Solution {
public:
    double bs(vector<int> &n1, vector<int> &n2, int i, int j, int k) {
        if (i == n1.size()) return n2[k - 1];
        if (j == n2.size()) return n1[k - 1];
        if (k == 1) return min(n1[i], n2[j]);
        int a, b;
        a = k / 2 > n1.size() - i ? n1.size() - i : k / 2;
        b = k - a > n2.size() - j ? n2.size() - j : k - a;
        a = k - b;
        if (n1[i + a - 1] < n2[j + b - 1]) {
            return bs(n1, n2, i + a, j, k - a);
        }
        return bs(n1, n2, i, j + b, k - b);
    }

    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        double val1 = bs(nums1, nums2, 0, 0, (n + m + 1) / 2);
        if ((n + m) % 2 == 0) {
            double val2 = bs(nums1, nums2, 0, 0, (n + m) / 2 + 1);
            return (val1 + val2) / 2;
        }
        return val1;
    }
};
```

方法二：划分数组
说明

方法一的时间复杂度已经很优秀了，但本题存在时间复杂度更低的一种方法。这里给出推导过程，勇于挑战自己的读者可以进行尝试。

思路与算法

为了使用划分的方法解决这个问题，需要理解「中位数的作用是什么」。在统计中，中位数被用来：

**将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素**



#### 2.6.0.16. [38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)

```cpp
class Solution {
public:
    string countAndSay(int n) {
        if (n == 1) return "1";
        string ret = "", str = countAndSay(n - 1);
        char tmp[10];
        int cnt = 1;
        for (int i = 1, j = 0; str[i]; i++) {
            if (str[i] == str[j]) cnt += 1;
            else {
                sprintf(tmp, "%d%c", cnt, str[j]);
                ret += tmp;
                cnt = 1, j = i;
            }
        }
        sprintf(tmp, "%d%c", cnt, str[str.size() - 1]);
        ret += tmp;
        return ret;
    }
};
```

#### 2.6.0.17. [217存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/description/)

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        return nums.size() > set<int>(nums.begin(), nums.end()).size();        
    }
};

```

#### 2.6.0.18. [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

给定一个整数数组和一个整数 *k*，判断数组中是否存在两个不同的索引 *i* 和 *j*，使得 **nums [i] = nums [j]**，并且 *i* 和 *j* 的差的 **绝对值** 至多为 *k*。

 

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        k += 1;
        unordered_map<int, int> s;
        for (int i = 0; i < nums.size(); i++) {
            s[nums[i]] += 1;
            if (i >= k) s[nums[i - k]] -= 1;
            if (s[nums[i]] == 2) return true;
        }
        return false;
    }
};
```

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n = nums.size();
        int l = 0,  r = -1;
        while (l < n) {
            if (r + 1 < n && r + 1 <= l + k) {
                ++r;
            } else {
                ++l;
            }
            if (r <= l) continue;
            if (nums[r] == nums[l]) return true;
        }
        return false;
    }
};
```

#### 2.6.0.19. [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int> &nums1, vector<int> &nums2) {
        set<int> record;
        for (int i = 0; i < nums1.size(); i++) {
            record.insert(nums1[i]);
        }

        set<int> resultSet;
        for (int i = 0; i < nums2.size(); ++i) {
            if (record.find(nums2[i]) != record.end()) {
                resultSet.insert(nums2[i]);
            }
        }

        vector<int> res;
        for (set<int>::iterator iter = resultSet.begin(); iter != resultSet.end(); iter++) {
            res.push_back(*iter);
        }
        return res;
    }
};
```

```cpp
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) return intersect(nums2,nums1);
        unordered_map<int,int> mp;
        for (int i:nums1)
        {
            mp[i]++;
        }
        vector<int> nums;
        for (int j:nums2)
        {
            if (mp[j] > 0)
            {
                nums.push_back(j);
                mp[j]--;
            }
        }
        return nums;


    }
};
```

#### 2.6.0.20. LC-375[猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/description/)

我们正在玩一个猜数游戏，游戏规则如下：

我从 **1** 到 **n** 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

**示例:**

```
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。
```

给定 **n ≥ 1，**计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

动态规划 极小极大化思路：这是一道Minimax算法 又名极小化极大算法问题。局部最大值，全局最小值。

使用动态规划的好处在于我可以穷举所有的情况，对于这个题来说，就是指动态规划的方法可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。

对于动态规划来说，需要明白dp[i][j]的含义，所以接下来我尝试解释dp\[i][j]的含义:
dp\[i][j]是说依次以从i到j的数字作为分割点(猜的数)，必定赢的游戏所用钱的最小值。

对于每一个分割点，我们取它左右两边区间的最大值加上分割点本身作为取此分割点的dp[i][j]值
对于每一个区间，我们取所有分割点的dp[i][j]的最小值作为dp[i][j]的真正的值
特别地，对于以i作为分割点的dp[i][j]，只取i右边的区间；对于以j作为分割点的dp[i][j]，只取j左边的区间

>i i+1 i+2 ... ... j-2 j-1 j
>以i+1为分割点对应的：dp1=max(dp\[i][i],dp\[i+2][j])+i+1
>以j-1为分割点对应的: dp2=max(dp\[i][j-2],dp\[j][j])+j-1
>特别地,以i为分割点：dp0=i+dp\[i+1][j];以j为分割点: dp3=j+dp[i][j-1]
>dp\[i][j]=min(dp0,dp1,dp2,dp3)

给出一个dp二维数组来用代码填充它，“\”表示正无穷

(1)初始化：         (2)易知dp\[i][i]=0   

| \ \ \ \ |         | 0 \ \ \ |
| \ \ \ \ |         | \ 0 \ \ |
| \ \ \ \ |         | \ \ 0 \ |
| \ \ \ \ |         | \ \ \ 0 |
接下来要考虑怎么填充矩阵以得到dp\[1][n]:
很容易我们发现可以用一个位置左边和下边地数据来计算它本身，因此可以这样填充

(3)填充1列：
| 0 1 \ \ |  dp\[1][2]计算步骤向上看
| \ 0 \ \ |
| \ \ 0 \ |
| \ \ \ 0 |
(4)再填充1列：
| 0 1 x \ |  dp\[1][3]计算步骤向上看
| \ 0 2 \ |  dp\[2][3]计算步骤向上看(先填充)
| \ \ 0 \ |
| \ \ \ 0 |

```cpp
class Solution {
public:
    int getMoneyAmount(int n) {
        if (n == 1) return 0;
        int dp[n + 1][n + 1];
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= n; ++j) {
                dp[i][j] = INT_MAX;
            }
        }
        for (int i = 0; i <= n; ++i) dp[i][i] = 0;
        for (int j = 2; j <= n; j++) {
            for (int i = j - 1; i >= 1; i--) {
                for (int k = i + 1; k <= j - 1; k++) {
                    dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]));

                }
                dp[i][j] = min(dp[i][j], i + dp[i + 1][j]);
                dp[i][j] = min(dp[i][j], j + dp[i][j - 1]);

            }
        }

        return dp[1][n];
    }
private :
    int calculate(int low, int high) {
        if (low >= high) return 0;
        int minres = 0x7fffffff;
        for (int i = (low + high) / 2; i <= high; ++i) {
            int res = max(calculate(low, i - 1), calculate(i + 1, high)) + i;
            minres = min(minres, res);
        }
        return minres;
    }
};
```







#### 2.6.0.21. [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

难度中等443

给定一个 *`n x n`* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
请注意，它是排序后的第 `k` 小元素，而不是第 `k` 个不同的元素。

 ```cpp

class Solution {
public:
    bool check(vector<vector<int>>& matrix,int k,int mid,int n){
        int i=n-1,j=0;
        int num=0;
        while(i>=0 && j<n){
            if(matrix[i][j]<=mid){
                num+=i+1;
                j++;
            }
            else    i--;
        }
        return num>=k;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n=matrix.size();
        int left=matrix[0][0],right=matrix[n-1][n-1];
        while(left<right){
            int mid=left+(right-left)/2;
            if(check(matrix,k,mid,n)) right=mid;
            else left=mid+1;
        }
        return left;
    }
};
 ```

```cpp
class Solution {
public:
    int bs_max(vector<vector<int>> &g, int val) {
        int cnt = 0, i = g.size();
        while (i > 0 && g[i - 1][0] > val) i -= 1;
        cnt += g.size() - i;
        for (int j = 1; j < g.size(); j++) {
            while (i > 0 && g[i - 1][j] > val) --i;
            cnt += g.size() - i;
        }
        return cnt;
    }
    int bs_min(vector<vector<int>> &g, int val) {
        int cnt = 0, i = -1;
        while (i + 1 < g.size() && g[i + 1][0] < val) i += 1;
        cnt += i + 1;
        for (int j = 1; j < g.size(); j++) {
            while (i >= 0 && g[i][j] >= val) --i;
            cnt += i + 1;
        }
        return cnt;
    }
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        int head = matrix[0][0], tail = matrix[n - 1][n - 1], mid;
        while (head <= tail) {
            mid = ((head ^ tail) >> 1) + (head & tail);
            int a = bs_min(matrix, mid);
            int b = bs_max(matrix, mid);
            int c = n * n - a - b;
            if (k <= a + c && k > a) return mid;
            if (a + c < k) head = mid + 1;
            else tail = mid - 1;
        }
        return -1;
    }
};
```

#### 2.6.0.22. LC-88 合并数组

> 给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中*，*使 `nums1` 成为一个有序数组。
>
> 初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。

``` cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, tar = m + n - 1;
        while (j >= 0) {
            nums1[tar--] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
        }
    }
};
```

#### 2.6.0.23. 最大平均值

**题目描述**

 给定一个有 N个元素的非负序列，求长度大于等于 M 的连续子序列的最大平均值。

最大平均值介于元素的最小值和最大值之间->二分法

区间和->前缀和->求解判断是否存在长度>=M的连续子序列 >= LA(给定值)

方法:在前缀和数组中维护一个最小值->判存在性

$a_{i+1} + \cdots + a_{i + L} >= AL \\ b_i = a_i - L \\ b_{i + 1} + \cdots + a_{i + L} >= 0$



````cpp
#define MAX_N 100000
long long arr[MAX_N + 5];
long long b[MAX_N + 5];
bool check(long long n, long long m, long long val) {
    for (long long i = 1; i <= n; ++i) b[i] = arr[i] - val;
    for (long long i = 1; i <= n; ++i) b[i] += b[i - 1];
    long long pre = 0;
    for (long long i = m; i <= n; ++i) {
        pre = min(pre, b[i - m]);
        if (b[i] - pre >= 0) return true;
    }
    return false;
}

long long bs(long long l, long long r, long long n, long long m) {
    if (l == r) return l;
    long long mid = (l + r + 1) >> 1;
    if (check(n, m, mid)) return bs(mid, r, n, m);
    return bs(l, mid - 1, n, m);

}

int main() {
    long long n, m, s, t;
    cin >> n >> m;
    for (long long i = 1; i <= n; ++i) {
        cin >> arr[i];
        arr[i] *= 1000;
        if (i == 1) s = t = arr[i];
        s = min(s, arr[i]);
        t = max(t, arr[i]);
    }
    cout << bs(s, t, n, m) << endl;
    return 0;
}

````

#### 2.6.0.24. 秦腾与教学评估.cpp

> 我们可以用三个整数S,E,D 来描述评估团的小组: 既该小组的成员在从宿舍到教学楼的路上的:S,S+D,S+2D,…,S+KD(K∈Z,S+KD≤E,S+(K+1)D>E) 位置。
>
> 找出奇数人数的位置最多有一个
>
> ![image-20210125213921849](/Image/A1.Data_Structure-photo/image-20210125213921849.png)

```cpp
#define MAX_N  200000

struct Node {
    long long s, e, d;
} data[MAX_N + 5];

long long count(long long n, long long pos) {
    long long sum = 0;
    for (long long i = 0; i < n; ++i) {
        if (data[i].s > pos) continue;
        if (data[i].e <= pos) {
            sum += (data[i].e - data[i].s) / data[i].d + 1;
            continue;
        }
        sum += (pos - data[i].s) / data[i].d + 1;
    }
    return sum;
}

long long check(long long n, long long pos) {
   return count(n, pos) % 2; 
}

long long bs(long long l, long long r, long long n) {
    if (l == r) return l;
    long long mid = (l + r) >> 1;
    if (check(n, mid)) return bs(l, mid, n);
    else bs(mid + 1, r, n);
}

long long calc(long long n) {
    long long l, r, mid;
    for (long long i = 0; i < n; ++i) {
        cin >> data[i].s >> data[i].e >> data[i].d;
        if (i == 0) l = data[i].s, r = data[i].e;
        l = min(l, data[i].s);
        r = max(r, data[i].e);
    }
    long long pos = bs(l, r, n);
    long long cnt = count(n, pos) - count(n, pos - 1);
    if (cnt & 1) {
        cout << pos << " " << cnt << endl;
    } else {
        cout << "Poor QIN Teng:(" << endl;
    }
    return 0;
}


int main() {
    long long t, n;
    cin >> t;
    for (long long i = 0; i < t; ++i) {
        cin >> n;
        calc(n);
    }
    return 0;
}

```

#### 2.6.0.25. HZOJ-244-奶牛围栏

![image-20210125233324739](/Image/A1.Data_Structure-photo/image-20210125233324739.png)



10000->二维数组,离散化均不可

```cpp
#define MAX_N 500

struct Data {
    int x, y;
} arr[MAX_N + 5];
int tmp[MAX_N + 5];

bool check_y(int l, int r, int c, int len) {
    int cnt = 0;
    for (int i = l; i <= r; ++i) {
        tmp[cnt++] = arr[i].y;
    }
    sort(tmp, tmp + cnt);
    for (int i = c - 1; i < cnt; ++i) {
        if (tmp[i] - tmp[i - c + 1] < len)  return true;
    }
    return false;
}

bool check(int n, int len, int c) {
    int j = 0;
    for (int i = 0; i < n; ++i) {
        while (arr[i].x - arr[j].x >= len) j++;
        if (arr[i].x - arr[j].x + 1 < c) continue;
        if (check_y(j, i, c, len)) return true;
    }
    return false;
}

bool cmp(const Data &a, const Data &b) {
    return a.x < b.x;
}

int main() {
    int c, n;
    cin >> c >> n;
    for (int i = 0; i < n; ++i) cin >> arr[i].x >> arr[i].y;
    sort(arr, arr + n, cmp);
    int l = 1, r = 10000;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(n, mid, c)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}

```



#### 2.6.0.26. [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        queue<TreeNode*> que;
        if(root!=NULL)
            que.push(root);
        while(!que.empty())
        {
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                TreeNode* p=que.front();
                que.pop();
                if(i==size-1)
                    res.push_back(p->val);
                if(p->left!=NULL)
                    que.push(p->left);
                if(p->right!=NULL)
                    que.push(p->right);
            }
        }
        return res;
    }
};
```

#### 2.6.0.27. [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        if(nullptr == root) return ans;
        dfs(root, 0);
        return ans;
    }
private:
    vector<int> ans;
    void dfs(TreeNode* root, int depth){
        if(nullptr == root) return;
        if(depth >= ans.size()) ans.push_back(root->val);
        if(root->val > ans[depth]) ans[depth] = root->val;
        dfs(root->left, depth + 1);
        dfs(root->right, depth + 1);
    }
};
```

# 3. ==单调栈&单调队列==

### 3.0.1. 、HZOJ-261-数据结构

1. 关键就是新造一个数据结构，结构定义 + 结构操作
2. 模拟光标的功能，左移动、右移动、插入、删除，用对顶栈模拟
3. 实现对顶栈，用数组模拟、用链表模拟
4. 题目中的 BUG：Query K 中，K 可能大于当前位置

```cpp
#include <cinttypes>
using namespace std;

class NewStruct {
public :
    NewStruct() {
        sum[0] = 0;
        ans[0] = INT64_MIN;
    }
    void insert(long long x) {
        s1.push(x);
        int ind = s1.size();
        long long val = x + sum[ind - 1];
        long long val1 = max(ans[ind - 1], val);
        sum[ind] = val;
        ans[ind] = val1;
        return ;
    }
    void del() {
        if (s1.empty()) return ;
        s1.pop();
        return ;
    }
    void move_left() {
        if (s1.empty()) return ;
        s2.push(s1.top());
        del();
        return ;
    }
    void move_right() {
        if (s2.empty()) return ;
        insert(s2.top());
        s2.pop();
        return ;
    }
    long long query(long long k) {
        return ans[k];
    }
private:
    stack<long long> s1, s2;
    long long sum[1005];
    long long ans[1005];
};

int main() {
    long long n;
    cin >> n;
    string op;
    int val;
    NewStruct s;
    for (int i = 0; i < n; i++) {
        cin >> op;
        switch (op[0]) {
            case 'I': cin >> val; s.insert(val); break;
            case 'D': s.del(); break;
            case 'L': s.move_left(); break;
            case 'R': s.move_right(); break;
            case 'Q': {
                cin >> val; 
                cout << s.query(val) << endl;
            } break;
        }
    }
    return 0;
}
```

### 3.0.2. hzoj-262 卡特兰数



f(n)表示进栈顺序为1,2,...,N时可能的出栈方案数，根据以前的经验，我们需要把它划分成范围更小的子问题。
考虑“1”“1”这个数排在最终序列的位置，可知只要“1”“1”的位置不同，序列就不同。如果“1”“1”这个数排在第*𝑘*k个，那么整个序列进出栈的过程即为：

1. “1”**入栈**。

2. “2,3,...,k"这*𝑘*−1k−1个数按某种顺序**进出栈**。

3. “1”**出栈**。

4. “k+1,k+2,...,N”这*𝑁*−*𝑘*N−k个数按某种顺序**进出栈**。

   由于 k  最后出栈，则在 k 入栈之前所有比他小的都出栈了，这里的情况为 F（k-1），所有比 k 大的元素都在 k 之前出栈，为 F（n-k）种情况

于是这样就把原问题划分成了范围更小的子问题，得到公式：

$f(n)=∑_{i=1}^Nf(k−1)∗f(N−k)$



当然，边界条件为：*𝑓*(0)=1,*𝑓*(1)=1f(0)=1,f(1)=1

时间复杂度为*𝑂*(*𝑛*2)O(n2)。





### 3.0.3. 、HZOJ-263-火车进栈

1. 当前进栈的最大数字是 x，序列中当前待出栈的数字是 y
2. $y <= x$，说明 y 一定是栈顶元素
3. $y > x$，将 $[x + 1, y]$ 入栈，此时栈顶元素一定是 y



```cpp
int a[30], s[30], top;

bool is_valid(int *a, int n) {
    int j = 0;
    top = -1;
    for (int i = 0; i < n; i++) {
        while (j < a[i]) { s[++top] = (++j); }
        if (top == -1 || s[top] - a[i]) return false;
        --top;
    }
    return true;
}

int main() {
    int n, ans = 20;
    cin >> n; 
    for (int i = 0; i < n; i++) a[i] = i + 1;
    do {
        if (!is_valid(a, n)) continue;
        for (int i = 0; i < n; i++) {
            cout << a[i];
        }
        cout << endl;
        --ans;
    } while (ans && next_permutation(a, a + n));
    return 0;
}
```



### 3.0.4. hzoj-68. 朋友队列



![image-20210308140505286](/Image/A1.Data_Structure-photo/image-20210308140505286.png)



Code:

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;
#define MAX_N 200000

map<int, int> q_ind;
queue<int> main_q;
queue<int> q[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    for (int i = 1, m; i <= n; i++) {
        cin >> m;
        for (int j = 1, a; j <= m; j++) {
            cin >> a;
            q_ind[a] = i;
        }
    }
    string op;
    while (cin >> op) {
        if (op == "STOP") break;
        if (op == "ENQUEUE") {
            int x;
            cin >> x;
            q[q_ind[x]].push(x);
            if (q[q_ind[x]].size() == 1) {
                main_q.push(q_ind[x]);
            }
        } else {
            cout << q[main_q.front()].front() << endl;
            q[main_q.front()].pop();
            if (q[main_q.front()].empty()) main_q.pop();
        }
    }
    return 0;
}

```







## 3.1. 二、单调队列







## 3.1. 二、单调队列

1. 本质问题是：固定查询结尾的 RMQ 问题，例如 $RMQ(x, 7)$
2. 问题性质：维护滑动窗口最值问题
3. 入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队
4. 出队：如果队首元素超出了滑动窗口的范围，队首出队
5. 队首元素：滑动窗口内的最值
6. 均摊时间复杂度：$O(1)$

```cpp
#define MAX_N 300000
int q[MAX_N + 5], head = 0, tail = 0;
int val[MAX_N + 5];

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] > val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    head = tail = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] < val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    return 0;
}
```





### 3.1.1. HZOJ-271-滑动窗口

单调队列的裸题，没什么好讲的，主要要学习代码实现

**思考：**单调队列中是记录值还是记录下标的问题

**结论：**记录下标，因为有了下标可以索引到值，记录值则反向不可查

```cpp
#define MAX_N 100000
long long s[MAX_N + 5], top;
long long h[MAX_N + 5], n;
long long l[MAX_N + 5], r[MAX_N + 5];

void read() {
    scanf("%lld", &n);
    for (long long i = 1; i <= n; i++) scanf("%lld", h + i);
    return ;
}

long long solve() {
    h[0] = h[n + 1] = -1;
    top = -1;
    s[++top] = 0;
    for (long long i = 1; i <= n; i++) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        l[i] = s[top];
        s[++top] = i;
    }
    top = -1;
    s[++top] = n + 1;
    for (long long i = n; i >= 1; i--) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        r[i] = s[top];
        s[++top] = i;
    }
    long long ans = 0;
    for (long long i = 1; i <= n; i++) {
        ans = max(ans, h[i] * (r[i] - l[i] - 1));
    }
    return ans;
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}
```





## 3.2. 三、单调栈

1. 单调栈保留了单调队列的『入队』操作
2. 单调栈依然是维护了一种单调性
3. 问题性质：最近（大于/小于）关系
4. 入栈之前，符合单调性的栈顶元素，就是我们要找的最近（大于/小于）关系
5. 均摊时间复杂度：$O(1)$



### 3.2.1. HZOJ-264-最大矩形面积

1. 分析最优解的性质，是解决问题的第一步
2. 最大矩形的性质：一定是以其所在区域中最矮的木板为高度的
3. 以每一块木板做为矩形高度，求能得到的最大矩形面积，最后在所有面积中，取一个最大值
4. 需要求解：每一块木板最近的高度小于当前木板的位置，所以需要用单调栈







# 4. ==字符串匹配算法==

**确定型有穷自动机（Determinism Finite Automate, DFA）**，与**非确定型有穷自动机（Non-determinism Finite Automate, NFA）**。

***next表示长度为i的字符串前缀和后缀的最长公共部分*kmp算法**

next数组三种用法

https://blog.csdn.net/yutianzuijin/article/details/11954939/

![image-20210126164802088](/Image/A1.Data_Structure-photo/image-20210126164802088.png)

Ta是最长前缀(否则漏答案)

**==kmp算法的核心==**即是计算字符串f每一个位置之前的字符串的前缀和后缀公共部分的最大长度

当每次比较到两个字符串的字符不同时，我们就可以根据最大公共长度将字符串f向前移动(已匹配长度-最大公共长度)位，接着继续比较下一个位置。

​    如果位置i和next[i]处的两个字符相同（下标从零开始)，则next[i+1]等于next[i]加1。

​    如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度next[next[i]]，然后再和位置i的字符比较。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为next[next[i]]的字符串，直到字符串长度为0为止

![img](/Image/A1.Data_Structure-photo/20151212110619965)



## 4.1. 一、暴力匹配算法

1. 字符串匹配问题：单模匹配问题，顾名思义，只有一个模式串
2. 依次对齐模式串和文本串的每一位，直到匹配成功
3. 关键：不重不漏的找到答案



## 4.2. 二、KMP 算法

1. KMP 算法中，模式串中的第三部分的重要性
2. 第三部分是可以帮助我们加快匹配速度的，避免掉大量无用的匹配尝试
3. KMP 算法保证不漏：第三部分匹配到的是模式串的最长前缀
4. 普通编码：获得 NEXT 数组，使用 NEXT 数组
5. 高级编码：抽象化了一个状态机模型，j 所指向的就是状态机中的位置
6. getNext 方法相当于根据输入字符，进行状态跳转，实际上就是改变 j 的值

Ta是最长前缀(否则漏答案)

## 4.3. 三、SUNDAY 算法

1. SUNDAY 算法理解的核心，在于理解黄金对齐点位

2. 是文本串的匹配尾部，一定会出现在模式串中的字符

3. 应该和模式串中最后一位出现该字符的位置对齐

4. 第一步：预处理每一个字符在模式串中最后一次出现的位置

5. 第二步：模拟暴力匹配算法过程，失配的时候，文本串指针根据预处理信息向后移动若干位


## 4.4. 一、字符串的哈希匹配算法

   

  1. 可以使用哈希操作判断两个字符串是否相等
  2. 哈希值不同的话，两个字符串一定不相等，从而就不需要按位比较了
  3. $H = (\sum_{k=0}^{n-1}{C_k\times base^k})\%P$
  4. 在文本串上，每一位字符串哈希值的前缀和，方便一会求区间和
  5. $H(i,j)=(HS_j-HS_{i-1})\times (base^i)^{-1}\%P $



拓展欧几里得算法



​	$x_1 * x_2 \% p = 1 x_1$和$x_2$互为逆元

   快速求逆元的推导过程
$$
\begin{aligned}
   x\times x^{-1}&\equiv1\ (mod\ P) \\
   Let：P\%x&=r \\
   P &= kx+r \\
   kx+r &\equiv0\ (mod\ P) \\
   kr^{-1}+x^{-1} &\equiv0\ (mod\ P) \\
   x^{-1} &\equiv-kr^{-1}\ (mod\ P) 
   \end{aligned}
$$

![image-20210126223810625](/Image/A1.Data_Structure-photo/image-20210126223810625-1611674126158.png)

![image-20210126223819648](/Image/A1.Data_Structure-photo/image-20210126223819648-1611674126158.png)




![image-20210126223842372](/Image/A1.Data_Structure-photo/image-20210126223842372-1611674126158.png)

```cpp
#define MAX_N 1000000
#define P 100007
#define base 13
int H[MAX_N + 5];
int K[MAX_N + 5];
int inv[P];
char s[MAX_N + 5];

void init() {
    inv[1] = 1;
    for (int i = 2; i < P; ++i) {
        inv[i] = ((-(P / i) * inv[P % i]) % P + P ) % P;
    }
    K[0] = 1;
    for (int i = 1; i <= MAX_N; ++i) {
        K[i] = (K[i - 1] * base) % P;
    }
    for (int i = 1; s[i]; ++i) {
        H[i] = (H[i - 1] + K[i] * s[i]) % P;
    }
    return ;
}

int getH(int l, int r) {
    return ((H[r] - H[l - 1]) % P * inv[K[l]] % P + P ) % P;
}

int is_same(int i, int j, int n) {
    for (int k = 0; k < n; ++i) {
        if (s[i + k] - s[j + k]) return false;
    }
    return true;
}

```







## 4.5. 二、shift_and 算法



 1. 第一步对模式串做特殊处理，把每一种字符出现的位置，转换成相应的二进制编码
  2. 后续匹配的过程中跟模式串一毛钱关系都没有
  3. $p_i = (p_{i-1}<<1 | 1) \& d[s_i]$
  4. $p_i$第 j 位二进制为1，代表当前位置为结尾，可以匹配成功模式串的第 j 位      

 ![image-20210126223755896](/Image/A1.Data_Structure-photo/image-20210126223755896-1611674126158.png)

![image-20210126231420260](/Image/A1.Data_Structure-photo/image-20210126231420260.png)

   

### 4.5.1. code

```cpp
#define MAX_N 1000
#define TEST(func, a, b) { \
    printf("TEST %s(%s, %s) = %d\n", #func, a, b, func(a, b)); \
}
char text[MAX_N + 5], pattern[MAX_N + 5];

int brute_force(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    for (int i = 0, I = len1 - len2 + 1; i < I; i++) {
        int j = 0;
        for (; t[j]; j++) {
            if (t[j] == s[i + j]) continue;
            break;
        }
        if (!t[j]) return i;
    }
    return -1;
}

int sunday(char *s, char *t) {
    int ind[128] = {0};
    int len1 = strlen(s);
    int len2 = strlen(t);
    //len2 + 1是因为没出现过，后一位是i+len2, 所以从 i + len2 + 1匹配
    for (int i = 0; i < 128; i++) ind[i] = len2 + 1;
    for (int i = 0; t[i]; i++) ind[t[i]] = len2 - i;
    for (int i = 0, I = len1 - len2 + 1; i < I;) {
        int flag = 1;
        for (int j = 0; j < len2; j++) {
            if (t[j] == s[i + j]) continue;
            i += ind[s[i + len2]];
            flag = 0;
            break;
        }
        if (flag) return i;
    }
    return -1;
}

int shift_and(char *s, char *t) {
    int code[128] = {0};
    int len = 0;
    for (len = 0; t[len]; len++) {
        code[t[len]] |= (1 << len);
    }
    int p = 0;
    for (int i = 0; s[i]; i++) {
        p = (p << 1 | 1) & code[s[i]];
        if (p & (1 << (len - 1))) return i - len + 1;
    }
    return -1;
}

int kmp(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    int *next = (int *)malloc(sizeof(int) * len2);
    next[0] = -1;
    for (int i = 1, j = -1; i < len2; i++) {
        while (j != -1 && t[j + 1] != t[i]) j = next[j];
        if (t[j + 1] == t[i]) j += 1;
        next[i] = j;
    }
    for (int i = 0, j = -1; s[i]; i++) {
        while (j != -1 && t[j + 1] != s[i]) j = next[j];
        if (t[j + 1] == s[i]) j += 1;
        if (t[j + 1] == 0) return i - len2 + 1;
    }
    free(next);
    return -1;
}

int main() {
    scanf("%s%s", text, pattern);
    TEST(brute_force, text, pattern);
    TEST(kmp, text, pattern);
    TEST(sunday, text, pattern);
    TEST(shift_and, text, pattern);
    return 0;
}
```

### 4.5.2. oj-275

```cpp
#define MAX_N 1000000
#define P 9973
#define P1 100007
#define base 13
#define base1 103
long long H[MAX_N + 5];
long long H1[MAX_N + 5];
long long K[MAX_N + 5];
long long K1[MAX_N + 5];
long long inv[P];
long long inv1[P1];
char s[MAX_N + 5];

void init() {
    inv[1] = 1;
    inv1[1] = 1;
    for (long long i = 2; i < P; i++) {
        inv[i] = ((-(P / i) * inv[P % i]) % P + P) % P;
        inv1[i] = ((-(P1 / i) * inv1[P1 % i]) % P1 + P1) % P1;
    }
    K[0] = 1;
    K1[0] = 1;
    for (long long i = 1; i <= MAX_N; i++) {
        K[i] = (K[i - 1] * base) % P;
        K1[i] = (K1[i - 1] * base1) % P1;
    }
    H[0] = 0;
    H1[0] = 0;
    for (long long i = 1; s[i]; i++) {
        H[i] = (H[i - 1] + K[i] * s[i]) % P;
        H1[i] = (H1[i - 1] + K1[i] * s[i]) % P1;
    }
    return ;
}

long long getH(long long l, long long r) {
    return ((H[r] - H[l - 1]) % P * inv[K[l]] % P + P) % P;
}

long long getH1(long long l, long long r) {
    return ((H1[r] - H1[l - 1]) % P1 * inv1[K1[l]] % P1 + P1) % P1;
}

int main() {
    scanf("%s", s + 1);
    long long m, l1, l2, r1, r2;
    init();
    scanf("%lld", &m);
    for (long long i = 0; i < m; i++) {
        scanf("%lld%lld%lld%lld", &l1, &r1, &l2, &r2);
        if (getH(l1, r1) == getH(l2, r2) && getH1(l1, r1) == getH1(l2, r2)) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }
    return 0;
}
```





#### 4.5.2.1. [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));
        string ans;
        for (int l = 0; l < n; ++l) {
            for (int i = 0; i + l < n; ++i) {
                int j = i + l;
                if (l == 0) {
                    dp[i][j] = 1;
                } else if (l == 1) {
                    dp[i][j] = (s[i] == s[j]);
                } else {
                    dp[i][j] = (s[i] == s[j] && dp[i + 1][j - 1]);
                }
                if (dp[i][j] && l + 1 > ans.size()) {
                    ans = s.substr(i, l + 1);
                }
            }
        }
        return ans;
    }
};

```



#### 4.5.2.2. HZOJ-278-循环字符串.cpp

```cpp
using namespace std;
#define MAX_N 1000000
char str[MAX_N + 5];
int nxt[MAX_N + 5];
int ans[MAX_N + 5];

void get_next(char *str, int *nxt) {
    int j = -1;
    nxt[0] = -1;
    for (int i = 1; str[i]; i++) {
        while (j != -1 && str[j + 1] != str[i]) j = nxt[j];
        if (str[j + 1] == str[i]) j += 1;
        nxt[i] = j;
    }
    return ;
}

int main() {
    int n;
    cin >> n;
    cin >> str;
    get_next(str, nxt);
    for (int i = 0; i < n; i++) {
        if (nxt[i] == -1 || i - nxt[i] != ans[nxt[i]]) {
            ans[i] = i + 1;
        } else {
            ans[i] = ans[nxt[i]];
        }
    }
    for (int i = 0; i < n; i++) {
        if (ans[i] == i + 1) continue;
        cout << i + 1 << " " << (i + 1) / ans[i] << endl;
    }
    return 0;
}
```

#### 4.5.2.3. HZOJ-281-前缀统计

```cpp
using namespace std;
#define MAX_N 1000000

struct Node {
    int flag;
    int next[26];
} tree[MAX_N + 5];
int root = 1, cnt = 1;
char str[MAX_N + 5];

int getNode() { return ++cnt; }
void insert(const char *str) {
    int p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - 'a';
        if (tree[p].next[ind] == 0) tree[p].next[ind] = getNode();
        p = tree[p].next[ind];
    }
    tree[p].flag += 1;
    return ;
}

int query(const char *str) {
    int p = root, cnt = 0;
    for (int i = 0; str[i] && p; i++) {
        p = tree[p].next[str[i] - 'a'];
        cnt += tree[p].flag;
    }
    return cnt;
}
```

#### 4.5.2.4. HZOJ-282-最大亦或和

      1. 思考：如何使得异或结果尽可能大
      2. 结论：参与异或运算的两个数字，参与异或运算的每一位尽可能不同
      3. 问题转换为：确定一个数字的情况下，找到从高为到低位与当前数字尽量不同的另外一个数字
      4. 把每个数字看成一个二进制字符串，插入到字符串中，采用贪心策略进行选择

  

















```cpp
#define MAX_N 320000
#define BASE 30

struct Node {
    int num;
    int next[2];
} tree[MAX_N + 5];
int root = 1, cnt = 1;
int arr[(MAX_N >> 5 )+ 5];
inline int getNode() { return ++cnt; }
void insert(int num) {
    int p = root;
    for (int i = BASE; i >= 0; --i) {
        int ind = !!((1 << i) & num);
        if (tree[p].next[ind] == 0) tree[p].next[ind] = getNode();
        p = tree[p].next[ind];
    }
    tree[p].num = num;
    return ;
}

int query(int num) {
    int p = root;
    for (int i = BASE; i >= 0; i--) {
        int ind = !!((1 << i) & num);
        int rind = !ind;
        if (tree[p].next[rind]) p = tree[p].next[rind];
        else p = tree[p].next[ind];
    }
    return num ^ tree[p].num;
}

int main() {
    int n, ans = 0;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> arr[i], insert(arr[i]);
    for (int i = 0; i < n; i++) {
        ans = max(ans, query(arr[i]));
    }
    cout << ans << endl;
    return 0;
}
```



# 5. ==字典树==

名称：trie， 字典树，单词查找树

作用：单词查找，字符串排序

      1. 也叫做：前缀索引树
      2. 把每个字符串按照前缀的顺序插入到树形结构中
      3. 字典树可以用于字符串的排序，时间复杂度 $O(n)$

字典树等价于单词表

![image-20210126235307421](/Image/A1.Data_Structure-photo/image-20210126235307421-1623756908422.png)

9 < 11 字典序:09 < 11 ->文件夹命名排序

红色节点可做结尾，独立成词，边代表字母

比较操作的时间下限为O(nlogn);

字典序排序单词：为O(n); 

小点：系统命名是1,2,3，...10直接排前，字典序

计算机：学习信息的表示

操作系统：如何表示文件，配置文件，

计算机网络：如何合理封装信息，如何保证，协议

- 

```cpp
#define BASE 26
#define BASE_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

inline int code(char ch) {
    return ch - BASE_LETTER;
}

void insert(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();
        p = p->next[code(str[i])];
    }
    p->flag = 1;
    return ;
}

int query(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        p = p->next[code(str[i])];
        if (p == NULL) return 0;
    }
    return p->flag;
}

void output(Node *root, int k, char *buff) {
    if (root == NULL) return ;
    if (root->flag) printf("%s\n", buff);
    for (int i = 0; i < BASE; i++) {
        buff[k] = BASE_LETTER + i;
        buff[k + 1] = '\0';
        output(root->next[i], k + 1, buff);
    }
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    char str[1000];
    int n;
    Node *root = getNewNode();
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    output(root, 0, str);
    while (~scanf("%s", str)) {
        printf("query %s, result = %s\n", str, query(root, str) ? "Yes" : "No");
    }
    return 0;
}
```

指针变量-8字节(sizeof(int *))



# 6. ==双数组字典树==

## 6.1. 传统字典树的缺点

1. 完全二叉树，实际存储结构是连续数组空间，思维逻辑结构是树型的
2. 完全二叉树，节省了大量的存储边的空间
3. 优化思想：记录式 改 计算式
4. $n$ 个节点的字典树，有效使用 $n-1$ 条边，浪费了 $(k-1)*n+1$ 条边的存储空间
5. 参考完全二叉树的优点，提出了双数组字典树



## 6.2. 双数组字典树

1. 顾名思义，两个数组代表一棵字典树结构
2. base 数组信息与子节点编号相关，base + i 就是第 i 个子节点编号
3. check 数组信息负责做【亲子鉴定】，check 数组中用正负表示是否独立成词
4. 不擅长进行动态插入操作
5. 一次建立，终身使用
6. 为了方便，基于普通字典树实现的双数组字典树
7. 增加了 fail 数组，可以完成基于双数组字典树的 AC 自动机
8. 超小规模实验结果：双数组字典树压缩效率是 25 倍
9. 非常方便的输出到文件中，进行机器之间的共享
10. 课后作业：利用真实数据集，测试双数组字典树的压缩效率
11. base值可以相同,base的子节点的值才重要,不可以冲突



## 6.3. 二叉字典树

1. 计算机中所有信息都是二进制存储的
2. 任何信息都可以看成一个二进制串
3. 插入二进制串的字典树，就是二叉字典树
4. 二叉字典树可以存储任意信息
5. 节省空间，浪费时间，本质：时间换空间的算法思维
6. 哈弗曼编码 + 二叉字典树 可能更配哦，既节省了空间，又在最大限度上节省了查找时间



不积跬步，无以至千里。不积小流，无以成江海。



**建议：**多看几本基本的算法书、【数论基础】、多接触离散型数学思维



字典树叶子节点浪费空间过大

记录式转计算式

### 6.3.1. 双数组字典树

![image-20201017104134948](/Image/A1.Data_Structure-photo/image-20201017104134948.png)


**==信息的等价==**

只是修改了字典树的表示方式---计算机本质就是信息的表示

双数组字典树是离散构建的，不太支持动态插入，其实它是字典文件->建立对应字典树->转为相应双数组字典树

父节点与子节点的关系的计算式表示：

- base[]：计算父子节点的边的中间量

  ​	father的第i个孩子(i是字符编码) ： child_i = base[father] + i;

- check[]：记录每个子节点的真正父节点, 以及是否独立成词(正负)

  ​	check[child_i] = father;

  ​	check[child_i] = -father; 负数额外代表独立成词

  ​	不可记录0号，从1号开始；相应节点的父节点不可为0号

  ​	初始check[]为0，代表未占用，一旦记录一定非0；

- base[child_i] = 

记录更多的信息，可通过封装结构体，多个数组

### 6.3.2. 二叉字典树+哈夫曼编码

编码：根据问题场景来等价信息表示。

哈夫曼编码：将信息表示为最短

回答：

- 哈夫曼编码算出：需要的信息，统计问题场景下的概率；

- 对中文字符集编码：一个中文占若干编码，对每个字节编码

### 6.3.3. 基于字典树的 AC 自动机

```cpp
/*************************************************************************
   > File Name: 12.double_array_trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  8/21 14:14:38 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DATrie {
    int *base, *check;
    int root, size;
} DATrie;

DATrie *getDATrie(int n) {
    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);
    tree->root = 1;
    tree->size = n;
    tree->base = (int *)calloc(sizeof(int), n);
    tree->check = (int *)calloc(sizeof(int), n);
    tree->check[tree->root] = 1;
    return tree;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int getBaseValue(Node *root, DATrie *tree) {
    int base = 0, flag;
    do {
        flag = 1;
        base += 1;
        for (int i = 0; i < BASE; i++) {
            if (root->next[i] == NULL) continue;
            if (tree->check[base + i] == 0) continue;
            flag = 0;
            break;
        }
    } while (!flag);
    return base;
}

int buildDATrie(int ind, Node *root, DATrie *tree) {
    int base = tree->base[ind] = getBaseValue(root, tree);
    int ans = ind;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree->check[base + i] = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        int temp = buildDATrie(base + i, root->next[i], tree);
        if (temp > ans) ans = temp;
    }
    if (root->flag) tree->check[ind] = -tree->check[ind];
    return ans;
}

int query(DATrie *tree, const char *str) {
    int p = tree->root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;
        p = tree->base[p] + ind;
    }
    return tree->check[p] < 0;
}

void clearDA(DATrie *tree) {
    if (tree == NULL) return ;
    free(tree->base);
    free(tree->check);
    free(tree);
    return ;
}

int main() {
    int n, cnt1 = 1, cnt2;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    while (n--) {
        scanf("%s", str);
        cnt1 += insert(root, str);
    }
    DATrie *tree = getDATrie(cnt1 * BASE + 5);
    cnt2 = buildDATrie(tree->root, root, tree) + 1;
    while (~scanf("%s", str)) {
        printf("search %s, result = %s\n", str, query(tree, str) ? "YES" : "NO");
    }
    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;
    printf("Trie memory : %d Bytes\n", mem1);
    printf("Double Array Trie memory : %d Bytes\n", mem2);
    printf("memory rate : %.4lf%%\n", 1.0 * mem2 / mem1 * 100);
    clearDA(tree);
    clear(root);
    return 0;
}
```

### 6.3.4. 基于双数组字典树的 AC 自动机

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BASE 26
#define BEGIN_LETTER 'a'
#define max(a, b) ((a) > (b) ? (a) : (b))
#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)

typedef struct DANode {
    int base, check, fail;
    char *str;
} DANode;

typedef struct Node {
    int flag;
    char *str;
    struct Node *next[BASE];
} Node, *Trie;

int node_cnt = 0;

Node *get_new_node() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    node_cnt += 1;
    return p;
}

void clear(Trie root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    if (root->flag) free(root->str);
    free(root);
    return ;
}

Node *insert(Trie root, const char *str) {
    if (root == NULL) root = get_new_node();
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = get_new_node();
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return root;
}

int get_base(Node *node, DANode *data) {
    int base = 2, flag = 0;
    while (!flag) {
        flag = 1;
        for (int i = 0; i < BASE; i++) {
            if (node->next[i] == NULL) continue;
            if (data[base + i].check == 0) continue;
            flag = 0;
            break;
        }
        base += (!flag);
    }
    return base;
}

int build(Node *node, DANode *data, int ind) {
    if (node == NULL) return 0;
    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;
    int max_ind = ind;
    data[ind].base = get_base(node, data);
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        data[data[ind].base + i].check = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        int temp = build(node->next[i], data, data[ind].base + i);
        max_ind = max(max_ind, temp);
    }
    return max_ind;
}

void build_ac(DANode *data) {
    #define MAX_N 100000
    int *queue = (int *)malloc(sizeof(int) * MAX_N);
    int head = 0, tail = 0;
    data[1].fail = 0;
    queue[tail++] = 1;
    while (head < tail) {
        int ind = queue[head++];
        for (int i = 0; i < BASE; i++) {
            if (!has_child(data, ind, i)) continue;
            int p = data[ind].fail;
            while (p && !has_child(data, p, i)) p = data[p].fail;
            if (p == 0) p = 1;
            else p = data[p].base + i;
            data[data[ind].base + i].fail = p;
            queue[tail++] = data[ind].base + i;
        }
    }
    return ;
    #undef MAX_N
}

void search_ac(DANode *data, const char *str) {
    int p = 1;
    for (int i = 0; str[i]; i++) {
        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;
        if (p == 0) p = 1;
        else p = data[p].base + str[i] - BEGIN_LETTER;
        int q = p;
        while (q) {
            if (data[q].check < 0) printf("find string : %s\n", data[q].str);
            q = data[q].fail;
        }
    }
    return ;  
}

void output_da(DANode *data, int n) {
    for (int i = 1; i <= n; i++) {
        if (i - 1 && i % 5 == 1) printf("\n");
        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);
    }
    printf("\n");
    return ;
}

int main() {
    Trie root = NULL;
    #define INSERT_CNT 5
    root = insert(root, "hai");
    root = insert(root, "zei");
    root = insert(root, "ha");
    root = insert(root, "ab");
    root = insert(root, "ehz");
    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));
    int da_cnt = build(root, data, 1);
    build_ac(data);
    output_da(data, da_cnt);
    search_ac(data, "sasherhs");
    #undef INSERT_CNT 
    return 0;
}
```



### 6.3.5. kaikeiba

```cpp
/*************************************************************************
	> File Name: 1.double_array_trie.cpp
	> Author: huguang
	> Mail: hug@haizeix.com
	> Created Time: 
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;

#define BASE 26
#define MSG_LEVEL 2
#define DEBUG_LEVEL 1
#define INFO_LEVEL 2

#define LOG(level, frm, args...) { \
    if (level >= MSG_LEVEL) { \
        printf(frm,##args); \
    } \
}

#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args)
#define LOG_INFO(args...) LOG(INFO_LEVEL, args)

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DANode {
    int base, check, fail;
} DANode;

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {
            cnt += 1;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear_trie(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;
    int base = get_base_value(root, tree, ind);
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {
        int a = transform_double_array_trie(root->next[i], tree, base + i);
        if (a > max_ind) max_ind = a;
    }
    return max_ind;
}

void dump_double_array_trie(DANode *tree, int n) {
    LOG_INFO("%d\n", n);
    for (int i = 0; i <= n; i++) {
        LOG_INFO("%d %d %d\n", tree[i].base, tree[i].check, tree[i].fail);
    }
    return ;
}

void build_ac_base_double_array_trie(DANode *tree, int max_ind) {
    int *que = (int *)malloc(sizeof(int) * (max_ind + 5));
    int head, tail;
    head = tail = 0;
    tree[1].fail = 0;
    for (int i = 0; i < BASE; i++) {
        int child_ind = tree[1].base + i;
        if (abs(tree[child_ind].check) != 1) continue;
        tree[child_ind].fail = 1;
        que[tail++] = child_ind;
    }
    while (head < tail) {
        int p = que[head++];
        for (int i = 0; i < BASE; i++) {
            int c = tree[p].base + i, k = tree[p].fail;
            if (abs(tree[c].check) != p) continue;
            while (k && abs(tree[tree[k].base + i].check) != k) k = tree[k].fail;
            if (k == 0) k = 1;
            if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;
            tree[c].fail = k;
            que[tail++] = c;
        }
    }
    free(que);
    return ;
}

int main() {
    int n, cnt = 1;
    char str[1000];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    LOG_DEBUG("trie(%lu Byte), double array trie(%lu Byte)\n", s1, s2);
    LOG_DEBUG("rate : %.2lf\n", 1.0 * s2 / s1);
    for (int i = 0; i <= max_ind; i++) {
        LOG_DEBUG("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1) % 5 == 0) LOG_DEBUG("\n");
    }
    LOG_DEBUG("\n");
    build_ac_base_double_array_trie(tree, max_ind);
    dump_double_array_trie(tree, max_ind);
    free(tree);
    clear_trie(root);
    return 0;
}
```





### 6.3.6. AC 自动机的递归建立

## 6.4.  

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode* fail, *father;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->fail = NULL;
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
            p->childs[buffer[i] - BASE]->father = p;
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    #define next childs
    #define Node TrieNode
    if (node == NULL) return ;
    if (node->fail == NULL) build_automaton(node->father);
    for (int i = 0; i < SIZE; i++) {
        if (node->next[i] == NULL) continue;
        if (node->next[i]->fail) continue;
        Node *p = node->fail, *pre_p = node;
        while (p && p->next[i] == NULL) {
            if (p->fail == NULL) build_automaton(p->father);
            pre_p = p;
            p = p->fail;
        }
        if (p == NULL) p = pre_p;
        else p = p->next[i];
        node->next[i]->fail = p;
        build_automaton(node->next[i]);
    }
    return ;
    #undef next
    #undef Node
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        while (p && p->childs[str[0] - 'a'] == NULL) p = p->fail;
        if (p == NULL) p = ac_tree;
        else p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        str++;
    }
    return ret;
}

int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```

### 6.4.1. AC 自动机的线索化

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode *fail;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));
    int head = 0, tail = 0;
    queue[tail++] = node;
    while (head < tail) {
        TrieNode *now = queue[head++];
        for (int i = 0; i < SIZE; i++) {
            if (now->childs[i] == NULL) {
                if (now != node) now->childs[i] = now->fail->childs[i];
                continue;
            }
            TrieNode *p = (now->fail ? now->fail->childs[i] : node);
            if (p == NULL) p = node;
            now->childs[i]->fail = p;
            queue[tail++] = now->childs[i];
        }
    }
    free(queue);
    return ;
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        if (p == NULL) p = ac_tree;
        str++;
    }
    return ret;
}
int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    printf("insert done\n");
    fflush(stdout);
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```



# 7. ==多模匹配问题==

1. 有多个模式串的匹配问题，就是多模匹配问题
2. Step1：多个模式串，建立成一棵字典树
3. Step2：和文本串的每一位对齐匹配，模拟暴力匹配算法的过程



## 7.1. AC 自动机的思想

1. 当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he
2. she 对应了字典树中的节点 P，he 对应了字典树中的节点Q
3. P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程
4. 在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作
5. 这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】等价匹配指针
6. AC 自动机 = Trie + Fail 指针
7. 子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】
8. 没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）
9. 通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态
10. 第二种理解：当前状态，并不代表唯一状态。

**AC 自动机优化：**使用路径压缩思想，使状态转移时可以一步跳转到目标状态。

优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。

![image-20210127193634993](/Image/A1.Data_Structure-photo/image-20210127193634993.png)

![image-20210127193826398](/Image/A1.Data_Structure-photo/image-20210127193826398.png)

![image-20210217201415813](/Image/A1.Data_Structure-photo/image-20210217201415813.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE], *fail;
} Node;

typedef struct Queue {
    Node **data;
    int head, tail, size;
} Queue;

Queue *init_queue(int n) {
    Queue *q = (Queue *)calloc(sizeof(Queue), 1);
    q->data = (Node **)malloc(sizeof(Node *) * n);
    q->tail = q->head = 0;
    return q;
}

Node *front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->head == q->tail;
}

void push(Queue *q, Node *node) {
    q->data[q->tail++] = node;
    return ;
}

void pop(Queue *q) {
    if (empty(q)) return ;
    q->head++;
}

void clear_queue(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *node) {
    if (node == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(node->next[i]);
    }
    free(node);
    return ;
}

void build_ac(Node *root, int n) {
    Queue *q = init_queue(n + 10);
    root->fail = NULL;
    push(q, root);
    while (!empty(q)) {
        Node *now_node = front(q);
        pop(q);
        for (int i = 0; i < BASE; i++) {
            if (now_node->next[i] == NULL) continue;
            Node *p = now_node->fail;
            while (p && p->next[i] == NULL) p = p->fail;
            if (p == NULL) now_node->next[i]->fail = root;
            else now_node->next[i]->fail = p->next[i];
            push(q, now_node->next[i]);
        }
    }
    return ;
}

int match(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        while (p && p->next[ind] == NULL) p = p->fail;
        if (p == NULL) p = root;
        else p = p->next[ind];
        Node *q = p;
        while (q) cnt += q->flag, q = q->fail;
    }
    return cnt;
}

int main() {
    Node *root = getNewNode();
    int n, cnt = 0;
    char str[1000];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    // build ac
    build_ac(root, cnt);
    scanf("%s", str);
    // match ac
    printf("match word cnt : %d\n", match(root, str));
    return 0;
}
```



## 7.2. 预习资料：【数据结构】> 字符串统计

1. AC 自动机裸题

2. 解题的关键，在于如何维护每一个单词的计数量

3. 使用幼儿园必知必会的指针技巧维护的

4. **船长翻车：**题目数据中给出的单词会有重复

   



### 7.2.1. 存储任意类型的栈

```cpp
/*************************************************************************
   > File Name: 15.any_stack.h
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  2/28 10:49:10 2018
 ************************************************************************/

#ifndef _15_ANY_STACK_H
#define _15_ANY_STACK_H

#include <stdlib.h>
#include <string.h>

#define STACK_OK 1
#define STACK_ERROR 0

typedef struct Stack {
    char *data;
    int data_size;
    int size, top;
} Stack;

#define init_stack(n, T) (__init_stack(n, sizeof(T)))
#define push_stack(s, data) (__push_stack(s, (char *)(data)))
#define top_stack(s, T) ((T *)(__top_stack(s)))

Stack *__init_stack(int n, int data_size) {
    Stack *s = (Stack *)malloc(sizeof(Stack) * 1);
    s->data = (char *)malloc(n * data_size);
    s->data_size = data_size;
    s->size = n;
    s->top = -1;
    return s;
}

int __push_stack(Stack *s, char *data) {
    if (s->size - 1 == s->top) {
        return STACK_ERROR;
    }
    s->top += 1;
    memcpy(s->data + s->top * s->data_size, data, s->data_size);
    return STACK_OK;
}

int empty_stack(Stack *s) {
    return s->top == -1;
}

char *__top_stack(Stack *s) {
    if (empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->data_size;
}

int pop_stack(Stack *s) {
    if (empty_stack(s)) {
        return STACK_ERROR;
    }
    s->top -= 1;
    return STACK_OK;
}

void clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}

#endif
```

### 7.2.2. 二叉树前序遍历（非递归）

```cpp
/*************************************************************************
   > File Name: 14.binary_non_recursive.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  2/28 10:26:37 2018
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "15.any_stack.h"

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int data) {
    Node *p = (Node *)malloc(sizeof(Node) * 1);
    p->data = data;
    p->lchild = p->rchild=  NULL;
    return p;
}

Node *init_binary_tree() {
    Node *root = getNewNode(1);
    root->lchild = getNewNode(3);
    root->rchild = getNewNode(6);
    root->lchild->rchild = getNewNode(9);
    root->rchild->rchild = getNewNode(11);
    root->rchild->lchild = getNewNode(14);
    root->lchild->rchild->lchild = getNewNode(17);
    return root;
}

void __pre_order(Node *root) {
    // status = 0
    if (root == NULL) return ; // status = 100
    printf("%d\n", root->data); // status = 1
    __pre_order(root->lchild); // status = 2
    __pre_order(root->rchild); // status = 3
    return ; // status = 100
}

typedef struct PreOrderArgs {
    Node *root;
    int status;
} PreOrderArgs;

PreOrderArgs *getNewArgs(Node *root) {
    PreOrderArgs *p = (PreOrderArgs *)malloc(sizeof(PreOrderArgs) * 1);
    p->root = root;
    p->status = 0;
    return p;
}

void pre_order(Node *root) {
    Stack *s = init_stack(100, PreOrderArgs);
    PreOrderArgs *temp_args = getNewArgs(root), *p_args;
    push_stack(s, temp_args);
    while (!empty_stack(s)) {
        p_args = top_stack(s, PreOrderArgs);
        switch (p_args->status) {
            case 0: {
                if (p_args->root == NULL) {
                    p_args->status = 100;
                } else {
                    p_args->status = 1;
                }
            } break;
            case 1: {
                printf("%d\n", p_args->root->data);
                p_args->status = 2;
            } break;
            case 2: {
                temp_args->root = p_args->root->lchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 3;
            } break;
            case 3: {
                temp_args->root = p_args->root->rchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 100;
            } break;
            case 100: {
                pop_stack(s);
            } break;
        }
    }
    free(temp_args);
    clear_stack(s);
    return ;
}



int main() {
    Node *root = init_binary_tree();
    pre_order(root);
    __pre_order(root);
    return 0;
}
```

### 7.2.3. 快速排序（非递归）



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MC(T, n) ((T *)malloc(sizeof(T) * n))

#define init_stack(s, n, T) (__init_stack(s, n, sizeof(T)))
#define push_stack(s, value) ({ \
    __typeof(value) __temp = (value); \
    __push_stack(s, (const char *)(&(__temp))); \
})

#define empty_stack(s) (__empty_stack(s))
#define pop_stack(s) (__pop_stack(s))
#define top_stack(s, T) (*((T *)__top_stack(s)))
#define clear_stack(s) (__clear_stack(s))
#define swap(a, b) { \
    __typeof(a) __temp = (a); \
    (a) = (b); (b) = (__temp); \
}
#define ERROR 0
#define OK 1

typedef struct Stack {
    char *data;
    int top, size;
    int value_size;
} Stack;

void __init_stack(Stack *s, int n, int value_size);
int __push_stack(Stack *s, const char *value);
int __empty_stack(Stack *s);
int __pop_stack(Stack *s);
char *__top_stack(Stack *s);
void __clear_stack(Stack *s);

typedef struct Node {
    int val;
    struct Node *lchild, *rchild;
} Node;

Node *init(int val) {
    Node *p = MC(Node, 1);
    p->val = val;
    p->lchild = p->rchild = NULL;
    return p;
}

typedef struct QuickSortArgs {
    int *arr;
    int l, r;
    int x;
    int status;
} QuickSortArgs;

int __quick_sort(int *arr, int l, int r) {
    // 0 : if (r <= l) return ;
    int x, y, z;
    x = l, y = r, z = arr[l];
    while (x < y) {
        while (x < y && arr[y] >= z) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] <= z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    return x;
    // 2: quick_sort(arr, l, x - 1);
    // 3 : quick_sort(arr, x + 1, r);
    // 4 : return ;
}

void init_quick_sort_args(QuickSortArgs *qsa, int *arr, int l, int r, int status) {
    qsa->arr = arr;
    qsa->l = l;
    qsa->r = r;
    qsa->status = 0;
    return ;
}

void quick_sort(int *arr, int n) {
    Stack *s = MC(Stack, 1);
    init_stack(s, 1000, QuickSortArgs);
    QuickSortArgs qsa;
    init_quick_sort_args(&qsa, arr, 0, n - 1, 0);
    push_stack(s, qsa);
    while (!empty_stack(s)) {
        QuickSortArgs *tqsa = &top_stack(s, QuickSortArgs);
        switch (tqsa->status) {
            case 0:
                if (tqsa->r <= tqsa->l) {
                    tqsa->status = 4;
                } else {
                    tqsa->status = 1;
                }
                break;
            case 1:
                tqsa->x = __quick_sort(tqsa->arr, tqsa->l, tqsa->r);
                tqsa->status = 2;
                break;
            case 2:
                init_quick_sort_args(&qsa, arr, tqsa->l, tqsa->x - 1, 0);
                push_stack(s, qsa);
                tqsa->status = 3;
                break;
            case 3:
                init_quick_sort_args(&qsa, arr, tqsa->x + 1, tqsa->r, 0);
                push_stack(s, qsa);
                tqsa->status = 4;
                break;
            case 4:
                pop_stack(s);
                break;
            default:
                printf("ERROR\n");
                break;
        }
    }
    return ;
}

int main() {
    int arr[10] = {9, 7, 5, 4, 2 ,1 ,3, 10, 6, 8};
    quick_sort(arr, 10);
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
void __init_stack(Stack *s, int n, int value_size) {
    s->data = (char *)malloc(value_size * n);
    s->top = -1;
    s->size = n;
    s->value_size = value_size;
    return ;
}

int __push_stack(Stack *s, const char *value) {
    if (s->top == s->size - 1) {
        return ERROR;
    }
    ++(s->top);
    memcpy(s->data + s->top * s->value_size, value, s->value_size);
    return OK;
}

int __empty_stack(Stack *s) {
    return s->top == -1;
}

int __pop_stack(Stack *s) {
    if (__empty_stack(s)) {
        return ERROR;
    }
    --(s->top);
    return OK;
}

char *__top_stack(Stack *s) {
    if (__empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->value_size;
}

void __clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}
```



# 8. ==并查集==



根节点：全集

子节点：子集

![image-20201018110356663](/Image/A1.Data_Structure-photo/image-20201018110356663.png)

按尺寸(正规说法叫做秩)进行平衡，按秩优化

![image-20201018110407696](/Image/A1.Data_Structure-photo/image-20201018110407696.png)

辅以路径压缩后，树结构会高度扁平化。

![image-20201018110431340](/Image/A1.Data_Structure-photo/image-20201018110431340.png)

![image-20201018110438419](/Image/A1.Data_Structure-photo/image-20201018110438419.png)



离散化--重映射(map)



根节点有特殊意义的并查集，带权并查集

用并查集去维护编号，一个放在另一个建立关系http://oj.haizeix.com/problem/324

用并查集去维护最近的一个空位置，http://oj.haizeix.com/problem/323

### 8.0.4. quick-union

```cpp
#include <stdio.h>
#include <stdlib.h>

#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for (int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    //if (u->size[fa] < u->size[fb]) swap(fa, fb);
    u->father[fb] = fa;
    //u->size[fa] += u->size[fb];
    return 1;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->father);
    free(u->size);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        switch (a) {
            case 1: merge(u, b, c); break;
            case 2: printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No"); break;
        }
    }
    clear(u);
    return 0;
}

```

### 8.0.5. HZOJ-72-猜拳.cpp

![image-20201022132834261](/Image/A1.Data_Structure-photo/image-20201022132834261.png)

0:x与y平手

1:x输给y

2:x赢y



```cpp
/*************************************************************************
   > File Name: 72.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  8/21 20:47:24 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 10000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; i++) fa[i] = i; 
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 3;
        return fa[x] = root;
    }
    void merge(int a, int b, int c) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        val[aa] = (c + val[b] - val[a] + 3) % 3;
        return ;
    }
};

UnionSet u;

void read(int &n, int &m) {
    cin >> n >> m;
    u.init(n);
    return ;
}

int main() {
    int n, m;
    read(n, m);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            u.merge(b, c, 2);
        } else {
            if (u.get(b) != u.get(c)) {
                cout << "Unknown" << endl;
            } else {
                switch ((u.val[b] - u.val[c] + 3) % 3) {
                    case 0: cout << "Tie" << endl; break;
                    case 1: cout << "Loss" << endl; break;
                    case 2: cout << "Win" << endl; break;
                }
            }
        }
    }
    return 0;
}
```

### 8.0.6. HZOJ-73-湖泊.cpp

```cpp
 
/*************************************************************************
   > File Name: 73.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 四  8/22 14:19:28 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 1000
#define MAX_M 1000000
#define ind(i, j) ((i) * (m) + (j) + 1)
char g[MAX_N + 5][MAX_N + 5];

struct UnionSet {
    int fa[MAX_M + 5];
    void init(int n) {
        for (int i = 0; i <= n; i++) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

UnionSet u;

int main() {
    int n, m;
    cin >> n >> m;
    u.init(n * m);
    for (int i = 0; i < n; i++) {
        cin >> g[i];
        for (int j = 0; j < m; j++) {
            if (g[i][j] == 'X') continue;
            if (i && g[i - 1][j] == 'O') u.merge(ind(i, j), ind(i - 1, j));
            if (j && g[i][j - 1] == 'O') u.merge(ind(i, j), ind(i, j - 1));
            if (i == 0 || i == n - 1) u.merge(ind(i, j), 0);
            if (j == 0 || j == m - 1) u.merge(ind(i, j), 0);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (g[i][j] == 'X') continue;
            if (u.get(ind(i, j)) - u.get(0)) ans += 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 8.0.7. 程序自动分析

离散做法：根据相等建立并查集，判断不等

```
#define MAX_N 1000000
struct UnionSet {
    int fa[(MAX_N << 1) + 5];
    void init(int n) {
        while (n--) fa[n + 1] = n + 1;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

UnionSet u;

struct Data {
    int e, i, j;
} arr[MAX_N + 5];

void solve() {
    map<int, int> ind;
    int cnt = 0;
    int n;
    cin >> n;
    u.init(2 * n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i].i >> arr[i].j >> arr[i].e;
        if (ind.find(arr[i].i) == ind.end()) ind[arr[i].i] = (++cnt);
        if (ind.find(arr[i].j) == ind.end()) ind[arr[i].j] = (++cnt);
        arr[i].i = ind[arr[i].i];
        arr[i].j = ind[arr[i].j];
    }
    for (int i = 0; i < n; i++) {
        if (arr[i].e == 0) continue;
        u.merge(arr[i].i, arr[i].j);
    }
    int flag = 1;
    for (int i = 0; i < n && flag; i++) {
        if (arr[i].e == 1) continue;
        flag = (u.get(arr[i].i) != u.get(arr[i].j));
    }
    cout << (flag ? "YES" : "NO") << endl;
    return ;
}

int main() {
    int tcase;
    cin >> tcase;
    while (tcase--) solve();
    return 0;
}
```

### 8.0.8. Supermarket

>  超市里有NN个商品. 第ii个商品必须在保质期(第didi天)之前卖掉, 若卖掉可让超市获得pipi的利润.每天只能卖一个商品.现在你要让超市获得最大的利润.

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 10000

struct Data {
    int p, d;
} arr[MAX_N + 5];
 
struct UnionSet {
    int fa[MAX_N + 5];
    void init(int n) {
        for (int i = 0; i <= n; ++i) fa[i] = i;
    }
    int get(int x) {
        return (fa[x] = (x - fa[x] ? get(fa[x]) : x));
    }
    //根节点代表当前节点前面第一个空位置
    //前面做儿子
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

bool cmp(const Data &a, const Data &b) {
    return a.p > b.p;
}

UnionSet u;

int solve(int n) {
    for (int i = 0; i < n; ++i) {
        cin >> arr[i].p >> arr[i].d;
    }
    sort(arr, arr + n, cmp);
    u.init(MAX_N);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        if (u.get(arr[i].d) == 0) continue;
        ans += arr[i].p;
        int day = u.get(arr[i].d);
        //让day作为day-1的子集，day被占用
        u.merge(day, day - 1);
    }
    cout << ans << endl;
    return 0;
}

int main() {
    int n;
    while (cin >> n) solve(n);
    return 0;
}

```







### 8.0.9. 银河英雄传说

>  有一个划分成NN列的星际战场，各列依次编号为1,2,…,N1,2,…,N。有NN艘战舰，也依次编号为1,2,…,N1,2,…,N, 其中第ii号战舰处于第ii列。
>
>  有M条指令，每条指令格式为以下两种之一：
>
>  M i j，表示第ii号战舰所在列的全部战舰保持原有顺序，接在第jj号战舰所在列的尾部。
>
>  C i j，表示询问第ii号战舰与第jj号战舰当前是否处于同一列中，如果在同列中，他们之间间隔了多少艘战舰。

```cpp
/*************************************************************************
	> File Name: oj-324.cpp
	> Author: wei 
	> Mail: 1931248856@qq.com
	> Created Time: 2020年10月21日 星期三 17时53分12秒
 ************************************************************************/

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 500000

struct Unionset {
    int fa[MAX_N + 5], size[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; ++i) {
            fa[i] = i;
            size[i] = 1;
            val[i] = 0;
        }
        return ;
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        return fa[x] = root;
    }
    void merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        val[aa] = size[bb];
        size[bb] += size[aa];
        return ;
    }
};

Unionset u;

int main() {
    int n;
    scanf("%d", &n);
    u.init(n);
    char str[10];
    for (int i = 0; i < n; ++i) {
        int a, b;
        scanf("%s%d%d", str, &a, &b);
        switch (str[0]) {
            case 'M' : u.merge(a, b); break;
            case 'C' : {
                if (u.get(a) != u.get(b)) {
                    printf("-1\n");
                } else {
                    printf("%d\n", abs(u.val[a] - u.val[b]) - 1);
                }
            } break;
        }
    }

    return 0;
}

```

### 8.0.10. HZOJ-325-代码演示



![image-20210131134715524](/Image/A1.Data_Structure-photo/image-20210131134715524.png)

a



```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
using namespace std;
#define MAX_N 5000

struct Data {
    int l, r;
    string s;
} arr[MAX_N + 5];

set<int> ind_s;
map<int ,int> ind;
int cnt = 0;

struct UnionSet {
    int father[MAX_N << 1 + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; ++i) {
            father[i] = i;
            val[i] = 0;
        }
        return ;
    }
    
    int get(int x) {
        if (father[x] == x) return x;
        int root = get(father[x]);
        val[x] += val[father[x]];
        val[x] %= 2;
        return father[x] = root;
    }
    
    int merge(int a, int b, int c) {
        int fa = get(a), fb = get(b);
        if (fa == fb) {
            return (val[a] - val[b] - c) % 2 == 0;
        }
        father[fa] = father[fb];
        val[fa] = (c + val[b] - val[a] + 2) % 2;
        return 1;
    }
};

UnionSet u;

int main() {
    int l, q;
    cin >> l >> q;
    for (int i = 0; i < q; ++i) {
        cin >> arr[i].l >> arr[i].r >> arr[i].s;
        arr[i].r += 1;
        ind_s.insert(arr[i].l);
        ind_s.insert(arr[i].r);
    }

    for (auto cur : ind_s) {
        ind[cur] = ++cnt;
    }

    u.init(cnt);
    for (int i = 0; i < q; ++i) {
        arr[i].l = ind[arr[i].l];
        arr[i].r = ind[arr[i].r];
        if (u.merge(arr[i].l, arr[i].r, arr[i].s == "odd")) continue;
        cout << i << endl;
        return 0;
    }
    cout << q << endl;
    return 0;
}

```

### 8.0.11. HZOJ-326-食物链

![image-20210131145149668](/Image/A1.Data_Structure-photo/image-20210131145149668.png)

a

```cpp
using namespace std;
#define MAX_N 50000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5], n;
    void init(int n) {
        this->n = n;
        for (int i = 1; i <= n; i++) {
            fa[i] = i;
            val[i] = 0;
        }
        return ;
    }
    int get(int x) {
        if (fa[x] == x) return x;
        int ret = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 3;
        return fa[x] = ret;
    }
    int merge(int a, int b, int c) {
        if (a > n || b > n) return 0;
        int aa = get(a), bb = get(b);
        if (aa == bb) {
            return (val[a] - val[b] - c) % 3 == 0;
        }
        fa[aa] = bb;
        val[aa] = ((c - val[a] + val[b]) % 3 + 3) % 3;
        return 1;
    }
} u;

int main() {
    int n, m, a, b, c, ans = 0;
    cin >> n >> m;
    u.init(n);
    while (m--) {
        cin >> c >> a >> b;
        c -= 1;
        if (!u.merge(a, b, c)) ans += 1;
    }
    cout << ans << endl;
    return 0;
}
```













### 8.0.12. HZOJ-327-关押罪犯.cpp



```cpp
 
/*************************************************************************
   > File Name: 327.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日 11/24 14:36:55 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 20000
#define MAX_M 100000

struct UnionSet {
    int fa[MAX_N + 5], val[MAX_N + 5];
    void init(int n) {
        for (int i = 1; i <= n; i++) fa[i] = i, val[i] = 0;
    }
    int get(int x) {
        if (x == fa[x]) return x;
        int root = get(fa[x]);
        val[x] += val[fa[x]];
        val[x] %= 2;
        return fa[x] = root;
    }
    bool merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) {
            return (val[a] + val[b]) % 2;
        }
        fa[aa] = bb;
        val[aa] = (3 + val[b] - val[a]) % 2;
        return true;
    }
};

struct Data {
    int i, j, c;
} arr[MAX_M + 5];

UnionSet u;

int main() {
    int n, m;
    cin >> n >> m;
    u.init(n);
    for (int i = 0; i < m; i++) {
        cin >> arr[i].i >> arr[i].j >> arr[i].c;
    }
    sort(arr, arr + m, [](const Data &a, const Data &b) {
        return a.c > b.c;
    });
    int ans = 0;
    for (int i = 0; i < m; i++) {
        if (!u.merge(arr[i].i, arr[i].j)) {
            ans = arr[i].c;
            break;
        }
    }
    cout << ans << endl;
    return 0;
}

```





### 8.0.13. [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度

```cpp
/*************************************************************************
   > File Name: 128.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日 11/24 18:46:05 2019
 ************************************************************************/

class UnionSet {
public :
    vector<int> fa, size;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) {
            fa.push_back(i);
            size.push_back(1);
        }
        return ;
    }
    int get(int x) {
        return (fa[x] = (fa[x] == x ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[aa] = bb;
        size[bb] += size[aa];
        return ;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        u.init(nums.size());
        unordered_map<int, int> ht;
        for (int i = 0; i < nums.size(); i++) {
            int k = nums[i];
            if (ht.find(k) != ht.end()) continue;
            if (ht.find(k - 1) != ht.end()) {
                u.merge(i, ht[k - 1]);
            }
            if (ht.find(k + 1) != ht.end()) {
                u.merge(i, ht[k + 1]);
            }
            ht[k] = i;
        }
        int ans = 0;
        for (int i = 0; i < nums.size(); i++) {
            ans = max(ans, u.size[i]);
        }
        return ans;
    }
    UnionSet u;
};
```

```cpp
class Solution
{
    public:
        //AC - 24ms - bottom-up method;
        int longestConsecutive(vector<int>& nums) 
        {
            int maxCount = 0, lCount = 0, rCount = 0;
            unordered_map<int, int> count_map;
            for(int i = 0; i < nums.size(); ++i)
            {
                if(!count_map[nums[i]])
                {
                    int lCount = count_map[nums[i]-1];
                    int rCount = count_map[nums[i]+1];
                    int sum = lCount+rCount+1;
                    count_map[nums[i]] = count_map[nums[i]-lCount] = count_map[nums[i]+rCount] = sum;
                    maxCount = max(maxCount, sum);
                }
            }
            return maxCount;
        }

        //AC - 20ms - blood spreading into two directions;
        int longestConsecutive(vector<int>& nums)
        {
            unordered_set<int> set(nums.begin(), nums.end());
            int ret = 1;
            for(auto &n: nums)
            {
                if(!set.count(n)) continue;
                set.erase(n);
                int pre=n-1, next=n+1;
                while(set.count(pre)) set.erase(pre--);
                while(set.count(next)) set.erase(next++);
                ret = max(ret, next-pre-1);
            }
            return ret;
        }
};

```



### 8.0.14. [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

```cpp

class Solution {
public:
    int dir[4][2] = {0,1 , 1, 0, 0, -1, -1, 0};
    struct node {
        int x, y;
    };
    void bfs(int sx, int sy, vector<vector<int>> &check, vector<vector<char>> &board) {
                int n = board.size(), m = board[0].size();
                queue<node> que;
                que.push((node){sx, sy});
                check[sx][sy] = 1;
                while (!que.empty()) {
                    node temp = que.front();
                    que.pop();
                    for (int i = 0; i < 4; ++i) {
                        int x = temp.x + dir[i][0];
                        int y = temp.y + dir[i][1];
                        if (x < 0 || y < 0 || x >= n || y >= m || check[x][y] || board[x][y] == 'X') continue;
                        check[x][y] = 1;
                        que.push((node){x, y});
                    }     
                }
    }
    void solve(vector<vector<char>>& board) {
        int n = board.size();
        if (n == 0) return ;
        int m = board[0].size();
        vector<vector<int>> check(n, vector<int>(m, 0));
        for (int i  = 0; i < m; ++i) {
            if (board[0][i] == 'X' || check[0][i]) continue;
            bfs(0, i, check, board);
        }
        for (int i  = 0; i < m; ++i) {
            if (board[n - 1][i] == 'X' || check[n - 1][i]) continue;
            bfs(n - 1, i, check, board);
        }
        for (int i  = 1; i < n - 1; ++i) {
            if (board[i][0] == 'X' || check[i][0]) continue;
            bfs(i,0, check, board);
        }
        for (int i  = 1; i < n - 1; ++i) {
            if (board[i][m - 1] == 'X' || check[i][m - 1]) continue;
            bfs(i,m - 1, check, board);
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (check[i][j]) board[i][j] = 'O';
                else board[i][j] = 'X';
            }
        }
        return ;

    }
```

# 9. #

```cpp
/*************************************************************************
   > File Name: 130.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日 11/24 19:46:48 2019
 ************************************************************************/

class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if (board.size() == 0) return ;
        if (board[0].size() == 0) return ;
        n = board.size();
        m = board[0].size();
        u.init(n * m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;
                if (i && board[i - 1][j] == 'O')
                    u.merge(ind(i, j), ind(i - 1, j));
                if (j && board[i][j - 1] == 'O')
                    u.merge(ind(i, j), ind(i, j - 1));
                if (i == 0 || i + 1 == n)
                    u.merge(ind(i, j), 0);
                if (j == 0 || j + 1 == m)
                    u.merge(ind(i, j), 0);
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'X') continue;
                if (u.get(ind(i, j)) == u.get(0)) continue;
                board[i][j] = 'X';
            }
        }
        return ;
    }
    int ind(int i, int j) {
        return i * m + j + 1;
    }
    int n, m;
    UnionSet u;
};
```

### 9.0.15. Leetcode-200[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```cpp
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

```cpp
/*************************************************************************
   > File Name: 200.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 四  5/23 19:08:07 2019
 ************************************************************************/

#define MC(T, n) (T *)malloc(sizeof(T) * (n))
#define CC(T, n) (T *)calloc(sizeof(T), (n))

typedef struct UnionSet {
    int *fa;
    int n;
} UnionSet;

UnionSet *init(int n) {
    UnionSet *u = MC(UnionSet, 1);
    u->fa = MC(int, n + 1);
    u->n = n;
    for (int i = 1; i <= n; i++) u->fa[i] = i;
    return u;
}

void clear(UnionSet *u) {
    if (u == NULL) return ;
    free(u->fa);
    free(u);
    return ;
}

int get(UnionSet *u, int x) {
    if (u->fa[x] == x) return x;
    return u->fa[x] = get(u, u->fa[x]);
}

void merge(UnionSet *u, int a, int b) {
    u->fa[get(u, a)] = get(u, b);
}

int numIslands(char** grid, int n, int *M) {
    if (n == 0) return 0;
    int m = M[0];
    #define ind(i, j) ((i) * (m) + (j) + 1)
    UnionSet *u = init(n * m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == '0') continue;
            if (i - 1 >= 0 && grid[i - 1][j] == '1')
                merge(u, ind(i, j), ind(i - 1, j));
            if (j - 1 >= 0 && grid[i][j - 1] == '1')
                merge(u, ind(i, j), ind(i, j - 1));
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == '0') continue;
            ans += (get(u, ind(i, j)) == ind(i, j));
        }
    }
    clear(u);
    return ans;
}
```



### 9.0.16. LC-547

```cpp
class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& M) {
        int n = M.size();
        u.init(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (M[i][j] == 0) continue;
                u.merge(i, j);
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) ans += (u.get(i) == i);
        return ans;
    }
    UnionSet u;
};
```

### 9.0.17. Leetcode-684

```cpp
class UnionSet {
public:
    vector<int> fa;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        fa[get(a)] = get(b);
    }
};

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        u.init(n);
        vector<int> ret;
        for (int i = 0; i < n; i++) {
            vector<int> &e = edges[i];
            if (u.get(e[0]) == u.get(e[1])) {
                ret = e;
                break;
            }
            u.merge(e[0], e[1]);
        }
        return ret;
    }
    UnionSet u;
};
```



### 9.0.18. [685. 冗余连接 II](https://leetcode-cn.com/problems/redundant-connection-ii/)

1. `有环` ：构成环形数字1连到2,2连到3,3连到1就是个环
2. `冲突 `：一个点有两个父节点

- 有环无冲突 [[1,2],[2,3],[3,1]]
- 有环有冲突 [[1,2],[2,3],[3,1],[4,2]]
- 无环有冲突 [[1,2],[1,3],[2,3]]

> 在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。
>
> 输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。
>
> 结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点

该图由一个有着 N 个节点 (节点值不重复 1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。

这说明题目中的图原本是是一棵树，只不过在不增加节点的情况下多加了一条边！

还有 若有多个答案，返回最后出现在给定二维数组的答案。这说明在两天边都可以删除的情况下，要删顺序靠后的！

那么有如下三种情况，前两种情况是出现入度为 2 的点，如图：

![685.冗余连接II1.png](/Image/A1.Data_Structure-photo/1600316277-YhGBBy-685.冗余连接II1.png)

且只有一个节点入度为 2，为什么不看出度呢，出度没有意义，一颗树中随便一个父节点就有多个出度。

第三种情况是没有入度为 2 的点，那么图中一定出现了有向环（注意这里强调是有向环！）

如图：

![685.冗余连接II2.png](/Image/A1.Data_Structure-photo/1600316290-fCDJSg-685.冗余连接II2.png)



```cpp
class Solution {
private:
    static const int N = 1010; // 如题：二维数组大小的在3到1000范围内
    int father[N];
    int n; // 边的数量
    // 并查集初始化
    void init() {
        for (int i = 1; i <= n; ++i) {
            father[i] = i;
        }
    }
    // 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
    // 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
    // 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
    // 在有向图里找到删除的那条边，使其变成树
    vector<int> getRemoveEdge(const vector<vector<int>>& edges) {
        init(); // 初始化并查集
        for (int i = 0; i < n; i++) { // 遍历所有的边
            if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边
                return edges[i];
            }
            join(edges[i][0], edges[i][1]);
        }
        return {};
    }

    // 删一条边之后判断是不是树
    bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
        init(); // 初始化并查集
        for (int i = 0; i < n; i++) {
            if (i == deleteEdge) continue;
            if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树
                return false;
            }
            join(edges[i][0], edges[i][1]);
        }
        return true;
    }
public:

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int inDegree[N] = {0}; // 记录节点入度
        n = edges.size(); // 边的数量
        for (int i = 0; i < n; i++) {
            inDegree[edges[i][1]]++; // 统计入度
        }
        vector<int> vec; // 记录入度为2的边（如果有的话就两条边）
        // 找入度为2的节点所对应的边，注意要倒叙，因为优先返回最后出现在二维数组中的答案
        for (int i = n - 1; i >= 0; i--) {
            if (inDegree[edges[i][1]] == 2) {
                vec.push_back(i);
            }
        }
        // 处理图中情况1 和 情况2
        // 如果有入度为2的节点，那么一定是两条边里删一个，看删哪个可以构成树
        if (vec.size() > 0) {
            if (isTreeAfterRemoveEdge(edges, vec[0])) {
                return edges[vec[0]];
            } else {
                return edges[vec[1]];
            }
        }
        // 处理图中情况3
        // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了
        return getRemoveEdge(edges);

    }
};
```





```cpp
/*************************************************************************
   > File Name: 685.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日 11/24 21:23:30 2019
 ************************************************************************/

class UnionSet {
public:
    vector<int> fa;
    int cnt;
    void init(int n) {
        fa.clear();
        for (int i = 0; i <= n; i++) fa.push_back(i);
        cnt = n;
    }
    int get(int x) {
        return (fa[x] = (x == fa[x] ? x : get(fa[x])));
    }
    void merge(int a, int b) {
        cnt -= (get(a) != get(b));
        fa[get(a)] = get(b);
    }
};

class Solution {
public:

    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> indeg(n + 1), outdeg(n + 1), father(n + 1);
        for (int i = 0; i < n; i++) {
            indeg[edges[i][1]] += 1;
            outdeg[edges[i][0]] += 1;
            father[edges[i][1]] = edges[i][0];
        }
        int flag = 0;
        for (int i = 1; i <= n; i++) {
            if (indeg[i] <= 1) continue;
            flag = i;
            break;
        }
        if (flag) {
            for (int i = n - 1; i >= 0; i--) {
                if (edges[i][1] - flag) continue;
                u.init(n);
                for (int j = 0; j < n; j++) {
                    if (i == j) continue;
                    u.merge(edges[j][0], edges[j][1]);
                }

                if (u.cnt != 1) {
                    continue;
                }
                return edges[i];
            }
        }
        queue<int> q;
        vector<int> ret;
        for (int i = 1; i <= n; i++) {
            if (outdeg[i]) continue;
            q.push(i);
        }
        while (!q.empty()) {
            int ind = q.front();
            q.pop();
            outdeg[father[ind]] -= 1;
            if (outdeg[father[ind]] == 0) q.push(father[ind]);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (outdeg[edges[i][0]] && outdeg[edges[i][1]]) {
                ret = edges[i];
                break;
            }
        }
        return ret;
    }
    UnionSet u;
};
```

### 9.0.19. [除法求值](https://leetcode-cn.com/problems/evaluate-division/description/)

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。



**示例 1：**

```cpp
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

# 10. ==树状数组==

## 10.1. 一、前缀和与差分

1. 原数组：${a_1, a_2,a_3,....,a_n}$
2. 前缀和：$S_i=\sum_{k=1}^{k=i}{a_i}$，$a_i=S_i-S_{i-1}$
3. 差分数组：$X_i=a_i-a_{i-1}$
4. X 数组是 a 数组的差分数组，a 数组是 S 数组的差分数组
5. S 数组是 a 数组的前缀和数组，a 数组是 X 数组的前缀和数组
6. 前缀和数组以及差分数组，并没有增加信息，只是信息的另外一种表示形式
7. 前缀和数组用来优化区间和操作
8. 差分数组用来优化区间修改操作



### 10.1.1. 问题1：原数组区间和操作

a 数组上的操作：$O(n)$

S 数组上的操作：$O(1)，S_i - S_{j-1}=a[j,i]区间和$



### 10.1.2. 问题2：原数组区间元素修改（加法）

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



a 数组时间复杂度：$O(n)$

X 数组时间复杂度：$O(1)$

![image-20210131164748767](/Image/A1.Data_Structure-photo/image-20210131164748767.png)

## 10.2. 二、树状数组

1. lowbit 函数求数字 i，二进制表示中的最低1所在的位权
2. lowbit(x) = x & -x
3. 树状数组本质上是对前缀和数组的一种优化，主要体现在单点修改操作上
4. 前缀和查询 $O(logn)$，单点修改$O(logn)$
5. 相比于最普通的前缀和数组，查询方面变差，单点修改操作变好，综合时间复杂度变好
6. 查询的时候，向前统计，$i$ 的前一位 $i-lowbit(i)$
7. 修改的时候，向后修改，$i$ 的后一位 $i + lowbit(i)$
8. lowbit(i):C[i]代表前lowbit[i]项的和



## 10.3. 三、海贼 OJ-329-弱化的整数问题

### 10.3.1. 引入差分数组

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



引入差分数组 X，将原数组 a 上的区间加操作，转换成 X 数组上的两次【单点操作】

对于查询原数组 a[i] 的值，等价于查询 X 数组前 i 位的【前缀和】



### 10.3.2. 结论

由于，既要维护【前缀和】，又要进行【单点修改】，所以可以使用树状数组



![image-20210131164801074](/Image/A1.Data_Structure-photo/image-20210131164801074.png)



## 10.4. 四、海贼 OJ-330-加强的整数问题

### 10.4.1. 引入差分数组

参考 HZOJ-329 的解法，主要为了维护原数组上的区间修改操作

 "C a b c"表示给[a, b]区间中的值全部增加c (-10000 ≤ c ≤ 10000)。

 "Q a b" 询问[a, b]区间中所有值的和。

### 10.4.2. 原数组上的区间和问题转化

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$

$Query(l, r) = S(r) - S(l - 1)$，重点分析 S 怎么求，会求 S，万事大吉

$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k*X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k*X_k}$

设$Y_i = i \times X_i$

$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$



### 10.4.3. 结论

$S_i$ 可以通过维护 X 与 Y 两个序列的前缀和得到

所以可以通过维护两个与差分数组 X 相关的前缀和数组，从而得到原数组 a 的前缀和值

需要维护两个：树状数组

![image-20210131164827184](/Image/A1.Data_Structure-photo/image-20210131164827184.png)



```cpp
long long c[2][MAX_N + 5];

void add(long long k, long long i, long long x, long long n) {
    while (i <= n) {
        c[k][i] += x;
        i += lowbit(i);
    }    
    return ;
}

long long query(long long k, long long i) {
    long long sum = 0;
    while (i) {
        sum += c[k][i];
        i -= lowbit(i);
    }
    return sum;
}

long long S(long long i) {
    return (i + 1) * query(0, i) - query(1, i);
}

void modify(long long i, long long x, long long n) {
    add(0, i, x, n);
    add(1, i, i * x, n);
    return ;
}
```





```cpp
#define MAX_N 100000
int c[MAX_N + 5];
inline int lowbit(int x) { return x & (-x); }
void add(int x, int val, int n) {
    while (x <= n) c[x] += val, x += lowbit(x);
}
int query(int x) {
    int sum = 0;
    while (x) sum += c[x], x -= lowbit(x);
    return sum;
}

int main() {
    int n, m, pre = 0, now;
    char str[10];
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> now;
        add(i, now - pre, n);
        pre = now;
    }
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str;
        switch (str[0]) {
            case 'C': {
                int a, b, c;
                cin >> a >> b >> c;
                add(a, c, n);
                add(b + 1, -c, n);
            } break;
            case 'Q': {
                int x;
                cin >> x;
                cout << query(x) << endl;
            }
        }
    }
    return 0;
}
```

## 10.5. 一、海贼 OJ-331-丢失的奶牛

> 有*𝑛*n只小动物，每只都有一个独特的编号，分别从11到*𝑛*n。现在他们从左到右依次排在一条直线上，顺序是乱的。 现在，我们只知道每个位置前面有几个比他小的数。请你根据给出的信息计算出每个位置上的数是多少

1. 理解标记数组，标记数组记录的是每一个下标知否可用，可用为1，不可用为0
2. 根据题意，我们从后向前，依次确定每一头奶牛的编号
3. 例如，当前奶牛比他前面的2个奶牛编号大的话，当前奶牛的编号就是当前剩余可用编号中的第三大的编号
4. 如何找到可用的第 x 大的编号，可以在标记数组的前缀和数组上做二分查找
5. 设计到标记数组的前缀和维护和单点更新，所以可以使用树状数组
6. 时间复杂度：$O(nlogn)$

```cpp
int n;
int ind[MAX_N + 5];
int cnt[MAX_N + 5];

void read() {
    cin >> n;
    ind[1] = 0;
    for (int i = 2; i <= n; ++i) cin >> cnt[i];
    for (int i = 1; i <= n; ++i) {
        add(i, 1, n);
    }
    return ;
}

int binary_search(int n, int x) {
    int head = 1, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (query(mid, n) < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

void solve() {
    for (int i = n; i >= 1; --i) {
        ind[i] = binary_search(n, cnt[i] + 1);
        add(ind[i], -1, n);
    }
    return ;
}

void output() {
    for (int i = 1; i <= n; ++i) {
        cout << ind[i] << endl;
    }
    return ;
}
```





相似问题：海贼 OJ-332-买票



## 10.6. 二、海贼 OJ-328-楼兰图腾

1. 求在当前位置之前，小于当前位置值的元素数量，当前元素值记为 X，元素数量记为 a，元素位置记为 i
2. 前面小于 $X$ 的元素数量是 $a$
3. 后面小于 $X$ 的元素数量是$X - a - 1$
4. 前面大于 $X$ 的元素数量 $i - a - 1$
5. 后面大于X 的元素数量$n-X-i+a+1$
6. 解题关键：前面小于 $X$ 的元素数量是 $a$
7. 标记数组，记录当前位置之前有哪些元素出现过，出现过标记为 1，否则标记为 0
8. $a$ 等于标记数组在 $X$ 位置之前的前缀和
9. 对于标记数组的单点修改及前缀和查询，所以可以使用树状数组



```cpp
void solve(long long &x, long long &y) {
    x = y = 0;
    for (long long i = 1; i <= n; ++i) {
        long long a1 = query(val[i], n);
        long long a2 = val[i] - a1 - 1;
        long long b1 = i - a1 - 1;
        long long b2 = n - val[i] - b1;
        x += b1 * b2;
        y += a1 * a2;
        add(val[i], 1, n);
    }  
}
```





## 10.7. 三、海贼 OJ-333-区间最大子段和

1. 线段树有点点儿难度的题目
2. 每个节点：区间和值，最大子段和值，左侧最大子段和，右侧最大子段和
3. 特殊性质：递归遍历时，是按照下标顺序得到的每一个查询区间内的线段树的节点
4. $|①②③④⑤|$，就是按照①②③④⑤的顺序遍历得到的每一个节点
5. 代码有点儿复杂，学会了，代码思维会更上一层楼

## 10.8.  

```cpp
#define MAX_N 500000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define SUM(ind) tree[ind].sum
#define MAX(ind) tree[ind].m
#define LMAX(ind) tree[ind].lm
#define RMAX(ind) tree[ind].rm

struct node {
    int sum, m, lm, rm;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 3, cnt = 4, ans = 0, temp = 1;
int arr[MAX_N + 5];
inline int getNode() { return cnt++; }

void UP(int a, int b, int c) {
    SUM(a) = SUM(b) + SUM(c);
    LMAX(a) = max(LMAX(b), SUM(b) + LMAX(c));
    RMAX(a) = max(RMAX(c), SUM(c) + RMAX(b));
    MAX(a) = max(MAX(b), MAX(c));
    MAX(a) = max(MAX(a), RMAX(b) + LMAX(c));
    return ;
}

void UP(int ind) {
    UP(ind, lc(ind), rc(ind));
}

void build(int ind, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    lc(ind) = getNode();
    rc(ind) = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = y;
        
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, l, mid);
    else modify(rc(ind), x, y, mid + 1, r);
    UP(ind);
    return ;
}

void query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        if (x == l) tree[ans] = tree[ind];
        else {
            UP(temp, ans, ind);
            swap(temp, ans);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) query(lc(ind), x, y, l, mid);
    if (y > mid) query(rc(ind), x, y, mid + 1, r);
    return ;
}

ostream &operator<<(ostream &out, node &a) {
    out << (&a - tree) << " : " << a.sum << " " << a.m << " " << a.lm << " " << a.rm;
    out << "(" << a.lind << "," << a.rind << ")";
    return out;
}

void output(int n) {
    for (int i = root; i < root + 2 * n - 1; i++) {
        cout << tree[i] << endl;
    }
    cout << "---------" << endl;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            if (b > c) swap(b, c);
            query(root, b, c, 1, n);
            cout << MAX(ans) << endl;
        } else {
            modify(root, b, c, 1, n);
        }
        //output(n);
    }
    return 0;
}
```

# 11. ==线段树==

线段树—关键词
完全二叉树:线段树程序实现时候的实际存储结构
区间:线段树中每个节点所维护的范围
向 上 更 新:用两个子节点的信息更新本节点的信息
下 沉 标 记:将本节点的懒惰标记更新给两个子节点
口诀:下沉发生在递归之前,向上发生在递归之后

## 11.1. 一、问题背景

1. 单点修改，区间查询（基础版）
2. 区间修改，区间查询（进阶版）
3. 单点修改，单点查询（用不着线段树）
4. 区间修改，单点查询（是第二种情况的特例）



## 11.2. 二、基础版线段树

1. 线段树是对于一维序列的一种维护结构

2. 采用的分治的思想，将总区间分成左右两部分，一直进行下去，直到区间中只剩下一个节点为止

3. 线段树的叶子结点，代表了原序列中的单个位置的值

4. 如果采用完全二叉树的存储结构的话，最起码需要 $4n$ 的存储空间

5. 当面对区间修改的时候，基础版的线段树效率上还不如直接在一维序列上修改

6. 只适用于单点修改，区间查询

   ```cpp
   #define MAX_N 10000
   #define lc(ind) (ind << 1)
   #define rc(ind) (ind << 1 | 1)
   
   struct node {
       int sum;
   } tree[(MAX_N << 2) + 5];
   int root = 1;
   int arr[MAX_N + 5];
   
   void UP(int ind) {
       tree[ind].sum = max(tree[lc(ind)].sum, tree[rc(ind)].sum);
       return ;
   }
   
   void build(int ind, int l, int r) {
       if (l == r) {
           tree[ind].sum = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build(lc(ind), l, mid);
       build(rc(ind), mid + 1, r);
       UP(ind);
       return ;
   }
   
   void modify(int ind, int x, int y, int l, int r) {
       if (l == r) {
           tree[ind].sum = y;
           return ;
       }
       int mid = (l + r) >> 1;
       if (x <= mid) modify(lc(ind), x, y, l, mid);
       else modify(rc(ind), x, y, mid + 1, r);
       UP(ind);
       return ;
   }
   
   int query(int ind, int x, int y, int l, int r) {
       if (x <= l && r <= y) {
           return tree[ind].sum;
       }
       int ans = 0x80000000, mid = (l + r) >> 1;
       if (x <= mid) ans = max(ans, query(lc(ind), x, y, l, mid));
       if (y > mid) ans = max(ans, query(rc(ind), x, y, mid + 1, r));
       return ans;
   }
   
   int main() {
       int n, m;
       cin >> n >> m;
       for (int i = 1; i <= n; i++) cin >> arr[i];
       build(root, 1, n);
       for (int i = 0; i < m; i++) {
           int a, b, c;
           cin >> a >> b >> c;
           if (a == 1) modify(root, b, c, 1, n);
           else {
               cout << query(root, b, c, 1, n) << endl;
           }
       }
       return 0;
   }
   ```

   ```cpp
   #define MAX_N 10000
   struct {
       int max_num;
       int l, r;
   } tree[MAX_N << 2];
   int arr[MAX_N + 5];
   
   void update(int ind) {
       tree[ind].max_num = max(tree[ind << 1].max_num, tree[ind << 1 | 1].max_num);
       return ;
   }
   
   void build_tree(int ind, int l, int r) {
       tree[ind].l = l, tree[ind].r = r;
       if (l == r) {
           tree[ind].max_num = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build_tree(ind * 2, l, mid);
       build_tree(ind * 2 + 1, mid + 1, r);
       update(ind);
       return ;
   }
   
   void modify(int ind, int k, int val) {
       if (tree[ind].l == tree[ind].r) {
           tree[ind].max_num = val;
           return ;
       }
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (k <= mid) {
           modify(ind << 1, k, val);
       } else {
           modify(ind << 1 | 1, k, val);
       }
       update(ind);
       return ;
   }
   
   int query(int ind, int x, int y) {
       if (tree[ind].l >= x && tree[ind].r <= y) {
           return tree[ind].max_num;
       }
       int ans = INT_MIN;
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (mid >= x) {
           ans = max(ans, query(ind << 1, x, y));
       }
       if (mid < y) {
           ans = max(ans, query(ind << 1 | 1, x, y));
       }
       return ans;
   }
   ```

   

   



## 11.3. 三、进阶版线段树

1. 优化掉了代码实现中的：l，r。区间变量
2. 可以用于区间更新，区间查询
3. 增加了懒标记，达到能够区间更新的目的
4. 懒标记是需要向下下沉的
5. 标记下沉发生在递归之前，向上更新发生在具有修改操作的递归之后

```cpp
#define MAX_N 10000
#define define_mid long long mid = (l + r) >> 1

long long flag = 0;
struct {
    long long sum, tag;
} tree[MAX_N << 2];
long long arr[MAX_N + 5];

void update(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    return ;
}

void down(long long ind, long long l, long long r) {
    if (tree[ind].tag) {
        long long val = tree[ind].tag;
        define_mid;
        tree[ind << 1].sum += val * (mid - l + 1);
        tree[ind << 1].tag += val;
        tree[ind << 1 | 1].sum += val * (r - mid);
        tree[ind << 1 | 1].tag += val;
        tree[ind].tag = 0;
    }
    return ;
}

void build_tree(long long ind, long long l, long long r) {
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    define_mid;
    build_tree(ind << 1, l, mid);
    build_tree(ind << 1 | 1, mid + 1, r);
    update(ind);
    return ;
}

void modify(long long ind, long long l, long long r, long long x, long long y, long long val) {
    flag && printf("modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, val, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        tree[ind].sum += val * (r - l + 1);
        tree[ind].tag += val;
        return ;
    }
    down(ind, l, r);
    define_mid;
    if (mid >= x) {
        modify(ind << 1, l, mid, x, y, val);
    }
    if (mid < y) {
        modify(ind << 1 | 1, mid + 1, r, x, y, val);
    }
    update(ind);
    return ;
}

long long query(long long ind, long long l, long long r, long long x, long long y) {
    flag && printf("query(%lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    down(ind, l, r);
    define_mid;
    long long ans = 0;
    if (mid >= x) {
        ans += query(ind << 1, l, mid, x, y);
    }
    if (mid < y) {
        ans += query(ind << 1 | 1, mid + 1, r, x, y);
    }
    return ans;
}

int main() {
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (long long i = 1; i <= n; i++) {
        scanf("%lld", arr + i);
    }
    build_tree(1, 1, n);
    long long a, b, c, d;
    for (long long i = 0; i < m; i++) {
        scanf("%lld%lld%lld", &a, &b, &c);
        switch (a) {
            case 1: {
                scanf("%lld", &d);
                modify(1, 1, n, b, c, d);
            } break;
            case 2: {
                if (b > c) {
                    printf("0\n");
                    break;
                }
                printf("%lld\n", query(1, 1, n, b, c));
            } break;
        }
    }
    return 0;
}
```





```cpp
#define MAX_N 10000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define tag(ind) tree[ind].tag
#define sum(ind) tree[ind].sum
#define cnt(ind) tree[ind].cnt

struct node {
    long long sum, tag, cnt;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 0, cnt = 1;
long long arr[MAX_N + 5];
int getNode() { return cnt++; }

void DOWN(int ind) {
    if (tag(ind)) {
        tag(lc(ind)) += tag(ind);
        tag(rc(ind)) += tag(ind);
        sum(lc(ind)) += tag(ind) * cnt(lc(ind));
        sum(rc(ind)) += tag(ind) * cnt(rc(ind));
        tag(ind) = 0;
    }
    return ;
}

void UP(int ind) {
    tree[ind].sum = tree[lc(ind)].sum + tree[rc(ind)].sum;
}

void build(int ind, int l, int r) {
    tree[ind].cnt = (r - l + 1);
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    tree[ind].lind = getNode();
    tree[ind].rind = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, long long d, int l, int r) {
    if (x <= l && r <= y) {
        tree[ind].tag += d;
        tree[ind].sum += d * tree[ind].cnt;
        return ;
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, d, l, mid);
    if (y > mid) modify(rc(ind), x, y, d, mid + 1, r);
    UP(ind);
    return ;
}

long long query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        return sum(ind);
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    long long ans = 0;
    if (x <= mid) ans += query(lc(ind), x, y, l, mid);
    if (y > mid) ans += query(rc(ind), x, y, mid + 1, r);
    return ans;
}
```





### 11.3.1. HZOJ224 复合线段树

```cpp
#define MAX_N 100000
struct Node {
    long long sum, t1, t2;
} tree[(MAX_N << 2) + 5];
long long a[MAX_N + 5];
long long n, m, p;

void mul_tag(long long ind, long long x) {
    tree[ind].sum *= x;
    tree[ind].sum %= p;
    tree[ind].t1 *= x;
    tree[ind].t1 %= p;
    tree[ind].t2 *= x;
    tree[ind].t2 %= p;
    return ;
}

void add_tag(long long ind, long long x, long long n) {
    tree[ind].sum += x * n;
    tree[ind].sum %= p;
    tree[ind].t2 += x;
    tree[ind].t2 %= p;
    return ;
}

void UP(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    tree[ind].sum %= p; 
    return ;
}

void DOWN(long long ind, long long l, long long r) {
    if (tree[ind].t1 - 1 || tree[ind].t2) {
        long long a = tree[ind].t1, b = tree[ind].t2;
        long long mid = (l + r) >> 1;
        mul_tag(ind << 1, a);
        mul_tag(ind << 1 | 1, a);
        add_tag(ind << 1, b, mid - l + 1);
        add_tag(ind << 1 | 1, b, r - mid);
        tree[ind].t1 = 1;
        tree[ind].t2 = 0;
    }
    return ;
}

void build(long long ind, long long l, long long r) {
    tree[ind].t1 = 1; tree[ind].t2 = 0;
    if (l == r) {
        tree[ind].sum = a[l];
        return ;
    }
    long long mid = (l + r) >> 1;
    build(ind << 1, l, mid);
    build(ind << 1 | 1, mid + 1, r);
    UP(ind);
    return ;
}

void modify(long long ind, long long flag, long long x, long long y, long long val, long long l, long long r) {
    if (x <= l && r <= y) {
        if (flag == 0) {
            mul_tag(ind, val);
        } else {
            add_tag(ind, val, r - l + 1);
        }
        return ;
    }
    long long mid = (l + r) >> 1;
    DOWN(ind, l, r);
    if (x <= mid) modify(ind << 1, flag, x, y, val, l, mid);
    if (y > mid) modify(ind << 1 | 1, flag, x, y, val, mid + 1, r);
    UP(ind);
    return ;
}

long long query(long long ind, long long x, long long y, long long l, long long r) {
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    long long mid = (l + r) >> 1;
    long long ans = 0;
    DOWN(ind, l, r);
    if (x <= mid) ans += query(ind << 1, x, y, l, mid);
    ans %= p;
    if (y > mid) ans += query(ind << 1 | 1, x, y, mid + 1, r);
    ans %= p;
    UP(ind);
    return ans;
}

int main() {
    cin >> n >> m >> p;
    for (long long i = 1; i <= n; i++) cin >> a[i];
    build(1, 1, n);
    long long op, x, y, k;
    for (long long i = 0; i < m; i++) {
        cin >> op >> x >> y;
        switch (op) {
            case 1: 
            case 2: {
                cin >> k;
                modify(1, op - 1, x, y, k, 1, n);
            } break;
            case 3: {
                cout << query(1, x, y, 1, n) << endl;
            } break;
        }
    }
    return 0;
}
```





习 题 作 业
Luogu P3372 Luogu P3373
Luogu P3924 Luogu P1047
Luogu P1168 Luogu P1204
Luogu P1276 Luogu P1438
Luogu P1442 Luogu P1471
Luogu P1531 Luogu P1533
Luogu P1558 Luogu P1637
Luogu P1816 Luogu P25

# 12. ==二叉排序树==



## 12.1. 一、性质

1. 左子树 < 根节点
2. 右子树 > 根节点
3. 中序遍历的结果，是一个有序序列

数据结构，就是定义一种性质，并且维护这种性质。

1. 二叉树中，第 i 层最多有$ 2^{i-1}$ 个结点。
2. 如果二叉树的深度为 K，那么此二叉树最多有 $2^K-1$ 个结点。
3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1

## 12.2. 二、插入操作

1. 插入的新节点，一定会做为叶子结点



## 12.3. 三、删除操作

1. 删除度为0的节点，直接删除
2. 删除度为1的节点，把『孤儿子树』挂到其父节点上面去
3. 删除度为2的节点，可以转化成删除度为1的节点



对于度为2的节点：

1. 前驱：左子树最大值
2. 后继：右子树最小值



## 12.4. 四、随堂练习

1. 插入顺序会影响最终的树形结构
2. 不同的树形结构，查找效率不同



平均查找效率：节点查找次数的期望值，$\frac{总次数}{节点数量}$，假设每个节点等概率的被查找



## 12.5. 五、扩展内容

1. 二叉排序树的删除代码优化
   1. 删除掉处理度为0的代码逻辑，不影响代码整体功能
2. 如何解决==排名==相关的检索需求
   1. 修改二叉排序树的结构定义，增加 size 字段，记录每棵树的节点数量
   2. $k = LS - 1$，根节点就是排名第 k 位的元素
   3. $k \le LS$，排名第 k 位的元素在左子树中
   4. $k \gt LS，search_k(root->rchild, k - LS - 1)$
3. 解决 Top-K 问题（找到小于第 k 位的所有元素）
   1. 根节点就是第 k 位元素的话，就把左子树中的值全部输出出来
   2. 第 k 位在左子树中，前 k 位元素全都在左子树中
   3. 第 k 位在右子树中，说明根节点和左子树中的元素，都是前 k 位元素里面的值
4. 二叉排序树和快速排序的关系
   1. 二叉排序树是快速排序在思维逻辑结构层面用的数据结构
   2. 思考1：快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系
   3. 思考2：快速选择算法和二叉排序树之间的关系
   4. 程序=算法+数据结构



所谓算法设计及分析能力：分类讨论及归纳总结的能力



```cpp
#include <stdio.h>
#include <stdlib.h>
#define KEY(n) (n ? n->key : 0)
#define SIZE(n) (n ? n->size : 0)
#define L(n) (n ? n->lchild : NULL)

typedef struct Node {
    int key, size;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->size = 1;
    p->lchild = p->rchild = NULL;
    return p;
}

void update_size(Node *root) {
    root->size = SIZE(root->lchild) + SIZE(root->rchild) + 1;
    return ;
}

int search(Node *root, int val) {
    if (root == NULL) return 0;
    if (root->key == val) return 1;
    if (val < root->key) return search(root->lchild, val);
    return search(root->rchild, val);
}

int search_k(Node *root, int k) {
    if (root == NULL) return -1;
    if (SIZE(L(root)) == k - 1) return root->key;
    if (k <= SIZE(L(root))) {
        return search_k(root->lchild, k);
    }
    return search_k(root->rchild, k - SIZE(L(root)) - 1);
}

Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    update_size(root);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NULL) return NULL;
    if (key < root->key) {
        root->lchild = erase(root->lchild, key);
    } else if (key > root->key) {
        root->rchild = erase(root->rchild, key);
    } else {
        if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    update_size(root);
    return root;
}

void clear(Node *root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void print(Node *root) {
    printf("(%d[%d], %d, %d)\n", 
           KEY(root), SIZE(root), 
           KEY(root->lchild), KEY(root->rchild)
    );
    return ;
}

void output(Node *root) {
    if (root == NULL) return ;
    output(root->lchild);
    print(root);
    output(root->rchild);
    return ;
}

void output_k(Node *root, int k) {
    if (k == 0 || root == NULL) return ;
    if (k <= SIZE(L(root))) {
        output_k(root->lchild, k);
    } else {
        output(root->lchild);
        print(root);
        output_k(root->rchild, k - SIZE(L(root)) - 1);
    }
    return ;
}

int main() {
    int op, val;
    Node *root =  NULL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 0: printf("search %d, result : %d\n", val, search(root, val)); break;
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
            case 3: {
                printf("search k = %d, result : %d\n", 
                    val, search_k(root, val)); 
            } break;
            case 4: { 
                printf("output top-%d elements\n", val);
                output_k(root, val); 
                printf("------------\n");
            } break;
        }
        if (op == 1 || op == 2) {
            output(root);
            printf("------------\n");
        }
    }
    return 0;
}
```





Leetcode 110
Leetcode 669



# 13. ==AVL 树==

- 学习重点

1. 平衡二叉树排序树，本质上也是二叉排序树，所以拥有二叉排序树的所有性质
2. 平衡二叉树排序树的学习重点，在于平衡条件以及平衡调整的相关学习



## 13.1. 二、性质

1. 平衡条件：左右子树高度差不超过 1

2. AVL 树改进的是节点数量的下限

   $ H \le SIZE(H) \le 2^H - 1 $

   $low(H - 2) + low(H - 1) + 1 \le SIZE(H) \le 2^H - 1$

   $low(1) =  1, low(2) = 2, low(3) = 4, low(4)  = 7, 斐波那契数列:1.618^n$



## 13.2. 四、平衡调整策略

1. 发生在回溯阶段的，第一个失衡节点处
2. 理解平衡调整策略的关键在于：分析清楚四种情况下，ABCD 四棵子树树高的关系
3. LL，大右旋
4. LR，先小左旋，再大右旋
5. RL，先小右旋，再大左旋
6. RR，大左旋

![image-20210205152153712](/Image/A1.Data_Structure-photo/image-20210205152153712.png)

![image-20210205152314037](/Image/A1.Data_Structure-photo/image-20210205152314037.png)



## 13.3. 五、代码演示

1. 插入和删除以后，注意重新计算树高字段
2. 引入了 NIL 阶段，代替 NULL，NULL 不可访问，NIL 是一个是实际节点，可访问



```cpp
#define H(root) (root)->h
#define K(root) (root)->key
#define L(root) (root)->lchild
#define R(root) (root)->rchild

typedef struct Node {
    int key, h;
    struct Node *lchild, *rchild;
} Node;

Node __NIL;
#define NIL (&__NIL)
__attribute__((constructor))
void init_NIL() {
    NIL->key = NIL->h = 0;
    NIL->lchild = NIL->rchild = NIL;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->h = 1;
    p->lchild = p->rchild = NIL;
    return p;
}

void update_height(Node *root) {
    root->h = (H(L(root)) > H(R(root)) ? H(L(root)) : H(R(root))) + 1;
    return ;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    update_height(root);
    update_height(temp);
    return temp;
}

Node *maintain(Node *root) {
    if (abs(H(L(root)) - H(R(root))) <= 1) return root;
    if (H(L(root)) > H(R(root))) {
        if (H(R(L(root))) > H(L(L(root)))) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (H(L(R(root))) > H(R(R(root)))) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
    return root;
}

Node *insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    update_height(root);
    return maintain(root);
}

Node *predeccessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) {
        root->lchild = erase(root->lchild, key);
    } else if (root->key < key) {
        root->rchild = erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return maintain(root);
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("(%d, %d, %d)\n", K(root), K(L(root)), K(R(root)));
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    #define MAX_OP 20
    Node *root = NIL;
    for (int i = 0; i < MAX_OP; i++) {
        int val = rand() % 100;
        root = insert(root, val);
    }
    output(root);
    int val;
    while (~scanf("%d", &val)) {
        root = erase(root, val);
        printf("erase %d from AVL tree\n", val);
        output(root);
    }
    return 0;
}
```





# 14. SB树

SB 树 :名称:Size Balanced 树

每棵子树的大小不小于其兄弟的子树大小

性质:
	Size(left) >= Size(right->left)
	Size(left) >= Size(right->right)
	Size(right) >= Size(left->left)
	Size(right) >= Size(left->right)
优点:
由于对每个节点的左右子树的节点数量做了限制,所以整棵树不会退化成一个链表

![image-20210205152513580](/Image/A1.Data_Structure-photo/image-20210205152513580.png)

思考:
1、高度为 H 的 BS 树,所包含的节点数量在什么范围之内?
2、高度为 H 的 SB 树,所包含的节点数量在什么范围之内?


Ｍaintain (T) 用于修复以 T 为根的 SBT 。由于性质(a)和(b)是对称的，下面仅讨论对性质(a)的修复。

### 14.0.1. Case 1: s[ Left[ Left[ T ] ]>s[ Right[ T ] ] 

在下图中，就是说 s[A]>s[R]

![img](/Image/A1.Data_Structure-photo/20131129202211734)

首先执行右旋（Right-Rotate (T)）可得

![img](/Image/A1.Data_Structure-photo/20131129203355843)

有可能旋转后的树仍然不是SBT,需要再次执行Maintain(T)

由于L的右儿子发生了变化，因此需要执行Maintain(L)

也就是说，这种情况先执行一次Right-Rotate (T)，接着执行Maintain (T) 保证T为SBT，然后执行Maintain(L)，保证L为SBT

### 14.0.2. Case 2: s[ right[ left[ t ] ]>s[ right[ t ] ]  

在下图中，也就是说 s[B]>s[R]

![img](/Image/A1.Data_Structure-photo/20131129203745125)

先执行左旋Left-Rotate(L)。如下图

![img](/Image/A1.Data_Structure-photo/20131129203857906)

执行右旋Right-Rotate(T)，如下图：

![img](/Image/A1.Data_Structure-photo/20131129203924718)

接着执行Maintain (L) 和Maintain (T)，来保证L和T是SBT

同理执行Maintain (B)



# 15. ==红黑树（上）==

## 15.1. 一、平衡条件

1. 节点非黑既红
2. 根节点是黑色
3. 叶子（NIL）结点是黑色
4. 红色节点下面接两个黑色节点
5. 从根节点到叶子结点路径上，黑色节点数量相同



### 15.1.1. 平衡条件的认识

第4条和第5条条件，注定了，红黑树中最长路径是最短路径的长度的 2 倍。

本质上，红黑树也是通过树高来控制平衡的。

红黑树比 AVL 树树高控制条件要更松散，红黑树在发生节点插入和删除以后，发生调整的概率，比 AVL 树要更小。



## 15.2. 二、学习诀窍

1. 理解红黑树的插入调整，要站在==祖父节点==向下进行调整
2. 理解红黑树的删除调整，要站在==父节点==向下进行调整
3. 插入调整，主要就是为了解决双红情况
4. 新插入的节点一定是红色，插入黑色节点一定会产生冲突，违反条件5，插入红色节点，不一定产生冲突
5. 把每一种情况，想象成一棵大的红黑树中的局部子树
6. 局部调整的时候，为了不影响全局，调整前后的路径上黑色节点数量相同



## 15.3. 三、插入策略

1. 叔叔节点为红色的时候，修改三元组小帽子，改成红黑黑
2. 叔叔节点为黑色的时候，参考 AVL 树的失衡情况，分成 $LL,LR,RL,RR$, 先参考 AVL 树的旋转调整策略，然后再修改三元组的颜色，有两种调整策略：红色上浮，红色下沉。
3. 两大类情况，包含 8 种小情况

![image-20210204204513136](/Image/A1.Data_Structure-photo/image-20210204204513136.png)

处理办法:1和20修改成黑色,15修改成红色(所谓的红色上顶)

![image-20210204204553104](/Image/A1.Data_Structure-photo/image-20210204204553104.png)

处理理办法:大右(左)旋,20调整成红色,15调整成黑色,即可搞定问题

只有17不确定

其余情况均可以调整成为情况二可处理理的情况,所以就不单独讨论了。



## 15.4. 四、代码演示

1. 插入调整，发正在递归的回溯阶段
2. 插入调整代码中，使用 goto 语句，8行代码，变成了4行
3. 处理根节点一定是黑色，通过代码封装，$insert->\_\_insert$



# 16. ==红黑树（下）==

## 16.1. 一、删除调整发生的前提

1. 删除红色节点，不会对红黑树的平衡产生影响
2. 度为1的黑色节点，唯一子孩子，一定是红色
3. 删除度为1的黑色节点，不会产生删除调整
4. 删除度为0的黑色节点，会产生一个双重黑的 NIL 节点
5. 删除调整，就是为了干掉双重黑（黑色上浮）



## 16.2. 二、删除调整

1. 双重黑节点的兄弟节点是黑色，兄弟节点下面的两个子节点也是黑色，父节点增加一重黑色，双重黑与兄弟节点，分别减少一重黑色。

2. 兄弟节点是黑色，并且，兄弟节点中有红色子节点
   1. R（兄弟）R（右子节点），左旋，新根改成原根的颜色，将新根的两个子节点，改成黑色
   2. R（兄弟）L（左子节点），先小右旋，对调新根与原根的颜色，转成上一种情况
   3. LL 同理 RR
   4. LR 同理 RL

3. 兄弟节点是红色，通过旋转，转变成兄弟节点是黑色的情况

![image-20210204204629813](/Image/A1.Data_Structure-photo/image-20210204204629813.png)

处理办法:brother 调整为红色,x 减少一重黑色,father 增加一重黑色

黑色上浮：根节点直接干掉

![image-20210204204703406](/Image/A1.Data_Structure-photo/image-20210204204703406.png)

![image-20210204230645450](/Image/A1.Data_Structure-photo/image-20210204230645450.png)

处理办法:brother 右(左)旋,51变黑,72变红,转成处理情况三

![image-20210204204736229](/Image/A1.Data_Structure-photo/image-20210204204736229.png)

![image-20210204230035628](/Image/A1.Data_Structure-photo/image-20210204230035628.png)

处理办法:father 左(右)旋,由于无法确定48的颜色,所以38改成黑色,51改成38的颜色,x 减少
一重黑色,72改成黑色

28，72，64，85确定

![image-20210204231107195](/Image/A1.Data_Structure-photo/image-20210204231107195.png)

兄弟节点是红色情况：左(右)旋，新根变黑，旧根变红

## 16.3. 三、代码演示

1. 进行 LR/RL 类型判断的时候，不能判断 LL 子树是否为黑色，LL 子树有可能是 NIL 节点，在某些特殊情况下，读到的颜色可能是双重黑，取而代之的判断方法就是【LL 子树不是红色】。

![image-20210205001401045](/Image/A1.Data_Structure-photo/image-20210205001401045.png)

空心代表红色：==RED:LR 		!=RED:LL

![image-20210204235441764](/Image/A1.Data_Structure-photo/image-20210204235441764.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#define RED 0
#define BLACK 1
#define DOUBLE_BLACK 2

typedef struct Node {
    int key, color; // 0 red, 1 black, 2 double black
    struct Node *lchild, *rchild;
} Node;

Node _NIL, * const NIL = &_NIL;

__attribute__((constructor))
void init_NIL() {
    NIL->key = 0;
    NIL->lchild = NIL->rchild = NIL;
    NIL->color = BLACK;
    return ;
}

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NIL;
    p->color = RED;
    return p;
}

int hasRedChild(Node *root) {
    return root->lchild->color == RED || root->rchild->color == RED;
}

Node *left_rotate(Node *root) {
    Node *temp = root->rchild;
    root->rchild = temp->lchild;
    temp->lchild = root;
    return temp;
}

Node *right_rotate(Node *root) {
    Node *temp = root->lchild;
    root->lchild = temp->rchild;
    temp->rchild = root;
    return temp;
}

Node *insert_maintain(Node *root) {
    if (!hasRedChild(root)) return root;
    if (root->lchild->color == RED && root->rchild->color == RED) {
        if (!hasRedChild(root->lchild) && !hasRedChild(root->rchild)) return root;
        goto insert_end;
    }
    if (root->lchild->color == RED) {
        if (!hasRedChild(root->lchild)) return root;
        if (root->lchild->rchild->color == RED) {
            root->lchild = left_rotate(root->lchild);
        }
        root = right_rotate(root);
    } else {
        if (!hasRedChild(root->rchild)) return root;
        if (root->rchild->lchild->color == RED) {
            root->rchild = right_rotate(root->rchild);
        }
        root = left_rotate(root);
    }
insert_end:
    root->color = RED;
    root->lchild->color = root->rchild->color = BLACK;
    return root;
}

Node *__insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (root->key > key) root->lchild = __insert(root->lchild, key);
    else root->rchild = __insert(root->rchild, key);
    return insert_maintain(root);
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = BLACK;
    return root;
}

Node *predeccessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild != NIL) temp = temp->rchild;
    return temp;
}

Node *erase_maintain(Node *root) {
    if (root->lchild->color != DOUBLE_BLACK && root->rchild->color != DOUBLE_BLACK) return root;
    if (root->rchild->color == DOUBLE_BLACK) {
        if (root->lchild->color == RED) {
            root->color = RED;
            root->lchild->color = BLACK;
            root = right_rotate(root);
            root->rchild = erase_maintain(root->rchild);
            return root;
        }
        if (!hasRedChild(root->lchild)) {
            root->color += 1;
            root->lchild->color -= 1;
            root->rchild->color -= 1;
            return root;
        }
        if (root->lchild->lchild->color != RED) {
            root->lchild->rchild->color = BLACK;
            root->lchild->color = RED;
            root->lchild = left_rotate(root->lchild);
        }
        root->lchild->color = root->color;
        root->rchild->color -= 1;
        root = right_rotate(root);
        root->lchild->color = root->rchild->color = BLACK;
    } else {
        if (root->rchild->color == RED) {
            root->color = RED;
            root->rchild->color = BLACK;
            root = left_rotate(root);
            root->lchild = erase_maintain(root->lchild);
            return root;
        }
        if (!hasRedChild(root->rchild)) {
            root->color += 1;
            root->lchild->color -= 1;
            root->rchild->color -= 1;
            return root;
        }
        if (root->rchild->rchild->color != RED) {
            root->rchild->lchild->color = BLACK;
            root->rchild->color = RED;
            root->rchild = right_rotate(root->rchild);
        }
        root->rchild->color = root->color;
        root->lchild->color -= 1;
        root = left_rotate(root);
        root->lchild->color = root->rchild->color = BLACK;
    }
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NIL) return root;
    if (root->key > key) {
        root->lchild = __erase(root->lchild, key);
    } else if (root->key < key) {
        root->rchild = __erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            temp->color += root->color;
            free(root);
            return temp;
        } else {
            Node *temp = predeccessor(root);
            root->key = temp->key;
            root->lchild = __erase(root->lchild, temp->key);
        }
    }
    return erase_maintain(root);
}

Node *erase(Node *root, int key) {
    root = __erase(root, key);
    root->color = BLACK;
    return root;
}

void clear(Node *root) {
    if (root == NIL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}

void output(Node *root) {
    if (root == NIL) return ;
    printf("%d [%d, %d] %s\n", 
        root->key, 
        root->lchild->key, 
        root->rchild->key,
        root->color ? "BLACK" : "RED"
    );
    output(root->lchild);
    output(root->rchild);
    return ;
}

int main() {
    int op, val;
    Node *root = NIL;
    while (~scanf("%d%d", &op, &val)) {
        switch (op) {
            case 1: root = insert(root, val); break;
            case 2: root = erase(root, val); break;
        }
        output(root);
    }
    return 0;
}

```

