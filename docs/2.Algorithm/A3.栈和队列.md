---
id : A3.æ ˆå’Œé˜Ÿåˆ—
titile : A3.æ ˆå’Œé˜Ÿåˆ—
typora-root-url : ../
---

# æ ˆ,é˜Ÿåˆ—

>  æ ˆè§£å†³å®Œå…¨åŒ…å«é—®é¢˜



| DS         | åº”ç”¨                  | å¤‡æ³¨ |
| ---------- | --------------------- | ---- |
| æ ˆ         | æ ‘çš„æ·±åº¦éå†,å›¾çš„æ·±æœ |      |
| é˜Ÿåˆ—(å¾ªç¯) | æ ‘çš„å±‚åºéå†,å›¾çš„å¹¿æœ |      |
| å•è°ƒæ ˆ     | ä¸´è¿‘æœ€å¤§(å°)å€¼        |      |
| å•è°ƒé˜Ÿåˆ—   | åŒºé—´æœ€å¤§(å°)å€¼        |      |



## æ ˆ

### æ ˆçš„å®ç°



### æ ˆä¹ é¢˜

#### lc-20-æ‹¬å·åŒ¹é…

```c
 bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }
        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
```

```c
bool isValid(char * s){
    int len = strlen(s);
    char*stack = (char *)malloc(sizeof(char) * len);
    int top = -1, flag = 1;
    for (int i = 0; i < len; ++i) {
        switch (s[i]) {
            case '(' : 
            case '[' : 
            case '{' : 
                stack[++top] = s[i]; 
                break;
            case ')' :
                flag = (top != -1 && stack[top--] == '(' );
                break;
            case ']' :
                flag = (top != -1 && stack[top--] == '[' );
                break;
            case '}' :
                flag = (top != -1 && stack[top--] == '{');
                break;
        }
        if (!flag) return false;
    }
    return top == -1;
}
```

#### [LC_946.éªŒè¯æ ˆåºåˆ—](https://leetcode-cn.com/problems/validate-stack-sequences/description/)

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if (pushed.size() != popped.size()) {
            return false;
        } 
        int size = pushed.size();
        int j = 0;
        stack<int> s;
        for (int i = 0; i < size; i++) {
            s.push(pushed[i]);
            while (!s.empty() && j < size && s.top() == popped[j]) {
                s.pop();
                j++;
            }
        }
        return j == size;
    }
};
```



## é˜Ÿåˆ—

### é˜Ÿåˆ—çš„å®ç°

```cpp
/*************************************************************************
	> File Name: 3.queue.cpp
	> Author: weier 
	> Mail: 1931248856@qq.com
	> Created Time: 2020å¹´06æœˆ20æ—¥ æ˜ŸæœŸå…­ 14æ—¶49åˆ†22ç§’
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Queue {
    int *data;
    int size, head, tail, cnt;
} Queue;

Queue *init(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data = (int *)malloc(sizeof(int) * n);
    q->size = n;
    q->head = q->tail = q->cnt = 0;
    return q;
}

int front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->cnt == 0;
}

int expand(Queue *q) {
    int extr_size = q->size;
    int *p;
    while (extr_size) {
        p = (int *)malloc(sizeof(int) * (q->size + extr_size));
        if (p) break;
        extr_size >>= 1;
    }
    if (p == NULL) return 0;
    for (int j = 0; j < q->cnt; ++j) {
        p[j] = q->data[(q->head + j) % q->size];
    }
    free(q->data);
    q->data = p;
    q->size += extr_size;
    q->head = 0;
    q->tail = q->cnt;
    return 1;
}

int push(Queue *q, int val) {
    if (q == NULL) return 0;
    if (q->cnt == q->size) {
        printf("\033[;31m expand : %d\033[0m\n\n", expand(q));
    }
    q->data[q->tail++] = val;
    if(q->tail == q->size) q->tail -= q->size;
    q->cnt += 1;
    return 1;
}

int pop(Queue *q) {
    if (q == NULL) return 0;
    if (empty(q)) return 0;
    q->head++;
    if (q->head == q->size) q->head -= q->size;
    q->cnt -= 1;
    return 1;
}

void output(Queue *q) {
    printf("Queue : [");
    for (int i = 0; i < q->cnt; ++i) {
        i != 0 && printf(", ");
        printf("%d", q->data[(q->head + i) % q->size]);
    }
    printf("]\n\n");
    return ;
}

void clear(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    #define max_op 40
    srand(time(0));
    Queue *q = init(1);
    for (int i = 0; i < max_op; ++i) {
        int val  = rand() % 100;
        int op = rand() % 4;
        switch (op) {
            case 0 : 
            case 1 :
            case 2 : {
                printf("push %d to the Queue = %d\n", val, push(q, val));
            } break;
            case 3 : {
                int head = front(q);
                printf("pop %d from the Queue = %d\n", head, pop(q));
            } break;
        }
        output(q);
    }
    clear(q);
    #undef max_op
    return 0;
}
```







## äºŒã€å•è°ƒé˜Ÿåˆ—

### æ¦‚è¿°

1. æœ¬è´¨é—®é¢˜æ˜¯ï¼šå›ºå®šæŸ¥è¯¢ç»“å°¾çš„ RMQ é—®é¢˜ï¼Œä¾‹å¦‚ $RMQ(x, 7)$
2. é—®é¢˜æ€§è´¨ï¼šç»´æŠ¤æ»‘åŠ¨çª—å£æœ€å€¼é—®é¢˜
3. å…¥é˜Ÿï¼šå°†é˜Ÿå°¾è¿åå•è°ƒæ€§çš„å…ƒç´ æ·˜æ±°å‡ºå±€ï¼Œå†å°†å½“å‰å…ƒç´ å…¥é˜Ÿ
4. å‡ºé˜Ÿï¼šå¦‚æœé˜Ÿé¦–å…ƒç´ è¶…å‡ºäº†æ»‘åŠ¨çª—å£çš„èŒƒå›´ï¼Œé˜Ÿé¦–å‡ºé˜Ÿ
5. é˜Ÿé¦–å…ƒç´ ï¼šæ»‘åŠ¨çª—å£å†…çš„æœ€å€¼
6. å‡æ‘Šæ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

### RMQé—®é¢˜

> RMQ ( Range Minimum / Maximum Query ) æ˜¯æŒ‡ï¼šå¯¹äºé•¿åº¦ä¸º n çš„æ•°åˆ— Aï¼Œå›ç­”è‹¥å¹²è¯¢é—® RMQ (A , i , j ) ( i , j â‰¤ n)ï¼Œè¿”å›æ•°åˆ—Aä¸­ä¸‹æ ‡åœ¨ i , j é‡Œçš„**æœ€å°ï¼ˆå¤§ï¼‰å€¼**ã€‚
>
> RMQé—®é¢˜æ˜¯æŒ‡æ±‚**åŒºé—´æœ€å€¼**çš„é—®é¢˜ã€‚



#### å•è°ƒé˜Ÿåˆ—

```cpp
#define MAX_N 300000
int q[MAX_N + 5], head = 0, tail = 0;
int val[MAX_N + 5];

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
    }
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] > val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    head = tail = 0;
    for (int i = 1; i <= n; i++) {
        while (tail - head && val[q[tail - 1]] < val[i]) --tail;
        q[tail++] = i;
        if (q[head] <= i - k) head++;
        if (i >= k) {
            i > k && cout << " ";
            cout << val[q[head]];
        }
    }
    cout << endl;
    return 0;
}
```







#### HZOJ-271-æ»‘åŠ¨çª—å£

å•è°ƒé˜Ÿåˆ—çš„è£¸é¢˜ï¼Œæ²¡ä»€ä¹ˆå¥½è®²çš„ï¼Œä¸»è¦è¦å­¦ä¹ ä»£ç å®ç°

**æ€è€ƒï¼š**å•è°ƒé˜Ÿåˆ—ä¸­æ˜¯è®°å½•å€¼è¿˜æ˜¯è®°å½•ä¸‹æ ‡çš„é—®é¢˜

**ç»“è®ºï¼š**è®°å½•ä¸‹æ ‡ï¼Œå› ä¸ºæœ‰äº†ä¸‹æ ‡å¯ä»¥ç´¢å¼•åˆ°å€¼ï¼Œè®°å½•å€¼åˆ™åå‘ä¸å¯æŸ¥

```cpp
#define MAX_N 100000
long long s[MAX_N + 5], top;
long long h[MAX_N + 5], n;
long long l[MAX_N + 5], r[MAX_N + 5];

void read() {
    scanf("%lld", &n);
    for (long long i = 1; i <= n; i++) scanf("%lld", h + i);
    return ;
}

long long solve() {
    h[0] = h[n + 1] = -1;
    top = -1;
    s[++top] = 0;
    for (long long i = 1; i <= n; i++) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        l[i] = s[top];
        s[++top] = i;
    }
    top = -1;
    s[++top] = n + 1;
    for (long long i = n; i >= 1; i--) {
        while (top != -1 && h[s[top]] >= h[i]) --top;
        r[i] = s[top];
        s[++top] = i;
    }
    long long ans = 0;
    for (long long i = 1; i <= n; i++) {
        ans = max(ans, h[i] * (r[i] - l[i] - 1));
    }
    return ans;
}

int main() {
    read();
    cout << solve() << endl;
    return 0;
}
```





## 

#### hzoj-372-åŒç”Ÿé˜Ÿåˆ—

å•è°ƒé˜Ÿåˆ—è§£å†³å›ºå®šæœ«å°¾ï¼²ï¼­ï¼±é—®é¢˜

```c
int a[MAX_N + 5], b[MAX_N + 5];
int main() {
    int n, p = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> a[i];
    for (int i = 0; i < n; ++i) cin >> b[i];
    int top1 = -1, top2 = -1;
    while (p < n) {
        while (top1 != -1 && a[p] < a[top1]) --top1;
        while (top2 != -1 && b[p] < b[top2]) --top2;
        a[++top1] = a[p];
        b[++top2] = b[p];
        p += 1;
    }
    cout << p << endl;
    return 0;
}

```

#### 





#### ç»´æŠ¤åŒºé—´æœ€å°æœ€å¤§

ä¾‹å­ï¼šæœ‰  7 6 8 12 9 10 3 ä¸ƒä¸ªæ•°å­—ï¼Œç°åœ¨è®©ä½ æ‰¾å‡ºèŒƒå›´ï¼ˆ i-4ï¼Œi ï¼‰ çš„æœ€å°å€¼ã€‚

å…ˆåˆå§‹åŒ–{ 0 } ï¼ˆè¡¨ç¤ºi=0æ—¶çš„å€¼ï¼‰

i=1 ->{ 0 } ï¼ˆè¡¨ç¤ºi=1,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º0ï¼‰-> 7è¿›é˜Ÿ { 7 } ï¼›

i=2->{ 7 }ï¼ˆè¡¨ç¤ºi=2,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º7ï¼‰-> 6æ¯”7å°ï¼Œ7å‡ºï¼Œ6è¿› { 6 }ï¼›

i=3-> { 6 } ï¼ˆè¡¨ç¤ºi=3,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º6ï¼‰->8æ¯”6å¤§ï¼Œ8è¿›  { 6, 8}ï¼›

i=4->{ 6, 8}ï¼ˆè¡¨ç¤ºi=4,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º6ï¼‰-> 12æ¯”8å¤§ï¼Œ12è¿› {6, 8 , 12};

i=5-> {6, 8 , 12}ï¼ˆè¡¨ç¤ºi=4,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º6ï¼‰-> 9æ¯”12å°ï¼Œ12outï¼Œ9æ¯”8å¤§ï¼Œ9è¿› {6ï¼Œ8,  9}ï¼›

i=6-> {6ï¼Œ8,  9} ä½†æ˜¯ å•è°ƒé˜Ÿåˆ—ä¸­å…ƒç´ 6çš„ä¸‹æ ‡æ˜¯2ï¼Œä¸åœ¨ï¼ˆ2, 6],ä¸­ï¼Œæ•…6 outï¼Œè¿™å°±æ˜¯å•è°ƒé˜Ÿåˆ—çš„ç²¾é«“äº†ã€‚æ•…å•è°ƒé˜Ÿåˆ—ä¸º

{ 8,9 }ï¼ˆè¡¨ç¤ºi=5,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º8ï¼‰->10æ¯”9å¤§ï¼Œ10è¿› æœ€ç»ˆ å•è°ƒé˜Ÿåˆ—ä¸º{ 8ï¼Œ9, 10} ;

i=7->{ 8ï¼Œ9, 10}ï¼ˆè¡¨ç¤ºi=6,æ—¶ï¼Œåœ¨å…¶èŒƒå›´å†…æœ€å°çš„å€¼ä¸º8ï¼‰-> 3æ¯”å•è°ƒé˜Ÿåˆ—ä¸º{ 8ï¼Œ9, 10} çš„ä»»æ„å€¼éƒ½å°ï¼Œæ•…å…¨outï¼Œæœ€ç»ˆé›†åˆä¸º { 3 }ï¼›



å•è°ƒé˜Ÿåˆ—çš„æ ¸å¿ƒï¼ˆæˆ‘è®¤ä¸ºçš„å“ˆï¼‰ï¼šå¾—åˆ°å½“å‰çš„æŸä¸ªèŒƒå›´å†…çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼,é¢˜ç›®æ˜¯æœ‰é™åˆ¶çš„ï¼Œè§„å®šåœ¨æŸä¸ªèŒƒå›´å†…æ‰¾ã€‚


```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define max_n 300000

int arr[max_n + 5];
int q[max_n + 5], head, tail;

int main() {
    int n, k;
    cin >> n  >> k;
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    head = tail = 0;
    for (int i = 0; i < n; ++i) {
        while (tail - head != 0 && arr[i] < arr[q[tail - 1]]) tail--;
        q[tail++] = i;
        if (i + 1 < k) continue;
        if (i - q[head] == k) head++;
        i + 1 == k || cout << " ";
        cout << arr[q[head]];
    }
    cout << endl;
    head = tail = 0;
    for (int i = 0; i < n; ++i) {
        while (tail - head != 0 && arr[i] >= arr[q[tail - 1]]) tail--;
        q[tail++] = i;
        if (i + 1 < k) continue;
        if (i - q[head] == k) head++;
        i + 1 == k || cout << " ";
        cout << arr[q[head]];
    }
    cout << endl;
    return 0;
}

```



#### æœ€å¤§å­åºåˆ—

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define max_n 300000

long long  s[max_n + 5]= {0};
int q[max_n + 5], head, tail;

int main() {
    int n, m;
    long long ans;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> s[i], s[i] += s[i - 1];
    head = tail = 0;
    q[tail++] = 0;
    ans = s[1];
    for (int i = 1; i <= n; ++i)  {
        if (i - q[head] > m) head++;
        ans = max(ans, s[i] - s[q[head]]);
        while (tail - head && s[i] < s[q[tail - 1]]) tail--;
        q[tail++] = i;
    }
    cout << ans << endl;
    return 0;
}

```



## ä¸‰ã€å•è°ƒæ ˆ

1. å•è°ƒæ ˆä¿ç•™äº†å•è°ƒé˜Ÿåˆ—çš„ã€å…¥é˜Ÿã€æ“ä½œ
2. å•è°ƒæ ˆä¾ç„¶æ˜¯ç»´æŠ¤äº†ä¸€ç§å•è°ƒæ€§
3. é—®é¢˜æ€§è´¨ï¼šæœ€è¿‘ï¼ˆå¤§äº/å°äºï¼‰å…³ç³»
4. å…¥æ ˆä¹‹å‰ï¼Œç¬¦åˆå•è°ƒæ€§çš„æ ˆé¡¶å…ƒç´ ï¼Œå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘ï¼ˆå¤§äº/å°äºï¼‰å…³ç³»
5. å‡æ‘Šæ—¶é—´å¤æ‚åº¦ï¼š$O(1)$



#### å•è°ƒæ ˆ

+ å®šä¹‰ï¼šå•è°ƒæ ˆï¼Œæ ˆåº•åˆ°æ ˆé¡¶ï¼ŒæŒ‰ç…§å•è°ƒé€’å¢æˆ–è€…å•è°ƒé€’å‡çš„é¡ºåºã€‚

+ åº”ç”¨åœºæ™¯

  é¢å¯¹ä¸€ä¸ªåºåˆ—ï¼Œç»å¸¸å¯ä»¥è¢«ç”¨æ¥åº”ç”¨æ±‚ï¼š

    + å·¦è¾¹è·ç¦»å®ƒæœ€è¿‘ä¸”æ¯”å®ƒå¤§/å°çš„æ•°å­—å’Œå³è¾¹è·ç¦»å®ƒæœ€è¿‘çš„ä¸”æ¯”ä»–å¤§/å°çš„æ•°å­—

    + å½“å‰å…ƒç´ çš„å·¦è¾¹æœ€å¤§/æœ€å°çš„å…ƒç´ ã€‚

      æ¯”å¦‚å•è°ƒå‡å¢æ ˆã€‚å¯¹äºæŸä¸ªå…ƒç´ ï¼Œå®ƒä¸‹é¢çš„æ•°å°±æ˜¯ä»–å·¦è¾¹è·ç¦»æœ€è¿‘çš„æ¯”ä»–å¤§çš„æ•°å­—ï¼Œè®©å®ƒå¼¹å‡ºå°±æ˜¯å®ƒå³è¾¹è·ç¦»æœ€è¿‘çš„æ¯”å¤§çš„æ•°å­—ã€‚ä¸”**åœ¨æ¯æ¬¡å¼¹å‡ºæ—¶å¼€å§‹è®¡ç®—æœ‰å…³é¢˜ç›®è¦æ±‚çš„**ã€‚

  + æœ«å°¾æ³¨æ„   
    åœ¨éå†æ‰€æœ‰å…ƒç´ ç»“æŸçš„æ—¶å€™ï¼Œå¦‚æœæ ˆä¸­è¿˜æœ‰å…ƒç´ ï¼Œè¦ä¾æ¬¡å¼¹å‡ºç»“ç®—ã€‚

    æ¯”å¦‚ï¼Œå­˜åœ¨æ•°ç»„ `[3,5,4,7,1]`ï¼Œä¿æŒæ ˆæ˜¯å•ç‹¬é€’å‡ã€‚ 

    ```
    1ï¼‰é¦–å…ˆå°†3å…¥æ ˆï¼Œæ­¤æ—¶æ ˆæ˜¯ç©ºçš„ï¼Œå¯ä»¥ç›´æ¥å…¥æ ˆ
    1) å½“å°†5å…¥æ ˆæ—¶ï¼Œ5æ¯”3å¤§ï¼Œæ­¤æ—¶å°±å¯ä»¥è®¡ç®—3çš„å³ä¾§è·ç¦»æœ€è¿‘çš„æ¯”ä»–å¤§çš„å…ƒç´ ï¼Œè¿™ä¸ªå…ƒç´ å°±æ˜¯5.å› ä¸º3å·¦ä¾§æ²¡æœ‰é‚£ä¹ˆå…ƒç´ ï¼Œé‚£ä¹ˆå°±æ˜¯NULLã€‚å°†3å¼¹å‡ºåï¼Œå†å°†5å…¥æ ˆ
    2) 4æ¯”5å°ï¼Œå¯ä»¥ç›´æ¥å…¥æ ˆï¼Œ
    4ï¼‰7å¤§äº4ï¼Œå› æ­¤æ­¤æ—¶è¦è®¡ç®—4çš„å·¦å³ä¸¤ä¾§è·ç¦»æœ€è¿‘æ¯”ä»–å¤§çš„å…ƒç´ ã€‚å·¦ä¾§æ˜¯5ï¼Œå³ä¾§æ˜¯è®©ä»–å¼¹å‡ºçš„å…ƒç´ 7
    1) åŒç†ï¼Œä¹Ÿè¦å¼¹å‡º5ï¼Œå·¦ä¾§æ˜¯nullï¼Œå³ä¾§æ˜¯7
    6ï¼‰å…¥æ ˆ7
    7ï¼‰å…¥æ ˆ1
    8ï¼‰æ­¤æ—¶åºåˆ—å·²ç»éå†ç»“æŸï¼Œè¦å¼¹å‡º1ï¼Œè®©1å¼¹å‡ºçš„å› ä¸ºéå†ç»“æŸï¼Œå³ä¾§æ˜¯null.å·¦ä¾§7
    9ï¼‰è®©7å¼¹å‡ºçš„æ˜¯nullï¼Œå·¦ä¾§ä¹Ÿæ˜¯null
    
    é¡ºä¾¿ä¹ŸçŸ¥é“äº†ï¼Œå·¦å³ä¸¤ä¾§éƒ½æ˜¯nullçš„å…ƒç´ å°±æ˜¯æœ€å¤§å€¼ã€‚
    ```

    å¦‚æœé¢˜ç›®æœ‰é™å®šæ¡ä»¶ï¼Œæ¯”å¦‚ä¸ä¼šå‡ºç°`INT_MAX`ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯å¯ä»¥åœ¨åŸæ•°ç»„åé¢ `nums.push_back(INT_MAX)` ï¼Œè¿™æ ·å°±ä¸ç”¨å†å•ç‹¬è®¨è®ºåºåˆ—éåŠç»“æŸæ—¶å€™çš„é—®é¢˜äº†ã€‚



#### HZOJ-261-æ•°æ®ç»“æ„

1. å…³é”®å°±æ˜¯æ–°é€ ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œç»“æ„å®šä¹‰ + ç»“æ„æ“ä½œ
2. æ¨¡æ‹Ÿå…‰æ ‡çš„åŠŸèƒ½ï¼Œå·¦ç§»åŠ¨ã€å³ç§»åŠ¨ã€æ’å…¥ã€åˆ é™¤ï¼Œç”¨å¯¹é¡¶æ ˆæ¨¡æ‹Ÿ
3. å®ç°å¯¹é¡¶æ ˆï¼Œç”¨æ•°ç»„æ¨¡æ‹Ÿã€ç”¨é“¾è¡¨æ¨¡æ‹Ÿ
4. é¢˜ç›®ä¸­çš„ BUGï¼šQuery K ä¸­ï¼ŒK å¯èƒ½å¤§äºå½“å‰ä½ç½®

```cpp
#include <cinttypes>
using namespace std;

class NewStruct {
public :
    NewStruct() {
        sum[0] = 0;
        ans[0] = INT64_MIN;
    }
    void insert(long long x) {
        s1.push(x);
        int ind = s1.size();
        long long val = x + sum[ind - 1];
        long long val1 = max(ans[ind - 1], val);
        sum[ind] = val;
        ans[ind] = val1;
        return ;
    }
    void del() {
        if (s1.empty()) return ;
        s1.pop();
        return ;
    }
    void move_left() {
        if (s1.empty()) return ;
        s2.push(s1.top());
        del();
        return ;
    }
    void move_right() {
        if (s2.empty()) return ;
        insert(s2.top());
        s2.pop();
        return ;
    }
    long long query(long long k) {
        return ans[k];
    }
private:
    stack<long long> s1, s2;
    long long sum[1005];
    long long ans[1005];
};

int main() {
    long long n;
    cin >> n;
    string op;
    int val;
    NewStruct s;
    for (int i = 0; i < n; i++) {
        cin >> op;
        switch (op[0]) {
            case 'I': cin >> val; s.insert(val); break;
            case 'D': s.del(); break;
            case 'L': s.move_left(); break;
            case 'R': s.move_right(); break;
            case 'Q': {
                cin >> val; 
                cout << s.query(val) << endl;
            } break;
        }
    }
    return 0;
}
```

#### hzoj-262 å¡ç‰¹å…°æ•°



f(n)è¡¨ç¤ºè¿›æ ˆé¡ºåºä¸º1,2,...,Næ—¶å¯èƒ½çš„å‡ºæ ˆæ–¹æ¡ˆæ•°ï¼Œæ ¹æ®ä»¥å‰çš„ç»éªŒï¼Œæˆ‘ä»¬éœ€è¦æŠŠå®ƒåˆ’åˆ†æˆèŒƒå›´æ›´å°çš„å­é—®é¢˜ã€‚
è€ƒè™‘â€œ1â€â€œ1â€è¿™ä¸ªæ•°æ’åœ¨æœ€ç»ˆåºåˆ—çš„ä½ç½®ï¼Œå¯çŸ¥åªè¦â€œ1â€â€œ1â€çš„ä½ç½®ä¸åŒï¼Œåºåˆ—å°±ä¸åŒã€‚å¦‚æœâ€œ1â€â€œ1â€è¿™ä¸ªæ•°æ’åœ¨ç¬¬*ğ‘˜*kä¸ªï¼Œé‚£ä¹ˆæ•´ä¸ªåºåˆ—è¿›å‡ºæ ˆçš„è¿‡ç¨‹å³ä¸ºï¼š

1. â€œ1â€**å…¥æ ˆ**ã€‚

2. â€œ2,3,...,k"è¿™*ğ‘˜*âˆ’1kâˆ’1ä¸ªæ•°æŒ‰æŸç§é¡ºåº**è¿›å‡ºæ ˆ**ã€‚

3. â€œ1â€**å‡ºæ ˆ**ã€‚

4. â€œk+1,k+2,...,Nâ€è¿™*ğ‘*âˆ’*ğ‘˜*Nâˆ’kä¸ªæ•°æŒ‰æŸç§é¡ºåº**è¿›å‡ºæ ˆ**ã€‚

   ç”±äº k  æœ€åå‡ºæ ˆï¼Œåˆ™åœ¨ k å…¥æ ˆä¹‹å‰æ‰€æœ‰æ¯”ä»–å°çš„éƒ½å‡ºæ ˆäº†ï¼Œè¿™é‡Œçš„æƒ…å†µä¸º Fï¼ˆk-1ï¼‰ï¼Œæ‰€æœ‰æ¯” k å¤§çš„å…ƒç´ éƒ½åœ¨ k ä¹‹å‰å‡ºæ ˆï¼Œä¸º Fï¼ˆn-kï¼‰ç§æƒ…å†µ

äºæ˜¯è¿™æ ·å°±æŠŠåŸé—®é¢˜åˆ’åˆ†æˆäº†èŒƒå›´æ›´å°çš„å­é—®é¢˜ï¼Œå¾—åˆ°å…¬å¼ï¼š

$f(n)=âˆ‘_{i=1}^Nf(kâˆ’1)âˆ—f(Nâˆ’k)$



å½“ç„¶ï¼Œè¾¹ç•Œæ¡ä»¶ä¸ºï¼š*ğ‘“*(0)=1,*ğ‘“*(1)=1f(0)=1,f(1)=1

æ—¶é—´å¤æ‚åº¦ä¸º*ğ‘‚*(*ğ‘›*2)O(n2)ã€‚





#### HZOJ-263-ç«è½¦è¿›æ ˆ

1. å½“å‰è¿›æ ˆçš„æœ€å¤§æ•°å­—æ˜¯ xï¼Œåºåˆ—ä¸­å½“å‰å¾…å‡ºæ ˆçš„æ•°å­—æ˜¯ y
2. $y <= x$ï¼Œè¯´æ˜ y ä¸€å®šæ˜¯æ ˆé¡¶å…ƒç´ 
3. $y > x$ï¼Œå°† $[x + 1, y]$ å…¥æ ˆï¼Œæ­¤æ—¶æ ˆé¡¶å…ƒç´ ä¸€å®šæ˜¯ y



```cpp
int a[30], s[30], top;

bool is_valid(int *a, int n) {
    int j = 0;
    top = -1;
    for (int i = 0; i < n; i++) {
        while (j < a[i]) { s[++top] = (++j); }
        if (top == -1 || s[top] - a[i]) return false;
        --top;
    }
    return true;
}

int main() {
    int n, ans = 20;
    cin >> n; 
    for (int i = 0; i < n; i++) a[i] = i + 1;
    do {
        if (!is_valid(a, n)) continue;
        for (int i = 0; i < n; i++) {
            cout << a[i];
        }
        cout << endl;
        --ans;
    } while (ans && next_permutation(a, a + n));
    return 0;
}
```



#### hzoj-68. æœ‹å‹é˜Ÿåˆ—



![image-20210308140505286](/Image/A3.æ ˆå’Œé˜Ÿåˆ—-photo/image-20210308140505286.png)



Code:

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;
#define MAX_N 200000

map<int, int> q_ind;
queue<int> main_q;
queue<int> q[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    for (int i = 1, m; i <= n; i++) {
        cin >> m;
        for (int j = 1, a; j <= m; j++) {
            cin >> a;
            q_ind[a] = i;
        }
    }
    string op;
    while (cin >> op) {
        if (op == "STOP") break;
        if (op == "ENQUEUE") {
            int x;
            cin >> x;
            q[q_ind[x]].push(x);
            if (q[q_ind[x]].size() == 1) {
                main_q.push(q_ind[x]);
            }
        } else {
            cout << q[main_q.front()].front() << endl;
            q[main_q.front()].pop();
            if (q[main_q.front()].empty()) main_q.pop();
        }
    }
    return 0;
}

```



#### HZOJ-264-æœ€å¤§çŸ©å½¢é¢ç§¯

1. åˆ†ææœ€ä¼˜è§£çš„æ€§è´¨ï¼Œæ˜¯è§£å†³é—®é¢˜çš„ç¬¬ä¸€æ­¥
2. æœ€å¤§çŸ©å½¢çš„æ€§è´¨ï¼šä¸€å®šæ˜¯ä»¥å…¶æ‰€åœ¨åŒºåŸŸä¸­æœ€çŸ®çš„æœ¨æ¿ä¸ºé«˜åº¦çš„
3. ä»¥æ¯ä¸€å—æœ¨æ¿åšä¸ºçŸ©å½¢é«˜åº¦ï¼Œæ±‚èƒ½å¾—åˆ°çš„æœ€å¤§çŸ©å½¢é¢ç§¯ï¼Œæœ€ååœ¨æ‰€æœ‰é¢ç§¯ä¸­ï¼Œå–ä¸€ä¸ªæœ€å¤§å€¼
4. éœ€è¦æ±‚è§£ï¼šæ¯ä¸€å—æœ¨æ¿æœ€è¿‘çš„é«˜åº¦å°äºå½“å‰æœ¨æ¿çš„ä½ç½®ï¼Œæ‰€ä»¥éœ€è¦ç”¨å•è°ƒæ ˆ





#### LC-221-æœ€å¤§æ­£æ–¹å½¢-dp,å•è°ƒæ ˆ

```c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
};


int maximalSquare(char** matrix, int matrixRowSize, int matrixColSizes) {
    int n = matrixRowSize, m = matrixColSizes;
    if (n == 0) return 0;
    int **cnt = (int **)malloc(sizeof(int *) * n);
    int *q = (int *)malloc(sizeof(int) * m);
    int head, tail, l;
    for (int i = 0; i < n; i++) cnt[i] = (int *)malloc(sizeof(int) * m);
    for (int i = 0; i < m; i++) cnt[0][i] = (matrix[0][i] == '1');
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cnt[i][j] = (matrix[i][j] == '1' ? cnt[i - 1][j] + 1 : 0);
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        head = tail = 0;
        l = 0;
        for (int j = 0; j < m; j++) {
            while (tail - head > 0 && cnt[i][q[tail - 1]] > cnt[i][j]) --tail;
            q[tail++] = j;       
            while (j - l >= 0 && j - l + 1 > cnt[i][q[head]]) {
                ++l;
                if (q[head] < l) ++head;
            }
            ans = fmax(ans, (j - l + 1) * (j - l + 1));    
        }
    }
    for (int i = 0; i < n; i++) free(cnt[i]);
    free(cnt);
    free(q);
    return ans;
}
```

#### LC-42-æ¥é›¨æ°´-å•è°ƒæ ˆ



![img](/Image/A3.æ ˆå’Œé˜Ÿåˆ—-photo/9f74f1cf461b56d9c2cf016674190211319faeead9c7ff919a9bddda43131272-å›¾ç‰‡.png)

å•è°ƒé€’å‡æ ˆ

å½“åé¢çš„æŸ±å­é«˜åº¦æ¯”å‰é¢çš„ä½æ—¶ï¼Œæ˜¯æ— æ³•æ¥é›¨æ°´çš„,å½“æ‰¾åˆ°ä¸€æ ¹æ¯”å‰é¢é«˜çš„æŸ±å­ï¼Œå°±å¯ä»¥è®¡ç®—æ¥åˆ°çš„é›¨æ°´,æ‰€ä»¥ä½¿ç”¨å•è°ƒé€’å‡æ ˆ,å¯¹æ›´ä½çš„æŸ±å­å…¥æ ˆ

æ›´ä½çš„æŸ±å­ä»¥ä¸ºè¿™åé¢å¦‚æœèƒ½æ‰¾åˆ°é«˜æŸ±å­ï¼Œè¿™é‡Œå°±èƒ½æ¥åˆ°é›¨æ°´ï¼Œæ‰€ä»¥å…¥æ ˆæŠŠå®ƒä¿å­˜èµ·æ¥
å¹³åœ°ç›¸å½“äºé«˜åº¦ 0 çš„æŸ±å­ï¼Œæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«å½±å“
å½“å‡ºç°é«˜äºæ ˆé¡¶çš„æŸ±å­æ—¶

41. è¯´æ˜å¯ä»¥å¯¹å‰é¢çš„æŸ±å­ç»“ç®—äº†
42. è®¡ç®—å·²ç»åˆ°æ‰‹çš„é›¨æ°´ï¼Œç„¶åå‡ºæ ˆå‰é¢æ›´ä½çš„æŸ±å­

è®¡ç®—é›¨æ°´çš„æ—¶å€™éœ€è¦æ³¨æ„çš„æ˜¯

é›¨æ°´åŒºåŸŸçš„å³è¾¹ r æŒ‡çš„è‡ªç„¶æ˜¯å½“å‰ç´¢å¼• i
åº•éƒ¨æ˜¯æ ˆé¡¶ st.top() ï¼Œå› ä¸ºé‡åˆ°äº†æ›´é«˜çš„å³è¾¹ï¼Œæ‰€ä»¥å®ƒå³å°†å‡ºæ ˆï¼Œä½¿ç”¨ cur æ¥è®°å½•å®ƒï¼Œå¹¶è®©å®ƒå‡ºæ ˆ
å·¦è¾¹ l å°±æ˜¯æ–°çš„æ ˆé¡¶ st.top()
é›¨æ°´çš„åŒºåŸŸå…¨éƒ¨ç¡®å®šäº†ï¼Œæ°´å‘çš„é«˜åº¦å°±æ˜¯å·¦å³ä¸¤è¾¹æ›´ä½çš„ä¸€è¾¹å‡å»åº•éƒ¨ï¼Œå®½åº¦æ˜¯åœ¨å·¦å³ä¸­é—´
ä½¿ç”¨ä¹˜æ³•å³å¯è®¡ç®—é¢ç§¯

**å½“å‡ºç°å½“å‰æœ¨æ¿é«˜åº¦å°äºæ ˆé¡¶çš„æœ¨æ¿é«˜åº¦ï¼Œé‚£ä¹ˆå°±å¯ä»¥è®¡ç®—æ ˆé¡¶æœ¨æ¿èƒ½å­˜å‚¨çš„æ°´é¢ç§¯äº†**

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> stk;
        int ans = 0;
        for (int i = 0; i < height.size(); ++i) {
            while (!stk.empty() && height[stk.top()] <= height[i]) {
                int cur = stk.top();
                stk.pop();
                if (stk.empty()) break;
                int width = i - stk.top() - 1;
                int h = min(height[i], height[stk.top()]) - height[cur];
                ans += width * h;
            } 
            stk.push(i);
        }
        return ans;
    }
};
```

####  LC-74-æŸ±çŠ¶å›¾ä¸­æœ€å¤§çŸ©å½¢

![image-20200629203350213](/Image/A3.æ ˆå’Œé˜Ÿåˆ—-photo/image-20200629203350213.png)

å“¨å…µçš„æŠ€å·§:è™šæ‹Ÿå¤´èŠ‚ç‚¹,æ’å…¥æ’åº

1. éå†å®Œæˆåæ ˆé¡¶ä¸€å®šæ‹“å±•åˆ°æœ«å°¾
2. å¼¹å‡ºæ ˆé¡¶å,æ ˆä¸ºç©º,ä¸€å®šå¯ä»¥æ‹“å±•å¤§æœ€å·¦è¾¹
3. æ ˆä¸­å­˜åœ¨é«˜åº¦ç›¸ç­‰çš„å…ƒç´ ,ä¸€ç§solutionæ˜¯åˆ¤æ–­å¼¹å‡ºå,åˆ¤æ–­æ˜¯å¦ç­‰;å®é™…æ²¡å¿…è¦,æ–°æ ˆé¡¶ä¼šè®¡ç®—æ­£ç¡®ç»“æœ

```cpp
 int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        int ans = 0;
        vector<int> newHeights;
        newHeights.push_back(0);
        for (int i = 0; i < n; ++i) newHeights.push_back(heights[i]);
        newHeights.push_back(0);
        n += 2;
        stack<int> mono_stack;
        mono_stack.push(0);
        for (int i = 1; i < n; ++i) {
            while (newHeights[mono_stack.top()] > newHeights[i]) {
                int h = newHeights[mono_stack.top()];
                mono_stack.pop();
                int width = i - mono_stack.top() - 1;
                ans = max(ans, h * width);
                
            }
            mono_stack.push(i);
        }
        return ans;
    }
};
```

```cpp
//é”™è¯¯åœ¨å¯¹äºéå†å®Œæˆå,è®¡ç®—æ— æ³•å¤„ç†ç¬¬2ä¸­æƒ…å†µ;æ‰€ä»¥å…ˆå¼¹æ ˆ
while (newHeights[mono_stack.top()] > newHeights[i]) {
                int h = newHeights[mono_stack.top()];
                int width = i - mono_stack.top();
                ans = max(ans, h * width);
                mono_stack.pop();
            }

```

#### [ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº I](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

è¿™é“é¢˜ï¼Œç›´è§‚ä¸Šæ±‚çš„å°±æ˜¯å¯¹äºæ¯ä¸ªå…ƒç´ å…¶æ¯”ä»–å¤§çš„å³è¾¹çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ã€‚å•è°ƒæ ˆçš„è§£æ³•ï¼Œå·§å¦™çš„è½¬æ¢äº†æ€è·¯ï¼šæ±‚çš„æ˜¯å¯¹äºå½“å‰å…ƒç´ å…¶å·¦è¾¹æœ€å°çš„å…ƒç´ ã€‚ä¿æŒæ ˆçš„å•è°ƒé€’å‡å±æ€§ï¼Œé‚£ä¹ˆæ¯æ¬¡å¯¹äºå½“å‰å…ƒç´ è€Œè¨€ï¼Œå…¶å·¦è¾¹æœ€å°çš„å…ƒç´ å°±æ˜¯æ ˆåº•ã€‚

å› æ­¤ï¼Œå¯¹äºå½“å‰æ•°ï¼š`curr - base`

```cpp
class Solution {
public:
    int maxProfit(std::vector<int>& prices) {
        std::stack<int> path; 

        int base =0;       // æ ˆåº•
        int maxProfit = 0; 
        for(int i=0; i < prices.size(); ++i) {   
            // æ ˆé¡¶çš„å€¼ > å½“å‰å€¼ï¼Œé‚£ä¹ˆå¯ä»¥è®¡ç®—æœ€å¤§åˆ©æ¶¦äº†
            while(!path.empty() && prices[path.top()] > prices[i]) { 

                int top = path.top(); path.pop();  // æ ˆé¡¶
                // æ ˆä¸­çš„å…ƒç´ è‚¯å®šæ˜¯ä¿æŒå•è°ƒé€’å¢çš„
                int profit = prices[top] - prices[base];
                maxProfit = std::max(profit, maxProfit);
            }
            // å½“å‰å…ƒç´  prices[i] æ¯”æ ˆä¸­ä»»ä½•ä¸€ä¸ªå…ƒç´ éƒ½å°æ—¶ï¼Œå°±ä¼šä½¿å¾—æ ˆç©º
            if(path.empty()) { base =i; }

            path.push(i);
        }

        while(!path.empty()) { 
            int top = path.top(); 
            path.pop(); 
                
            int profit = prices[top] - prices[base];
            maxProfit = std::max(profit, maxProfit);
        }

        return maxProfit;
    }
};
```

## 

## åŒç«¯é˜Ÿåˆ—

åŒç«¯é˜Ÿåˆ—ï¼Œç»´æŠ¤ç€ä¸€ä¸ªçª—å£ï¼Œåœ¨è¿™ä¸ªçª—å£é‡Œä¿æŒç€å•è°ƒæ€§ã€‚èµ·å§‹æœ‰ä¸¤ä¸ªæŒ‡é’ˆ`L`å’Œ`R`ï¼Œéƒ½æ˜¯æŒ‡å‘çª—å£é¦–æ®µã€‚

+ `L` å’Œ `R` åªèƒ½å‘å³å¢åŠ ï¼Œä¸èƒ½å›é€€
+ åŒç«¯é˜Ÿåˆ—ä»å¤´éƒ¨åˆ é™¤è¿‡æœŸå…ƒç´ 
+ åŒç«¯é˜Ÿåˆ—ä»å°¾éƒ¨å¢åŠ æ–°çš„å…ƒç´ 

å½“æ±‚çª—å£å†…çš„æœ€å¤§å€¼æ—¶ï¼Œè®©åŒç«¯é˜Ÿåˆ—ä»é˜Ÿé¦–åˆ°é˜Ÿå°¾æŒ‰ä¿æŒå•è°ƒé€’å‡ï¼š**åŒç«¯é˜Ÿåˆ—çš„å¤´å§‹ç»ˆæŒ‡å‘æœ€å¤§å€¼ï¼Œå°¾éƒ¨æ˜¯æœ€å°å€¼**ã€‚æ¯æ¬¡å–æœ€å¤§å€¼æ—¶å°±ç›´æ¥ä»é˜Ÿé¦–å–å‡ºå…ƒç´ å³å¯ã€‚æ­¤å¤–å¯¹äºæ•°ç»„ï¼Œé˜Ÿåˆ—é‡Œå­˜æ”¾çš„å¯ä»¥æ˜¯å…ƒç´ ä¸‹æ ‡ã€‚

+ é˜Ÿå°¾ï¼š`R` æŒ‡å‘æ–°çš„å…ƒç´ ã€‚è‹¥æ–°å…ƒç´ å°äºé˜Ÿå°¾çš„å…ƒç´ å°±ç›´æ¥å…¥é˜Ÿï¼›è‹¥å¤§äºç­‰äºé˜Ÿå°¾çš„å…ƒç´ ï¼Œå°±ä¸€ç›´å¼¹å‡ºé˜Ÿå°¾çš„å…ƒç´ ï¼Œç›´åˆ°å°¾éƒ¨çš„å…ƒç´ å¤§äºæ–°å…ƒç´ æˆ–è€…é˜Ÿåˆ—æ˜¯ç©ºã€‚
+ é˜Ÿé¦–ï¼šå½“`L`å‘å³ç§»ï¼Œå°±æ£€æµ‹é˜Ÿé¦–å…ƒç´ æ˜¯å¦è¿‡æœŸ

è¿™é‡Œçš„çª—å£ä¸æ˜¯å›ºå®šçš„ï¼Œå¯ä»¥ä»»æ„æ‰©å……ç¼©å‡ã€‚

## åº”ç”¨

### [æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode-cn.com/problems/sliding-window-maximum/)

å¯¹äºåºåˆ— `[1,3,-1,-3,5,3,6,7], k=3`ã€‚   

```
    [1, 3, -1, -3, 5, 3, 6, 7] 
    0  1   2   3  4  5  6  7

    è®¾ç«‹ä¸€ä¸ªè¾…åŠ©åŒç«¯é˜Ÿåˆ— dqeue ï¼Œå¼€å§‹æ—¶å€™ï¼ŒLã€R æŒ‡å‘é˜Ÿåˆ—é¦–ã€‚
    1) R å³ç§»ä¸€ä½ï¼Œæ­¤æ—¶dqeueä¸ºç©ºï¼Œ1ä»dqeueå°¾éƒ¨åŠ å…¥
    2ï¼‰R==3æ—¶ï¼Œ3æ¯”1å¤§ï¼Œè¦ä¿æŒçª—å£å†…å…ƒç´ å•è°ƒé€’å‡ï¼Œéœ€è¦å°†1ä»å°¾éƒ¨å¼¹å‡ºï¼Œ3åŠ å…¥ã€‚
    3ï¼‰R==-1ï¼Œ-1æ¯”3å°ï¼Œå…¥é˜Ÿã€‚
    4) æ­¤æ—¶çª—å£æ»‘è¿‡äº†å‰ä¸‰ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå–å‡ºä¸‰ä¸ªå…ƒç´ ä¸­çš„æœ€å¤§å€¼ï¼Œç›´æ¥ä»é˜Ÿé¦–å–å‡ºã€‚
    5ï¼‰R==-3ï¼Œæ¯”-1å°ï¼Œå…¥é˜Ÿã€‚
    6) æ­¤æ—¶çª—å£æ»‘è¿‡[3,-1,-3]ï¼Œæœ€å¤§å€¼å°±æ˜¯æ­¤æ—¶çš„é˜Ÿåˆ—é¦–å…ƒç´ ï¼š3ã€‚dd
    7ï¼‰R==5ï¼Œå¤§äº-3ï¼Œ-1ï¼Œå› æ­¤éœ€è¦å°†å…ƒç´ ä¾æ¬¡å¼¹å‡ºï¼Œå†å°†5å‹å…¥ 
    8ï¼‰æ­¤æ—¶çª—å£æ»‘è¿‡[-1,-3, 5]ï¼Œæ­¤æ—¶æœ€å¤§å€¼å°±æ˜¯é˜Ÿåˆ—é¦–å…ƒç´ :5ã€‚
    9ï¼‰R==3ï¼Œå°äº5ï¼Œå…¥é˜Ÿã€‚
    10) æ­¤æ—¶çª—å£æ»‘è¿‡[-3, 5, 3]ï¼Œæœ€å¤§å€¼æ˜¯é˜Ÿåˆ—é¦–å…ƒç´ ï¼š5
    11ï¼‰R==6ï¼Œä¾æ¬¡å°†5å’Œ3å¼¹å‡ºï¼Œ6å…¥é˜Ÿ
    10ï¼‰æ­¤æ—¶æ»‘åŠ¨çª—å£æ»‘è¿‡[5,3,6]ï¼Œæœ€å¤§å€¼å°±æ˜¯é˜Ÿé¦–ï¼š6
    11ï¼‰R==7ï¼Œå¼¹å‡º6ï¼Œå…¥é˜Ÿ7
    12ï¼‰æ­¤æ—¶æ»‘åŠ¨çª—å£åˆ’è¿‡[3,6,7]ï¼Œæœ€å¤§å€¼å°±æ˜¯é˜Ÿé¦–ï¼š7
```

ä»é˜Ÿåˆ—ä¸­åˆ é™¤å…ƒç´ ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š

+ é˜Ÿé¦–å…ƒç´ è¿‡æœŸï¼Œå³å½“é˜Ÿé¦–å…ƒç´ å’Œå½“å‰å…ƒç´ è·ç¦»ä¹‹å·®è¶…è¿‡çª—å£å€¼kï¼Œé˜Ÿé¦–å…ƒç´ å°±æ˜¯è¿‡æœŸï¼Œåº”è¯¥ä»é˜Ÿé¦–åˆ é™¤
+ æ–°çš„å…ƒç´ å¤§äºç­‰äºé˜Ÿå°¾å…ƒç´ ï¼Œéœ€è¦ä¸æ–­åœ°å¼¹å‡ºé˜Ÿå°¾å…ƒç´ ï¼Œç›´åˆ°æ»¡è¶³é˜Ÿå°¾å¤§äºæ–°çš„å…ƒç´ ï¼Œæˆ–è€…å¼¹åˆ°ç©º 

```cpp
  class Solution {
  public:
      std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
              
        int N = nums.size();
        std::vector<int> windMax(N -k+1);
        std::list<int> path;

        for(int R=0; R < N; ++R) { 

          while(!path.empty() && nums[path.back()] <= nums[R]) { 
            path.pop_back();
          }

          path.push_back(R);

          // æ–°å…ƒç´ çš„åŠ å…¥å¯èƒ½ä¼šå¯¼è‡´çª—å£å¤§äº k 
          // ä½¿å¾—é˜Ÿåˆ—é¦–éƒ¨å…ƒç´ è¿‡æœŸ
          if(path.front() + k == R) { 
            path.pop_front();
          }

          // åªè¦çª—å£å¤§äºç­‰äºkï¼Œå°±éœ€è¦è®¡ç®—ä¸‹æœ€å¤§å€¼
          if(R >= k-1) { 
            windMax[R-(k-1)] = nums[path.front()];
          }
        }

        return windMax;
      }
  };
```

### çª—å£çš„æœ€å¤§å€¼å‡å»æœ€å°å€¼å°äºç­‰äº `num` çš„å­æ•°ç»„ä¸ªæ•°

> ç°è±¡ï¼š  
>
> + å¦‚æœä¸€ä¸ªå­æ•°ç»„æ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè¿™ä¸ªå­æ•°ç»„çš„ä»»ä½•ä¸€ä¸ªå­æ•°ç»„ä¹Ÿç¬¦åˆè¦æ±‚ï¼šå› ä¸ºè¿™ä¸ªå¤§çš„å­æ•°ç»„ä¸­ `max - min <= num` ï¼Œé‚£ä¹ˆè¿™ä¸ªå¤§çš„å­æ•°ç»„çš„å­æ•°ç»„çš„è‚¯å®šä¹Ÿæ˜¯åœ¨`[min, max]`é‡Œé¢
> + å¦‚æœä¸€ä¸ªå­æ•°ç»„ä¸æ»¡è¶³è¦æ±‚ï¼Œé‚£ä¹ˆè¿™ä¸ªå­æ•°ç»„å†æ€ä¹ˆæ‰©ï¼Œä¹Ÿä¸è¾¾æ ‡ï¼šå› ä¸ºè¿™ä¸ªå­æ•°ç»„`max - min > num`ï¼Œé‚£ä¹ˆæ‰©å……åªèƒ½è®© `max`å˜å¤§`min`å˜å°ï¼Œæ›´åŠ ä¸æ»¡è¶³ã€‚  

å»ºç«‹ä¸¤ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œä¸€ä¸ªç”¨æ¥ä¿å­˜æœ€å¤§å€¼ï¼Œä¸€ä¸ªç”¨æ¥ä¿å­˜æœ€å°å€¼ã€‚

+ å¯¹äºæ•°ç»„ `arr` ï¼Œ `L` å’Œ `R` å¼€å§‹æŒ‡å‘èµ·å§‹ä½ç½®
+ `R` å‘å³æ‰©ï¼Œæ‰©åˆ°ç¬¬ä¸€ä¸ªä¸ç¬¦åˆè¦æ±‚çš„å…ƒç´ ï¼Œé‚£ä¹ˆ `[L, R)` éƒ½æ˜¯æ»¡è¶³è¦æ±‚çš„ã€‚ é‚£ä¹ˆä»¥ `L` ä¸ºå¼€å§‹ä¸”ç¬¦åˆè¦æ±‚çš„å­æ•°ç»„å…±æœ‰`R-L`ä¸ªã€‚
+ ç„¶å `L` å³ç§»åŠ¨ï¼Œ`R` é‡å¤ä¹‹å‰åŠ¨ä½œã€‚

```cpp
int getNum(std::vector<int> arr, int num) { 
    if(arr.empty()) return 0;

    std::list<int> qmin;
    std::list<int> qmax;

    int result =0;
    // è®¡ç®—ä»¥æ¯ä¸ª L çš„æƒ…å†µ
    for(int L  =0; L < arr.size(); ++L) { 
        // R æ‰©åˆ°ä¸èƒ½å†æ‰© åœæ­¢
        for(int R=0; R < arr.size(); ++R) { 
            //  å•è°ƒé€’å¢
            while(!qmin.empty() && arr[qmin.back()] >= arr[R]) { 
                qmin.pop_back();
            }
            qmin.push_back(R);

            // å•è°ƒé€’å‡
            while(!qmax.empty() && arr[qmax.back()] <= arr[R]) { 
                qmax.pop_back();
            }
            qmax.push_back(R);

            if(arr[qmax.front()] - arr[qmin.front()] > num) { 
                break;
            }
        }

        // æœ€å°å€¼è¿‡æœŸæŸ¥è¯¢
        if(qmin.front() == L)  qmin.pop_front();
        // æœ€å¤§å€¼è¿‡æœŸæŸ¥è¯¢
        if(qmax.front() == L)  qmax.pop_front();

        result += R - L;
    }

    return result;
}
```

