---
id : C1.Algorithm
title : C1.Algorithm
typora-root-url : ../
---

# 算法



## 技巧

### 1.读数据

![image-20200716100407158](/Image/C1.Algorithm-photo/image-20200716100407158.png)

```cpp
 for (int i = x; i <= n; i++) {
        que.push(i);
    }
    for (int i = 1; i < x; i++) {
        que.push(i);
    }
    while (que.size() != 1) {
        if (have7(t) == 1) {
            que.pop();
        } else {
            que.push(que.front());
            que.pop();
        }
        t++;
    }
```





递推

状态定义->递推公式推导->程序实现

把原始大集合分成若干不相交的子集

拓扑序

有后效性：有合理合法的拓扑序

无后效性：无合法拓扑序，有环

先根据状态转移图得出拓扑序，再根据拓扑序更新值，

容斥原理



优化：

1. 状态定义的优化
2. 转移方程的优化
   - 一般不是转移方程的优化，而是转移方式的优化，二分，堆等
3. 程序实现的优化



贪心

区间问题

![image-20201026205238443](/Image/C1.Algorithm-photo/image-20201026205238443.png)



顺序相关决定如何排序

1. 先r小优先，l大优先 -- 尽可能向后安排
2. 相反

策略相关决定贪心策略





## 卡特兰数



https://blog.csdn.net/qq_30115697/article/details/88906534?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param



### 卡特兰数简介

卡特兰数是组合数学中的一种著名数列，通常用如下通项式表示(为了不与组合数C C*C*冲突，本文用f f*f*表示卡特兰数)：
$f ( n ) = C 2_n + 1 f(n)=\frac{C_{2n}^{n}}{n+1}*f*(*n*)=*n*+1*C*2*n**n*$
当然，卡特兰数也是有递推式的：
$f ( n ) = ∑ i = 0 n − 1 f ( i ) × f ( n − i − 1 ) f(n)=\sum_{i=0}^{n-1}f(i)\times f(n-i-1)*f*(*n*)=*i*=0∑*n*−1*f*(*i*)×*f*(*n*−*i*−1)$
但在实际应用中，最常用的却是第一个通项式的变形：
$f ( n ) = C 2 n n − C 2 n n − 1 f(n)=C_{2n}^{n}-C_{2n}^{n-1}*f*(*n*)=*C*2*n**n*−*C*2*n**n*−1$

### 卡特兰数的应用

#### 基本模型

有一个长度为2 n 2n2*n*的01序列，其中1,0各n n*n*个，要求对于任意的整数k ∈ [ 1 , 2 n ] k \in [1,2n]*k*∈[1,2*n*]，数列的前k k*k*个数中，1的个数不少于0。

#### 解决方法

当然你可以选择用DP秒切。

不知当初哪位神仙想出了这种神奇的构造方法。

我们把0,1操作扔到一个坐标系中。1看成向右上方走一步，0看成向右下角走一步，那么最后构造完后一定走到了( 2 n , 0 ) (2n,0)(2*n*,0)

如下图：

![aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjkvNWM5ZTE2ZTgxMDhlNS5wbmc](/Image/C1.Algorithm-photo/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjkvNWM5ZTE2ZTgxMDhlNS5wbmc.png)



那么总的路径数量就是在2 n 2n2*n*步中选择n n*n*步为1，方案数为$C 2 n nC_{2n}^{n}*C*2*n**n*$。

接着来考虑题目中的限制条件：对于任意前缀，1的个数不少于0。

那么转化到坐标系中，也就是说走的路径不应该穿过x x*x*轴，即直线y = 0 y=0*y*=0，也就是不接触y = − 1 y=-1*y*=−1。

于是我们把与y = − 1 y=-1*y*=−1的接触点的右边整条路径以y = − 1 y=-1*y*=−1为对称轴翻折，于是终点变为了( 2 n , − 2 ) (2n,-2)(2*n*,−2)。如下图：



![aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjkvNWM5ZTE1NjgzODI1MS5wbmc](/Image/C1.Algorithm-photo/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDMvMjkvNWM5ZTE1NjgzODI1MS5wbmc.png)

那么此时，从( 0 , 0 ) (0,0)(0,0)到( 2 n , − 2 ) (2n,-2)(2*n*,−2)的路径必定至少穿过一次y = − 1 y=-1*y*=−1，不满足条件，那么此时的路径数量即为总路径数中不符合题意的路径数，那么我们用总路径数减去不符合的路径数，就是最终的答案。

而此时的路径数量也很简单，由于反转后终点向下移了两位，也就意味着n − 1 n-1*n*−1步是1，n + 1 n+1*n*+1步是0，总方案为C 2 n n − 1 C_{2n}^{n-1}*C*2*n**n*−1，那么最终的答案就是C 2 n n − C 2 n n − 1C_{2n}^{n}-C_{2n}^{n-1}*C*2*n**n*−*C*2*n**n*−1。

诶，这不就是卡特兰数吗。

------

### 例题

1. [洛谷1641 生成字符串](https://www.luogu.org/problemnew/show/P1641)
2. [Loj10238网格](https://loj.ac/problem/10238)

这两道题需要在深刻理解了上述卡特兰数的推导后进行一些变形得出最终的答案。

具体的变动在于，转换成基本模型后，1和0的个数不一样，分别为n n*n*和m m*m*，最后可以得出答案为C n + m n − C n + m m − 1C_{n+m}^{n}-C_{n+m}^{m-1}*C**n*+*m**n*−*C**n*+*m**m*−1。白水一道紫题。

1. [洛谷P2532 树屋阶梯](https://www.luogu.org/problemnew/show/P2532)

这道题我一看两军阵前……，跟卡特兰数好像没有直接关系，但是手画几个样例后，发现答案都是卡特兰数，那么基本上就可以大胆猜想了。

但实际上，我们可以从d p dp*d**p*的角度考虑这道题。对于任意大小为n n*n*的阶梯，我们都可以现在左下角放一个大块，然后在上方构造一个大小为i i*i*的阶梯，右下方构造大小为n − i − 1 n-i-1*n*−*i*−1的阶梯，那么转移方程就十分显然：
f ( n ) = ∑ i = 0 n − 1 f ( i ) ∗ f ( n − i − 1 ) f(n)=\sum_{i=0}^{n-1}f(i)*f(n-i-1)*f*(*n*)=*i*=0∑*n*−1​*f*(*i*)∗*f*(*n*−*i*−1)
显然就是卡特兰数，直接一波通项式+高精度搞定。

1. [洛谷P3200 有趣的数列](https://www.luogu.org/problemnew/show/P3200)

首先有一个结论，对于每个偶数位，上面放的数必须不小于当前位的下标。（意会一下）

转化一下题意：把1~2n这些数依次放入序列，每次可以选择最后的奇数位或偶数位。

然后再观察后发现一个显然的性质：**对于任意时刻，数列中的奇数位数量不能少于偶数位数量**。否则偶数位上放的数不可能大于等于下标。

于是，这就是一个卡特兰数模板，通项式秒切。具体对于组合数的处理，可以参看各种题解。





## 米勒拉宾素数测试

```cpp
int tab[]={2, 3, 5, 7};
long long qpow(int a, int b, int r)  //(a^b)%r  快速幂取模
{
    long long ret = 1, tmp = a;
    while(b)
    {
        if (b&1)
            ret = ret*tmp%r;
        tmp = tmp*tmp%r;
        b >>= 1;
    }
    return ret; 
}
bool  Miller_Rabbin(int n, int a)//米勒拉宾素数测试 
{
    int r = 0, s = n-1, j;
    long long k;
    if(n%a == 0)    return false;
    while((s&1) == 0)
    {
        s >>= 1;
        r++;
    }
    k = qpow(a, s, n);
    if(k == 1)  return true;
    for (j = 0; j < r; j++, k=k*k%n)
        if (k == n-1)
            return true;
    return false;
}
bool Isprime(int n)//判断是否是素数 
{
    for (int i = 0; i < 4; i++)
    {
        if (n == tab[i])
            return true;
        if (!Miller_Rabbin(n, tab[i]))
            return false;
    }
    return true;
}
```







# 17. ==从递推到递归==

## 17.1. 一、递推问题的求解套路

1. 确定递推状态，一个数学符号 + 一个数学符号的语义解释
2. 确定递推状态，推导递推状态符号的自我表示方法
3. 程序实现，（递归+记忆化 / 循环实现）



- 确定递推状态

注意：这是学习递推问题的重中之重。学习确定递推状态的技巧。

$f(x) = y$

y：问题中的求解量，也是我们所谓的因变量

x：问题中直接影响求解量的部分，也是我们所谓的自变量

本质：就是寻找问题中的自变量与因变量



- 推导递推公式

本质：分析状态中的容斥关系

$f(n)=f(n-1)+f(n-2)$

$f(n-1)$，代表 n-1个月的兔子数量，恰巧等于第 n 个月的成年兔子数量

$f(n-2)$，代表 n-2个月的兔子数量，恰巧等于第 n 个月的幼年兔子数量

所谓的推导，就是推导上面的这两句话的内容



## 17.2. 爬楼梯问题

- 状态定义

$f(n)$ 代表爬 n 节楼梯的方法总数

- 递推公式

$f(n)=f(n - 2) + f(n - 3)$



## 17.3. 凑钱币问题

- 状态定义

$f(n, m)$ 代表用前 n 种钱币，拼凑 m 元钱的方案总数

- 递推公式

$f(n, m) = f(n - 1, m) + f(n, m - val[n])$





## 17.4. 墙壁涂色

### 17.4.1. 方法1

技巧：先按照非环情况做，保证所有方案之间，相邻墙壁颜色不同，最后再保证首尾颜色不同

- 状态定义

$f(n, i, j)$ 代表 n 块墙壁，第一块涂颜色 i，最后一块涂颜色 j 的方案总数

- 递推公式

$f(n, i, j) = \sum_{k}{f(n-1,i,k)}\ |\ k \ne j$

loo	

---



### 17.4.2. 方法2

基于第一种做法，优化状态定义，忽略第一块的颜色

- 状态定义

$f(n, j)$ 代表 n 块墙壁，第一块涂颜色 0，最后一块涂颜色 j 的方案总数

- 递推公式

$f(n, j) = \sum_{k}{f(n-1,k)}\ |\ k \ne j$

---



### 17.4.3. 方法3

单刀直入，直接定义状态，求什么定义什么

- 状态定义

$f(n)$ 代表 n 块墙壁，首尾颜色不同的方法总数

- 递推公式

$f(n) = (k - 2) * f(n-1) + (k - 1) \times f(n-2)$





## 17.5. 一、数字三角形

### 17.5.1. 惊人的发现

$f(i, j)$ 代表从底边走到 i, j 点的最大值

$f(i, j)$ 代表从顶点走到 i, j 点的最大值

1. 数学符号完全一致
2. 语义信息不同
3. 递归公式不同
4. 结论：数学符号无法完全代表状态定义



### 17.5.2. 两种方法的对比

本质：两种状态定义方式的对比

1. 第一种：不用做边界判断，最终结果，直接存储在 $f[0][0]$
2. 第二种：需要做边界判断，最终结果，存储在一组数据中
3. 结论：第一种要比第二种优秀



## 17.6. 二、动态规划问题的求解套路

1. 第一步：确定动归状态
2. 第二步：推导状态转移方程，理解：转移、决策；容斥原理
3. 第三步：正确性证明，利用数学归纳法
4. 第四步：程序实现
5. 所谓的转移，把所有决定 $f(i, j)$ 最优值的状态，放入到决策过程中。



## 17.7. 三、附加内容：拓扑序

图形结构是最最抽象的数据结构，必须理解成思维逻辑结构

1. 拓扑序是一种图形结构上的依赖顺序，一个图的拓扑序不唯一
2. 拓扑序的本质作用：是把图形结构上变成一个一维序列
3. 图形结构不能用循环遍历的，一维序列可以
4. 所有递推问题中的状态更新过程，本质上满足拓扑序



## 17.8. 四、最长上升子序列

1. 状态定义

$f(i)$ 代表以为 i 为结尾的，最长上升子序列的长度

2. 状态转移方程

$f(i) = max\left\{f(j)\right\} + 1 | j < i, val[j] < val[i]$

状态转移的时间复杂度：$O(n^2)$



后续重点：优化转移过程

## 17.9. 五、最长公共子序列1. 

1. 状态定义

$f(i,j)$ 代表第一个字符串取前 i 位，第二个字符串取前 j 位的，最长公共子序列的长度

2. 状态转移方程

$f(i,j) = \left\{\begin{aligned} & max[f(i - 1, j), f(i, j - 1)] &val(i) \neq val(j)\\ & f(i - 1, j - 1) &val(i) = val(j)\end{aligned} \right.$

状态转移的时间复杂度：$O(n \times m)$



学习的重点：注意到，参与决策的状态数量，是会根据条件不同而改变的

## 17.10. 六、课后作业题

1. **[HZOJ46-切割回文](http://oj.haizeix.com/problem/46)**
2. **[HZOJ47-0/1背包](http://oj.haizeix.com/problem/47)**
3. **[HZOJ48-完全背包](http://oj.haizeix.com/problem/48)**
4. **[HZOJ49-多重背包](http://oj.haizeix.com/problem/49)**

41，44，45

![image-20210205214350515](/Image/C1.Algorithm-photo/image-20210205214350515.png)

### 17.10.1. P1113 杂务

`John`的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务11。`John`有需要完成的n*n*个杂务的清单，并且这份清单是有一定顺序的，杂务k(k>1)*k*(*k*>1)的准备工作只可能在杂务11至k-1*k*−1中。

写一个程序从11到n*n*读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定`John`的农场有足够多的工人来同时完成任意多项任务



因为任务可以并发，所以一个任务如果有前驱的话，最优方案便是在它的最晚一个前驱结束后就立即开始，而且任务k的前驱节点一定小于k，所以读入时顺便从它的前驱里挑一个最大的转移即可。同时可以更新最终答案。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,l,t,ans[10005],maxans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&i);
        scanf("%d",&l);
        int tmp=0;
        while(scanf("%d",&t)&&t)
            tmp=max(ans[t],tmp);
        ans[i]=tmp+l;
        maxans=max(ans[i],maxans);
    } 
    printf("%d\n",maxans);
    return 0;
 } 
```



### 17.10.2. 大整数

```cpp
using namespace std;
#define MAX_N 1000

struct BigInt: public vector<int> {
    BigInt(int x = 0) {
        push_back(x);
        normal();
    }    
    
    BigInt operator*(int x) {
        BigInt ret(*this);
        for (int i = 0; i < ret.size(); i++) ret[i] *= x;
        ret.normal();
        return ret;
    }

    BigInt operator+(const BigInt &a) {
        BigInt ret(*this);
        for (int i = 0; i < a.size(); i++) {
            if (i < ret.size()) ret[i] += a[i];
            else ret.push_back(a[i]);
        }
        ret.normal();
        return ret;
    }

    void normal() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};

BigInt f[MAX_N + 5];

ostream &operator<<(ostream &out, const BigInt &a) {
    for (int i = a.size() - 1; i >= 0; --i) {
        out << a[i];
    }
    return out;
}

int main() {
    int n, k;
    cin >> n >> k;
    f[1] = k;
    f[2] = (k - 1) * k;
    f[3] = k * (k - 1) * (k - 2);
    for (int i = 4; i <= n; i++) {
        f[i] = f[i - 1] * (k - 2) + f[i - 2] * (k - 1);
    }
    cout << f[n] << endl;
    return 0;
}
```



### 17.10.3. HZOJ-490.cpp

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 32767
int f[MAX_N + 5];

int main() {
    int n;
    cin >> n;
    f[1] = 1;
    for (int i = 2; i <= n; i++) {
        f[i] = (f[i - 1] + 2 - 1) % i + 1;
    }
    int x = n;
    while (f[x] - x) x = f[x];
    cout << n + x << endl;
    return 0;
}
```



### 17.10.4. [52. 例题6：古老的打字机](http://oj.haizeix.com/problem/52)

### 17.10.5. 状态定义

$dp[i]$ 代表打印前 i 个字符的最小消耗值



### 17.10.6. 状态转移方程

定义： $s_i = \sum_{k=1}^{i}c_k$

$dp[i] = min(dp[j] + (s_i - s_j)^2 + M)$



**时间复杂度：**$O(n^2)$



### 17.10.7. 斜率优化

假设从 j 转移要优于从 k 转移

$dp[j] + (s_i-s_j)^2+M < dp[k] + (s_i-s_k)^2+M$

$dp[j] + s_j^2-2s_is_j < dp[k] + s_k^2-2s_is_k$

$(dp[j] + s_j^2) -(dp[k] + s_k^2)< 2s_i(s_j-s_k)$

$\frac{(dp[j] + s_j^2) -(dp[k] + s_k^2)}{s_j-s_k}< 2s_i$

设：$f(i) = dp[i] + s_i^2$

$\frac{f(j) - f(k)}{s_j-s_k}< 2s_i$ ，这东西就是一个斜率

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 1000000
#define SQ(a) ((a) * (a))

long long c[MAX_N + 5], sum[MAX_N + 5];
long long f[MAX_N + 5], dp[MAX_N + 5];
int q[MAX_N + 5], head = 0, tail = 0;
long long n, M;

void set(int i, int j) {
    dp[i] = dp[j] + SQ(sum[i] - sum[j]) + M;
    f[i] = dp[i] + SQ(sum[i]);
    return ;
}

//斜率
double slope(int i, int j) {
    return  1.0 * (f[i] - f[j]) / (sum[i] - sum[j]);
}

int main() {
    cin >> n >> M;
    for (int i = 1; i <= n; ++i) cin >> c[i], sum[i] = sum[i - 1] + c[i];
    q[tail++] = 0;
    for (int i = 1; i <= n; ++i) {
        while (tail - head >= 2 && slope(q[head], q[head + 1]) <= 2 * sum[i]) ++head;
        set(i, q[head]);
        while (tail - head >= 2 && slope(q[tail - 1], q[tail - 2]) > slope(q[tail - 1], i)) --tail;
        q[tail++] = i;
    }
    cout << dp[n] << endl;
    return 0;
}

```





### 17.10.8. HZOJ-51-矩阵

> 在一个黑白相间的矩形中，问有多少个全白色的子矩形。

```cpp
/*************************************************************************
	> File Name: 51.cpp
	> Author: huguang
	> Mail: hug@haizeix.com
	> Created Time: 二  5/12 20:10:06 2020
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 1000
int f[MAX_N + 5];
int a[MAX_N + 5]; // 向下数，连续白色格子的数量
int s[MAX_N + 5], top = -1;


int main() {
    int n, m, ans = 0;
    cin >> n >> m;
    a[m + 1] = -1;
    f[m + 1] = 0;
    for (int  i = 1; i <= n; i++) {
        for (int j = 1, val; j <= m; j++) {
            cin >> val;
            if (val == 1) a[j] += 1;
            else a[j] = 0;
        }
        top = -1;
        s[++top] = m + 1;
        for (int j = m; j >= 1; j--) {
            while (a[s[top]] >= a[j]) top--;
            f[j] = (s[top] - j) * a[j] + f[s[top]];
            f[j] %= 100007;
            s[++top] = j;
            ans += f[j];
            ans %= 100007;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 17.10.9. HZOJ-50.cpp

> 定义鸡蛋的硬度为 kk，则代表鸡蛋最高从 kk 楼扔下来不会碎掉，现在给你 nn 个硬度相同的鸡蛋，楼高为 m，问最坏情况下最少测多少次，可以测出鸡蛋的硬度。

```cpp
/*************************************************************************
    > File Name: 50.cpp
    > Author: hug
    > Mail:   hug@haizeix.com
    > Created Time: 日  5/26 20:34:05 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 32
#define MAX_K 65536
long long dp[MAX_N + 5][MAX_K + 5];

int main() {
    int n, m;
    cin >> n >> m;
    if (n == 1) {
        cout << m << endl;
        return 0;
    }
    for (int i = 2; i <= n; i++) {
        for (int j = 1; dp[i][j - 1] < m; j++) {
            long long val1;
            if (i - 1 == 1) val1 = j - 1;
            else val1 = dp[i - 1][j - 1];
            dp[i][j] = val1 + dp[i][j - 1] + 1;
        }
    }
    int k = 1;
    while (dp[n][k] < m) k++;
    cout << k << endl;
    return 0;
}
```



### 17.10.10. HZOJ-342.cpp

> 有NN个学生合影，战成左端对齐的kk排，每排分别有N1,N2,…,NkN1,N2,…,Nk 个人， 第一排站在最后面，第k排站在最前面。学生的身高互不相同，把他们从高到低依次标记为1,2,…,N1,2,…,N. 在合影时要求每一排从左到右身高依次递减，每一列从后到前身高也递减，问一共有多少种安排合影位置的方案？(1≤N≤30,1≤k≤5)

```cpp
/*************************************************************************
   > File Name: 342.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 一  2/17 23:03:02 2020
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 5
int cnt[MAX_N + 5] = {0};

void solve(int k) {
    if (k == 0) return ;
    memset(cnt, 0, sizeof(cnt));
    for (int i = 0; i < k; i++) cin >> cnt[i];
    long long f[cnt[0] + 1][cnt[1] + 1][cnt[2] + 1][cnt[3] + 1][cnt[4] + 1];
    memset(f, 0, sizeof(f));
    f[0][0][0][0][0] = 1;
    for (int i0 = 0; i0 <= cnt[0]; i0++) {
        for (int i1 = 0; i1 <= cnt[1]; i1++) {
            for (int i2 = 0; i2 <= cnt[2]; i2++) {
                for (int i3 = 0; i3 <= cnt[3]; i3++) {
                    for (int i4 = 0; i4 <= cnt[4]; i4++) {
                        long long val = f[i0][i1][i2][i3][i4];
                        if (i0 >= i1 && i0 >= i2 && i0 >= i3 && i0 >= i4 && i0 < cnt[0])
                            f[i0 + 1][i1][i2][i3][i4] += val;
                        if (i1 >= i2 && i1 >= i3 && i1 >= i4 && i1 < cnt[1])
                            f[i0][i1 + 1][i2][i3][i4] += val;
                        if (i2 >= i3 && i2 >= i4 && i2 < cnt[2])
                            f[i0][i1][i2 + 1][i3][i4] += val;
                        if (i3 >= i4 && i3 < cnt[3])
                            f[i0][i1][i2][i3 + 1][i4] += val;
                        if (i4 < cnt[4])
                            f[i0][i1][i2][i3][i4 + 1] += val;
                    }
                }
            }
        }
    }
    cout << f[cnt[0]][cnt[1]][cnt[2]][cnt[3]][cnt[4]] << endl;
    return ;
}

int main() {
    int k;
    while (cin >> k) solve(k);
    return 0;
}
```



| 无符号右移赋值（Unsigned right shift assignment） | `x >>>= y` | `x = x >>> y` |
| ------------------------------------------------- | ---------- | ------------- |
|                                                   |            |               |



### 17.10.11. Nowder 在二叉树中找到累加和为指定值

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
int n, root, mmax;
struct node{
    int data;
    int lchild, rchild;
};
vector<node> v;
void dfs(int root, int depth, int sum, int &mmaxdepth){
    if(root == 0)
        return;
    sum = sum + v[root].data;
    if(sum == mmax && depth > mmaxdepth)
    {
        mmaxdepth = depth;
    }
    dfs(v[root].lchild, depth+1, sum, mmaxdepth);
    dfs(v[root].rchild, depth+1, sum, mmaxdepth);
}
int maxlen( int root){
    if(root == 0){
        return 0;
    }
    int m0 = 0,ml = 0,mr = 0;
    dfs(root, 1, 0, m0);
    ml = maxlen(v[root].lchild);
    mr = maxlen(v[root].rchild);
    return max(m0, max(ml, mr));
}
int main() {
    int n1, l, r, val;
    scanf("%d %d",&n,&root);
    v.resize(n + 1);
    for(int i = 0;i < n; ++i){
        scanf("%d%d%d%d", &n1, &l, &r, &val);
        v[n1].data = val;
        v[n1].lchild = l;
        v[n1].rchild = r;
    }
    scanf("%d", &mmax);
    cout << maxlen(root) << endl;
}

```



**nautilus**  在终端使用文件夹



# 18. ==动态规划==

![图片](/Image/C1.Algorithm-photo/lALPBG1Q6-8czMbNA5nNBDg_1080_921.png_620x10000q90g.jpg)

### 18.0.12. 海贼 OJ-46-切割回文

1. 状态定义

$dp[i]$ 代表取字符串的前 $i$ 位，最少分成多少段回文串

2. 状态转移

$dp[i] = min(dp[j]) + 1\ |\ s[j + 1, i]\ is\ palindrome$

1. 根据状态转移，算法时间复杂度$O(n^2)$
2. 所以，我们需要对转移阶段进行优化
3. 动态规划优化章节的时候，重点解决



### 18.0.13. 二、海贼-OJ-47-01背包

1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值

2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$



1. 第一种程序实现，状态如何定义的，程序就如何实现
2. 第二种程序实现，使用滚动数组，对代码进行了空间优化
3. 第三种程序实现，将程序中的 $dp$ 数组变成一维的，并且修改了更新顺序



### 18.0.14. 三、海贼 OJ-48-完全背包

1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值



2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i][j-v[i]]+w[i] &选了若干个第 i 件\end{aligned}\right.$$



程序实现的时候，参考01背包的程序实现，将逆向刷表，改成正向刷表



### 18.0.15. 四、海贼 OJ-49-多重背包

问题模型转换

1. 多重背包，每类物品多了一个数量限制
2. 01背包，每种物品只有一个
3. 将多重背包中的数量限制，当做多个单一物品来处理
4. 至此就将多重背包，转成了0/1背包问题



1. 状态定义

$dp[i][j]$ 前 i 个物品，背包最大承重为 j 的情况下，最大价值



2. 状态转移

$$dp[i][j] = max\left\{\begin{aligned}&dp[i-1][j]&没选第 i 件\\&dp[i-1][j-v[i]]+w[i] &选了第 i 件\end{aligned}\right.$$





### 18.0.16. 五、海贼 OJ-50-扔鸡蛋

1. 状态定义

$dp[n][m]$ 用 n 个鸡蛋，测 m 层楼，最坏情况下最少测多少次

2. 状态转移

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$



1. 程序所使用的存储空间与楼层数量强相关
2. 楼层数量达到了 $2^{31}$，所以在这种状态定一下不可行
3. 状态定义不可行，我们就需要优化状态定义
4. 时间复杂度 $O(n \times m^2)$，当 m 过大的时候，无法通过时间限制



## 18.1. 一、动态规划优化的分类

1. 状态转移过程的优化，不改变状态定义，使用一些特殊的数据结构或者算法专门优化转移过程
2. 程序实现的优化，例如：01背包问题。状态定义没有变、转移过程也没变。
3. 状态定义的优化，大量训练，才能培养出来的能力，从源头进行优化
4. 状态定义->源头，转移过程->过程，程序实现->结果



程序优化：01背包，钱币问题，滚动数组



## 18.2. 二、扔鸡蛋问题的优化

### 18.2.1. 转移过程优化

$$dp[n][m] = min(max\left\{\begin{aligned}&dp[n-1][k-1]+1&鸡蛋碎了\\&dp[n][m-k]+1 &鸡蛋没碎\end{aligned})\right.$$

通过观察 k 与 $dp[n-1][k-1]$与 $dp[n][m-k]$之间的关系，最优的转移 k 值，一定发生在两个函数的交点处

优化掉 min 以后，总体时间复杂度变成了 $O(n \times m)$

![image-20210615192401451](/Image/C1.Algorithm-photo/image-20210615192401451.png)

![image-20210615192406407](/Image/C1.Algorithm-photo/image-20210615192406407.png)

### 18.2.2. 状态定义的优化

1. 原状态定义所需存储空间与 m 相关，m 值域大，所以存不下
2. 当发现某个自变量与因变量之间存在相关性的时候，两者即可对调
3. $dp[n][m]=k$ 重定义为$dp[n][k]=m$，代表 n 个鸡蛋扔 k 次，最多测多少层楼
4. k 的值域小，当 n=2 时，$k \le \sqrt{2m}$ 



**状态转移方程：**$dp[n][k] = dp[n-1][k-1]+dp[n][k-1] + 1$

本质上已经不是一个动态规划题目了，实际上变成了一个递推问题

![image-20210615192424816](/Image/C1.Algorithm-photo/image-20210615192424816.png)

## 18.3. 三、多重背包的优化

### 18.3.1. 二进制拆分法

1. 本质上，对于某一类物品，我们具体要选择多少件，才是最优答案
2. 普通的单一拆分法，实际上只是想枚举某个物品选择 1--s 件的所有情况
3. 二进制拆分法可以达到相同的效果，拆分出来的物品数量会更少
4. 拿14举例，普通拆分法 14 份，二进制拆分法 4 份物品



**时间复杂度：**$O(nm\sum_{i=1}^{i=n}{logs_i})$

**最优时间复杂度：**$O(nm)$，借助单调队列，后续再讲

**01背包时间复杂度：**$O(nm)$

**完全背包时间复杂度：**$O(nm)$

![image-20210615192430113](/Image/C1.Algorithm-photo/image-20210615192430113.png)

## 18.4. 四、最长上升子序列

### 18.4.1. 状态定义

$dp[i]$，代表以 i 位做为结尾的最长上升子序列的长度



### 18.4.2. 状态转移

$dp[i] = max(dp[j]) + 1 | val_j < val_i$



### 18.4.3. 优化方式

1. 维护一个单调数组 len，len[i] 代表长度为 i 的序列，结尾最小值
2. $dp[i]$ 在转移的时候，在 len 数组中查找第一个 $len[k]>=val_i$ 的位置，$dp[i] = k$
3. 更新 $len[k] = val_i$
4. 需要明确，len 数组为什么是单调的
5. 证明过程：假设，更新前是单调的，更新以后，一定是单调的
6. 在 len 数组中查找位置 k，实际上就是二分算法搞定



**时间复杂度：**$O(nlogl)$


![image-20210615192434217](/Image/C1.Algorithm-photo/image-20210615192434217.png)




![image-20210615192910900](/Image/C1.Algorithm-photo/image-20210615192910900.png)

## 18.5. 五、切割回文

提前处理得到 mark 数组，$mark[i]$ 存储的是所有以 i 位置做为结尾的回文串的起始坐标，在转移过程中，利用 mark 数组，就可以避免掉大量的无用循环遍历过程。



**时间复杂度：**$O(n+m)$，m 是字符串中回文串的数量



## 18.6. 二、单调队列

1. 本质问题是：固定查询结尾的 RMQ 问题，例如 $RMQ(x, 7)$
2. 问题性质：维护滑动窗口最值问题
3. 入队：将队尾违反单调性的元素淘汰出局，再将当前元素入队
4. 出队：如果队首元素超出了滑动窗口的范围，队首出队
5. 队首元素：滑动窗口内的最值
6. 均摊时间复杂度：$O(1)$

## 18.7. 三、单调栈

1. 单调栈保留了单调队列的『入队』操作
2. 单调栈依然是维护了一种单调性
3. 问题性质：最近（大于/小于）关系
4. 入栈之前，符合单调性的栈顶元素，就是我们要找的最近（大于/小于）关系
5. 均摊时间复杂度：$O(1)$



# 19. ==贪心==

### 19.0.1. HZOJ-253-奶牛晒太阳

```cpp
/*************************************************************************
   > File Name: 253.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 二  6/18 19:31:12 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 2500
struct Range {
    int l, r;
} arr[MAX_N + 5], item[MAX_N + 5];

bool cmp(const Range &a, const Range &b) {
    return a.r < b.r;
}

int main() {
    int n, l;
    cin >> n >> l; 
    for (int i = 0; i < n; i++) {
        cin >> arr[i].l >> arr[i].r;
    }
    for (int i = 0; i < l; i++) {
        cin >> item[i].l >> item[i].r;
    }
    sort(arr, arr + n, cmp);
    int ans = 0;
    for (int i = 0; i < n; i++) {
        int flag = 0, ind = -1;
        for (int j = 0; j < l; j++) {
            if (item[j].r == 0) continue;
            if (item[j].l < arr[i].l || item[j].l > arr[i].r) continue;
            if (ind == -1) {
                ind = j;
                flag = 1;
                continue;
            }
            if (item[j].l < item[ind].l) ind = j;
        }
        if (flag) item[ind].r -= 1;
        ans += flag;
    }
    cout << ans << endl;
    return 0;
}
```



### 19.0.2. HZOJ-255-安装雷达

```cpp
/*************************************************************************
   > File Name: 255.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 二  6/18 19:57:15 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 1000
struct Range {
    double l, r;
} arr[MAX_N + 5];

bool cmp(const Range &a, const Range &b) {
    return a.r < b.r;
}

int main() {
    int n;
    double d;
    cin >> n >> d;
    for (int i = 0; i < n; i++) {
        double x, y;
        cin >> x >> y;
        if (y > d) {
            cout << -1 << endl;
            return 0;
        }
        arr[i].l = x - sqrt(d * d - y * y);
        arr[i].r = x + sqrt(d * d - y * y);
    }
    sort(arr, arr + n, cmp);
    double p = arr[0].r;
    int cnt = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i].l > p) {
            cnt += 1;
            p = arr[i].r;
        }
    }
    cout << cnt << endl;
    return 0;
}
```



### 19.0.3. HZOJ-257-树的颜色

```cpp
/*************************************************************************
   > File Name: 257.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 二  6/18 20:36:44 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 1000

struct Node {
    int father, head, tail;
    int val, cnt;
};

bool operator<(const Node &a, const Node &b) {
    return a.val * b.cnt < a.cnt * b.val;
}

struct UnionSet {
    int fa[MAX_N + 5];
    Node arr[MAX_N + 5];
    int ans[MAX_N + 5];
    inline void init(int n) {
        for (int i = 1 ; i <= n; i++) {
            fa[i] = i;
            ans[i] = 0;
            arr[i].father = 0;
            arr[i].head = arr[i].tail = i;
            arr[i].cnt = 1;
        }
    }
    int get(int x) {
        return (fa[x] == x ? x : get(fa[x]));
    }
    void merge(int a, int b) {
        int aa = get(a), bb = get(b);
        if (aa == bb) return ;
        fa[bb] = aa;
        ans[arr[aa].tail] = arr[bb].head;
        arr[aa].tail = arr[bb].tail;
        arr[aa].val += arr[bb].val;
        arr[aa].cnt += arr[bb].cnt;
        return ;
    }
};

UnionSet u;
priority_queue<Node> que;

int val[MAX_N + 5];

int main() {
    int n, r;
    cin >> n >> r;
    u.init(n);
    for (int i = 1; i <= n; i++) {
        cin >> val[i];
        u.arr[i].val = val[i];
        que.push(u.arr[i]);
    }
    for (int i = 1; i < n; i++) {
        int a, b;
        cin >> a >> b;
        u.arr[b].father = a;
    }
    while (!que.empty()) {
        int ind = que.top().head, fa = u.arr[ind].father;
        que.pop();
        if (fa == 0) continue;
        u.merge(fa, ind);
        que.push(u.arr[u.get(ind)]);
    }
    int p = r, t = 1, ans = 0;
    while (p) {
        ans += val[p] * t;
        p = u.ans[p];
        t++;        
    }
    cout << ans << endl;
    return 0;
}
```



# 20. ==图论==



### 20.0.4. 最短路

foyld算法:慢，多源最短路，求任意两点的最短路径，动归思想   O(n^3)

>这个算法的主要思路，就是通过其他的点进行中转来求的两点之间的最短路。因为我们知道，两点之间有多条路，如果换一条路可以缩短距离的话，就更新最短距离。而它最本质的思想，就是用其他的点进行中转，从而达到求出最短路的目的。
>
>两点之间可以由一个点作为中转点更新最短路径，也可以通过多个点更新最短路径。

------

```cpp
for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(e[i][j]>e[i][k]+e[k][j])
                 e[i][j]=e[i][k]+e[k][j];
```

> 最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程**

dijkstra算法：单源最短路，不能有负权边

> **通过“边”来松弛v1顶点到其余各个顶点的路程**：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！
>
> 贪心
>
> 算法重复从节点集合V-S中选择最短路径估计最小的节点u，将u加入到集合S，然后对所有从u出发的边进行松弛操作。
>
> 当把一个节点选入集合S时，即意味着已经找到了从源点到这个点的最短路径，但若存在负权边，就与这个前提矛盾，可能会出现得出的距离加上负权后比已经得到S中的最短路径还短
>
> -----

bellman-ford算法：单源最短路 O(nm)

> 对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。换句话说，第1轮在对所有的边进行松弛后，得到的是源点最多经过一条边到达其他顶点的最短距离；第2轮在对所有的边进行松弛后，得到的是源点最多经过两条边到达其他顶点的最短距离；第3轮在对所有的边进行松弛后，得到的是源点最多经过一条边到达其他顶点的最短距离

spfa(bellman队列优化)：最坏O(nm)

> 每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。

负环：可能会使得权值越来越小，一直走



### 20.0.5. 存储方式

1. 邻接矩阵

2. 邻接表

   ```cpp
   typedef pair<int, int> PII;
   vector<vector<PII>> v(n + 1, vector<PII>(0));
       for (int i = 0; i < m; ++i) {
           int a, b, c;
           cin >> a >> b >> c;
           v[a].push_back(PII(b, c)); 
           v[b].push_back(PII(a, c));
       }
       for (int i = 1; i <= n; ++i) {
           cout << i << " : ";
           for (int j = 0; j < v[i].size(); ++j) {
               cout << "(" << v[i][j].first << "," << v[i][j].second << ") ";
           }
           cout << endl;
       }
   
   ```

   

3. 链式前向星

   ![image-20201027203837070](/Image/C1.Algorithm-photo/image-20201027203837070.png)

   思想类似与哈希表拉链法，用数组模拟链表实现邻接表



```cpp
struct Edge {
    int u, v, w, next;
};
int head[MAX_N + 5], dist[MAX_N + 5];
Edge e[MAX_M + 5];
inline void addEdge(int u, int v, int w) {
    e[++cnt].u = u;
    e[cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
    return ;
}

```





![image-20201029192331455](/Image/C1.Algorithm-photo/image-20201029192331455.png)

mark标记防止重复4进入队列





## 20.1. floyd

```cpp
int n, m, s, arr[1005][1005];

int main() {
    memset(arr, 0x3F, sizeof(arr));
    cin >> n >> m >> s;
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        arr[a][b] = min(arr[a][b], c);
    }
    for (int i = 1; i <= n; ++i) arr[i][i] = 0;
    for (int i = 1; i <= n; ++i) {  //中转的点
        for (int j = 1; j <= n; ++j) {  //起点
            for (int k = 1; k <= n; ++k) { //终点
                arr[j][k] = min(arr[j][k], arr[j][i] + arr[i][k]);
            }
        }
    }
    for (int i = 1; i <= n; i++)  {
        i != 1 && cout << " ";
        if (arr[s][i] == 0x3F3F3F3F) {
            cout << -1;
        } else {
            cout << arr[s][i];
        }
    }

    return 0;
}

```



## 20.2. dijskstra

```cpp
#define MAX_N 100000
#define MAX_M 200000
#define INF 0x7fffffff

struct Edge {
    int u, v, w, next;
};

struct Node {
    int now, w;
    bool operator<(const struct Node &b) const {
        return this->w > b.w;
    }
};

int head[MAX_N + 5], dist[MAX_N + 5];
bool vis[MAX_M + 5];
int n, m, s, cnt;
Edge e[MAX_M + 5];
priority_queue<Node> que;

inline void addEdge(int u, int v, int w) {
    e[++cnt].u = u;
    e[cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
    return ;
}

void dijkstra(){
    memset(dist, 0x3F, sizeof(dist));
    memset(vis, false, sizeof(vis));
    que.push((Node){s, 0});
    dist[s] = 0;
    while (!que.empty()) {
        Node tmp = que.top();
        que.pop();
        int u = tmp.now;
        if (vis[u]) continue; //维护以计算的最小路径的顶点集合
        vis[u] = true;
        for (int i = head[u]; i != -1; i = e[i].next) {
            int v = e[i].v;
            if (vis[v] == true || dist[v] < dist[u] + e[i].w) continue;
            dist[v] = dist[u] + e[i].w;
            que.push((Node){v, dist[v]});
        }
    }
    return ;
}

int main() {
    memset(head, -1, sizeof(head));
    cin >> n >> m >> s;
    for (int i = 0, a, b, c; i < m; ++i) {
        cin >> a >> b >> c;
        addEdge(a, b, c);
    }
    dijkstra();
    for (int i = 1; i <= n; ++i) {
        i != 1 && cout << " ";
        cout << (dist[i] == 0x3F3F3F3F? INF: dist[i]);
    }
    cout << endl;
    return 0;
}

```



## 20.3. bellman

```cpp
int n, m, s, edg[50005][3], ans[10005];

int main() {
    memset(ans, 0x3F, sizeof(ans));
    cin >> n >> m >> s;
    for (int i = 0; i < m; ++i) {
        cin >> edg[i][0] >> edg[i][1] >> edg[i][2];
    }
    ans[s] = 0;
    for (int i = 1; i < n; ++i) {  //点
        for (int j = 0; j < m; ++j) { //边
            ans[edg[j][1]] = min(ans[edg[j][1]], ans[edg[j][0]] + edg[j][2]);
        	//通过边松弛答案
        }
    }
    for (int i = 1; i <= n; ++i) {
        i != 1 && cout << " ";
        if (ans[i] == 0x3F3F3F3F) cout << 0x7fffffff;
        else cout << ans[i];
    }
    cout << endl;
    return 0;
}

```





## 20.4. spfa(bellman队列优化)

只遍历被更新边的点

```cpp
//bellman-队列优化
struct Edge {
    int v, w, next;
};

Edge edg[500005];
int n, m, s, ans[100005], mark[100005], head[100005];

int main() {
    memset(ans, 0x3F, sizeof(ans));
    memset(head, -1, sizeof(head));
    cin >> n >> m >> s;
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        edg[i].v = b;
        edg[i].w = c;
        edg[i].next = head[a];
        head[a] = i;
    }
    queue<int> que;
    que.push(s);
    ans[s] = 0;
    while (!que.empty()) {
        int temp = que.front();
        que.pop();
        mark[temp] = 0;  //mark避免重复入队
        for (int i = head[temp]; i != -1; i = edg[i].next) {
            int v = edg[i].v, w = edg[i].w;
            if (ans[v] > ans[temp] + w) {
                ans[v] = ans[temp] + w;
                if (mark[v] == 0) {
                    que.push(v);
                    mark[v] = 1;
                }
            }
        }
    }

    for (int i = 1; i <= n; ++i) {
        i != 1 && cout << " ";
        if (ans[i] == 0x3F3F3F3F) cout << 0x7fffffff;
        else cout << ans[i];
    }

    return 0;
}

```



## 20.5. 严格次短路

必须有一条边与最短路不同

![image-20210403134832985](/Image/C1.Algorithm-photo/image-20210403134832985.png)



![image-20210403141440767](/Image/C1.Algorithm-photo/image-20210403141440767.png)

## 20.6. 最小生成树

kruskal：该算法的基本思想是从小到大加入边，是个贪心算法。用幷查集维护不成环

​	边正反存

prim：从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。

具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。



非严格次小生成树

> 稠密图跑 Prim！ 

> 稀疏图跑 Kruskal！

## 20.7. prim

```cpp
struct Edge {
    int v, w, next;
};

struct Node {
    int now, val; //val : 通过权值为多少的边来到这里
    bool operator<(const struct Node &b) const {
        return this->val > b.val;
    }
};

Edge e[400005];
int n, m, ans, edg_cnt, head[5005], already, dist[5005], mark[5005];
//dist : 表示通过权值为多少的边来到这个点
inline void addEdge(int u, int v, int w) {
    e[edg_cnt].v = v;
    e[edg_cnt].w = w;
    e[edg_cnt].next = head[u];
    head[u] = edg_cnt++;

}

int main() {
    memset(head, -1, sizeof(head));
    memset(dist, 0x3f, sizeof(dist));
    cin >> n >> m;
    for (int i = 0, u, v, w; i < m; ++i) {
        cin >> u >> v >> w;
        addEdge(u, v, w);
        addEdge(v, u, w);
    }
    priority_queue<Node> que;
    que.push((Node){1, 0});
    while (!que.empty()) {
        Node tmp = que.top();
        que.pop();
        if (mark[tmp.now] == 1) continue;
        mark[tmp.now] = 1;
        ans += tmp.val;
        already++;
        if (already == n) break;
        for (int i = head[tmp.now]; i != -1; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            if (mark[v] == 0 && dist[v] > w) {
                dist[v] = w;
                que.push((Node){v, w});
            }
        }
    }
    if (already == n) {
        cout << ans << endl;
    } else {
        cout << "orz" << endl;
    }
    return 0;
}

```





## 20.8. kruskal

```cpp
using namespace std;
#define MAX_M 200000
#define MAX_N 5000

struct Edge {
    int u, v, w;
};

bool cmp(const struct Edge &a, const struct Edge &b) {
    return a.w < b.w;
}

Edge e[MAX_M + 5];
int n, m, ans, myUnionSet[MAX_N + 5], already = 1;

int find_root(int x) {
    return myUnionSet[x] = (myUnionSet[x] == x ? x : find_root(myUnionSet[x]));
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> e[i].u >> e[i].v >> e[i].w; 
    }
    for (int i = 0; i <= n; ++i) {
        myUnionSet[i] = i;
    }
    sort(e, e + m, cmp);
    for (int i = 0; i <= m; ++i) {
        int sr = find_root(e[i].u), er = find_root(e[i].v);
        if (sr != er) {
            already++;
            ans += e[i].w;
            myUnionSet[sr] = er;
            if (already == n) {
                break;
            }
        }
        
    }
    if (already == n) {
        cout << ans << endl;
    } else {
        cout << "orz" << endl;
    }
    return 0;
}

```





#### 20.8.0.1. Superbull -最大生成树

> Bessie和她的朋友们正在一年一度的Superbull锦标赛中打球，而Farmer John负责让比赛尽可能激动人心。总共有 N*N* 支队伍（ 1≤N≤20001≤*N*≤2000 ）参加了Superbull锦标赛。每个团队都有一个 1 ... 2 ^ {30} -11...230−1的团队ID。
>
> Superbull是一场淘汰赛 - 在每场比赛之后，FJ选择淘汰其中一支球队，而被淘汰的球队再也无法参加任何比赛了。当只剩下一支球队时，比赛就结束了。
>
> FJ注意到一个不寻常的事情：在任何游戏中，两个团队的总分是两个团队ID的按位异或（XOR）。例如，如果第 1212 队和第 2020 队将参加比赛，则该游戏的得分为 2424 分，因为01100 XOR 10100 = 11000。
>
> FJ想要设计一种比赛方案，让所有比赛的得分总和最大。请帮助Farmer John组织比赛。
>
> 输入格式：第一行包括一个整数 N*N* ，下面 N*N* 行每行包括一个队伍的ID。
>
> 输出格式：输出一个整数，代表比赛的最大总得分。
>
> 样例解释：让 33 队与 99 队进行比赛，并让 99 队晋级。然后他让 66 队和 99 队对决，让 66 队获胜。最后，第 66 队和第 1010 队比赛， 1010 队获胜。总得分为：3 XOR 9+6 XOR 9+6 XOR 10=10+15+12=37。



两点的亦或就是边值，两个点合并一次变一个点（两个队比赛剩一队）



#### 20.8.0.2. P4047部落划分

> 聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。
>
> 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 n*n* 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 k*k* 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：
>
> 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。
>
> 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。

![img](/Image/C1.Algorithm-photo/30573.png)

选n-k条边划分看个部落，找不在同一部落的最小边





#### 20.8.0.3. luogu-P1119 灾后重建



> 给出B*B*地区的村庄数N*N*，村庄编号从00到N-1*N*−1，和所有M*M*条公路的长度，公路是双向的。并给出第i*i*个村庄重建完成的时间t_i*t**i*，你可以认为是同时开始重建并在第t_i*t**i*天重建完成，并且在当天即可通车。若t_i*t**i*为00则说明地震未对此地区造成损坏，一开始就可以通车。之后有Q*Q*个询问(x, y, t)(*x*,*y*,*t*)，对于每个询问你要回答在第t*t*天，从村庄x*x*到村庄y的最短路径长度为多少。如果无法找到从x*x*村庄到y*y*村庄的路径，经过若干个已重建完成的村庄，或者村庄x*x*或村庄y*y*在第t天仍未重建完成 ，则需要返回-1−1。

首先谈谈Floyed算法：Floyd算法的本质是动态规划，其转移方程 为：f[k][i][j] = min( f[k-1][i][j], f([k-1][i] [k])+f[k-1][k][j] )。

f[k][i][j]表示路径除开起点i与终点j，只经过前k个点中的某些 点，从i到j的最小值。计算这个值只需要考虑两种情况：最短路经 过k，和最短路不经过k（那么就经过前k-1个点中的某些点）。由于 k要从k-1转移而来，自然k为最外层的循环。而经过滚动（类似于背 包问题）后，就变成了我们熟悉的f[i][j]=min(f[i][j],f[i] [k]+f[k][j])了。

使用前i个点进行更新

```cpp
#define MAX_N 200
#define MAX_M 20000
int n, m, q;
int matrix[MAX_N + 5][MAX_N + 5];
int t[MAX_N + 5];

inline void update(int k) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);
        }
    }
    return ;
}

int main() {
    memset(matrix, 0x3f, sizeof(matrix));
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; ++i) {
        scanf("%d", t + i);
        matrix[i][i] = 0;
    }
    for (int i = 0, a, b, c; i < m; ++i) {
        scanf("%d%d%d", &a, &b, &c);
        matrix[a][b] = c;
        matrix[b][a] = c;
    }
    scanf("%d", &q);
    int now = 0;
    for (int i = 0, a, b, c; i < q; ++i) {
        scanf("%d%d%d", &a, &b, &c);
        while (t[now] <= c && now < n) update(now), now++;
        if (t[a] > c || t[b] > c) printf("-1\n");
        else if (matrix[a][b] == 0x3f3f3f3f) printf("-1\n");
        else printf("%d\n",matrix[a][b]);
    }
    return 0;
}

```



#### 20.8.0.4. luogu-P1340 兽径管理

> 逆序跑kruskal
>
> 这样的好处在于，一旦发现某一周不能构成最小生成树，那么那周之前也不可能构成最小生成树，于是我们可以少跑很多次kruskal
>
> 因为只能用那一周及之前的兽径建树，而在快排的时候边会被打乱，所以我们在结构体存边时要加一个参数，记录该边是第几周的兽径

```cpp
int prime(int time) {
    uset.init(n);
    memset(mask, false, sizeof(mask));
    int alreaday = 1;
    int ans = 0;
    for (int i = 0; i < m; i++) {
        if (e[i].t > time)  continue;
        int u = e[i].u, v = e[i].v, w = e[i].w;
        if (uset.get(u) == uset.get(v)) continue;
        mask[e[i].t] = true;
        uset.merge(u, v);
        alreaday++;
        ans += w;
        if (alreaday == n)  break;
    }
    return alreaday == n ? ans : -1;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> e[i].u >> e[i].v >> e[i].w;
        e[i].t = i;
    }

    sort(e, e + m, [](const Edge &a, const Edge &b) {
        return a.w < b.w;
    });
    int last = prime(m - 1); 
    vector<int> ans(m);
    ans[m - 1] = last;
    for (int i = m - 2; i >= 0; i--) {
        if (last == -1) {
            ans[i] = -1;
            continue;
        }
        if (mask[i + 1] == true) {
            last = prime(i);
        }
        ans[i] = last;
    }

    for (int i = 0; i < m; i++)  {
        cout << ans[i] << endl;
    }
    return 0;
}
```



#### 20.8.0.5. luogu-P1629 邮递员送信

正着走过去的时候用一便dijkstra。
返回时就建个返图跑一遍dijkstra。

> 有一个邮递员要送东西，邮局在节点 11。他总共要送 n-1*n*−1 样东西，其目的地分别是节点 22 到节点 n*n*。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有 m*m* 条道路。这个邮递员每次只能带一样东西，并且**运送每件物品过后必须返回邮局**。求送完这 n-1*n*−1 样东西并且**最终回到邮局**最少需要的时间。



#### 20.8.0.6. P1144 最短路计数

给出一个N*N*个顶点M*M*条边的无向无权图，顶点编号为1-N1−*N*。问从顶点11开始，到其他每个点的最短路有几条。

请注意可能有自环与重边。

```cpp
void dijskstra(int start) {
    memset(visit, false, sizeof(visit));
    priority_queue<Node> que;
    que.push({start, 0});
    dist[start] = 0;
    ans[start] = 1;
    while (!que.empty()) {
        Node cur = que.top();
        que.pop();
        int now = cur.now;
        if (visit[now]) continue;
        visit[now] = true;
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v;
            if (visit[v] || dist[v] < cur.w + 1) continue;
            if (dist[v] == cur.w + 1) {
                ans[v] += ans[now];
            }
            else {
                dist[v] = cur.w + 1;
                ans[v] = ans[now];
                que.push({v, dist[v]});
            }
            ans[v] %= MOD;
        }
    }
}

```

#### 20.8.0.7. P2865 [USACO06NOV]Roadblocks G

> 贝茜把家搬到了一个小农场，但她常常回到FJ的农场去拜访她的朋友。贝茜很喜欢路边的风景，不想那么快地结束她的旅途，于是她每次回农场，都会选择第二短的路径，而不象我们所习惯的那样，选择最短路。 贝茜所在的乡村有R(1<=R<=100,000)条双向道路，每条路都联结了所有的N(1<=N<=5000)个农场中的某两个。贝茜居住在农场1，她的朋友们居住在农场N（即贝茜每次旅行的目的地）。 贝茜选择的第二短的路径中，可以包含任何一条在最短路中出现的道路，并且，一条路可以重复走多次。当然咯，第二短路的长度必须严格大于最短路（可能有多条）的长度，但它的长度必须不大于所有除最短路外的路径的长度。



```cpp
void bellman(int start, int k) {
    memset(visit, false, sizeof(visit));
    queue<int> que;
    que.push(start);
    dist[k][start] = 0;
    visit[start] = true;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        visit[now] = false;
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            if (dist[k][v] > dist[k][now] + w) {
                dist[k][v] = dist[k][now] + w;
                if (visit[v] == false) {
                    visit[v] = true;
                    que.push(v);
                }
            }
        }
    }
    return ;
}

int main() {
    init();
    cin >> n >> m;
    for (int i = 0, u, v, w; i < m; i++) {
        cin >> u >> v >> w;
        addEdge(u, v, w);
        addEdge(v, u, w);
    }
    bellman(1, 0);
    bellman(n, 1);
    int ans = 0x3f3f3f3f;
    for (int i = 0; i < cnt; i++) {
        int val = dist[0][e[i].u] + dist[1][e[i].v] + e[i].w;
        if (val != dist[0][n] && val < ans) {
            ans = val;
        }
    }
    cout << ans << endl;
    return 0;
}

```





```cpp
void bellman(int start) {
    memset(visit, false, sizeof(visit));
    queue<int> que;
    dist[0][start] = 0;
    que.push(start);
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        visit[now] = false;
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            int val = dist[0][now] + w;
            if (dist[0][v] > val) { //用最短路更新最短路
                dist[1][v] = dist[0][v];
                dist[0][v] = val;
                if (visit[v] == false) {
                    visit[v] = true;
                    que.push(v);
                }
            }
            if (dist[0][v] < val && dist[1][v] > val) { //用最短路更新次短路
                dist[1][v] = val;
                if (visit[v] == false) {
                    visit[v] = true;
                    que.push(v);
                }
            }
            if (dist[1][v] > dist[1][now] + w) { //用次短路更新次短路
                dist[1][v] = dist[1][now] + w; 
                if (visit[v] == false) {
                    visit[v] = true;
                    que.push(v);
                }
            }
        }
    }
}

```





#### 20.8.0.8. hzoj-639. 车站分级

们可以知道一辆车没经过的站，一定比经过的站级别低，我们通过这个建边，然后bfs一下，



#### 20.8.0.9. cd-109-1.约瑟夫环

经典约瑟夫问题，有n个人，每次数到第k个人出列，求剩下的最后一人。

```cpp
#include <iostream>
using namespace std;
  
int main()
{
    int n, m, s, oldn=1, newn=1;
    cin>>n>>m;
      
    for(int i = 1;i<n;i++){
        newn = oldn;
        s = (m-1)%(i+1)+1;
        oldn = newn <= i+1-s? s+newn: newn+s-1-i;
    }
    cout<<oldn<<endl;
    return 0;
}

int main() {
    int n, m;
    cin >> n >> m;
    int res = 0;
    for (int i = 2; i <= n; ++i) res = (res + m) % i;
    cout << res + 1 << endl;
    return 0;
}

```





分析：用线段树模拟约瑟夫问题，记录区间的减少情况，然后根据每次数到的人在区间排第几位，线段树log(n)找到并更新，总复杂度为O(nlog(n))。

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define N 100010
#define mod 1000000007
#define LL long long
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
int n,k;
int sum[N<<2],vis[N];
void Pushup(int rt)
{
    int ls=rt<<1,rs=ls|1;
    sum[rt]=sum[ls]+sum[rs];
}
void build(int l,int r,int rt)
{
    if(l==r)
    {
        sum[rt]=1;return;
    }
    int m=(l+r)>>1;
    build(lson);
    build(rson);
    Pushup(rt);
}
void update(int num,int l,int r,int rt)
{
    if(l==r)
    {
        vis[l]=1;
        sum[rt]=0;
        return;
    }
    int m=(l+r)>>1;
    if(num<=sum[rt<<1])update(num,lson);
    else update(num-sum[rt<<1],rson);
    Pushup(rt);
}
int main()
{
    int T,cas=1;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&k);
        memset(vis,0,sizeof(vis));
        build(1,n,1);
        int num=1;
        for(int i=n;i>1;i--)
        {
            num=(num+k-1)%i;
            if(num==0)num=i;
            update(num,1,n,1);
        }
        for(int i=1;i<=n;i++)
        if(!vis[i])
        {
            printf("Case %d: %d\n",cas++,i);break;
        }
    }
}
```





# 21. ==拓扑排序==

#### 21.0.0.10. 神经网络



> 在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，如果有一条边 *𝑋*X 的终点是第 *𝑖*i 号神经元，那么 *𝑋*X 即为该神经元的输入通道，如果有一条边 *𝑌*Y 的起点是第 *𝑖*i 号神经元，那么 *𝑌*Y 即为该神经元的输出通道，*𝐶**𝑖*Ci 表示神经元目前的状态，*𝑈**𝑖*Ui 是阈值，可视为神经元的一个内在参数。
>
> 神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。
>
> 兰兰规定，*𝐶**𝑖*Ci 服从公式：
>
> *𝐶**𝑖*=∑*𝑊**𝑗**𝑖**𝐶**𝑗*−*𝑈**𝑖*  ((*𝑗*,*𝑖*)∈*𝐸*)Ci=∑WjiCj−Ui  ((j,i)∈E)
>
> 公式中的 *𝑊**𝑗**𝑖*Wji（可能为负值）表示连接 *𝑗*j 号神经元和 *𝑖*i 号神经元的边的权值。当 *𝐶**𝑖*Ci 大于 00 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为*𝐶**𝑖*Ci。
>
> 如此，在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（*𝐶**𝑖*Ci），要求你的程序运算出最后网络输出层的状态。

------

```cpp
int head[MAX_N + 5], in_degree[MAX_N + 5], out_degree[MAX_N + 5];
int c[MAX_N + 5], u[MAX_N + 5];

int main() {
    memset(head, -1, sizeof(head));
    cin >> n >> p;
    queue<int> que;
    for (int i = 1; i <= n; i++) {
        cin >> c[i] >> u[i];
        if (c[i]) que.push(i);
    }
    for (int i = 1, x, y, z; i <= p; i++) {
        cin >> x >> y >> z;
        e[i].v = y;
        e[i].w = z;
        e[i].next = head[x];
        head[x] = i;
        in_degree[y]++;
        out_degree[x]++;
    }
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            if (c[now] > 0) {
                c[v] += c[now] * w;
            }
            in_degree[v]--;
            if (in_degree[v] == 0) {
                que.push(v);
                c[v] -= u[v];
            }
        }
    }
    
    int flag = 0;
    for (int i = 1; i <= n; i++) {
        if (out_degree[i] || c[i] <= 0) continue;
        cout << i << " " << c[i] << endl;
        flag = 1;
    }
    if (!flag) cout << "NULL" << endl;
    return 0;
}

```





#### 21.0.0.11. 旅行计划

>  小明要去一个国家旅游。这个国家有 *𝑁*N 个城市，编号为 11 至 *𝑁*N，并且有 *𝑀*M 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 *𝑖*i 停止。
>
>  所以他就需要选择最先到达的城市，并制定一条路线以城市 *𝑖*i 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。
>
>  现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 *𝑖*i，都需要你为小明制定一条路线，并求出以城市 *𝑖*i 为终点最多能够游览多少个城市。

拓扑排序，更新下一节点的值



#### 21.0.0.12. 宿舍楼里的电竞赛

>  大 *𝑇*T 所在的大学宿舍楼一直以来有着举办电竞比赛的优良传统①① （*𝑊**𝐴**𝑅*3，*𝐶**𝑆*1.6WAR3，CS1.6 等），现在想知道某一年的历史排名，但是记录比赛排名的纸已经被污损了，只有一部分比赛过程被保留了下来，现需要通过这一部分比赛过程，求出那一年有几支队伍的排名是确定的。
>
>  注①：20142014 年举办了最后一届比赛，之后楼长辞职，各种活动和福利全部消失了。

确定排名即确定在该对前面有多少人，后面多少人

可通过Floyd判断任意两点是否可达

```cpp
#define MAX_N 100

int n, m, ans[MAX_N + 5][MAX_N + 5];
int l[MAX_N + 5], r[MAX_N + 5];

int main() {
    memset(ans, 0x3f, sizeof(ans));
    cin >> n >> m;
    for (int i = 0, u, v; i < m; i++) {
        cin >> u >> v;
        ans[u][v] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for(int k = 1; k <= n; k++) {
                ans[j][k] = min(ans[j][k], ans[j][i] + ans[i][k]);
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (ans[i][j] == 0x3f3f3f3f) continue;
            l[i]++;
            r[j]++;
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) {
        if (l[i] + r[i] == n - 1) res++;
    }
    cout << res << endl;
    return 0;
}

```

#### 21.0.0.13. 排序

>  一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 *𝐴*,*𝐵*,*𝐶*,*𝐷*A,B,C,D 表示 *𝐴*<*𝐵*,*𝐵*<*𝐶*,*𝐶*<*𝐷*A<B,B<C,C<D。在这道题中，我们将给你一系列形如 *𝐴*<*𝐵*A<B 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。
>
>  ------
>
>  #### 输入
>
>  第一行有两个整数 *𝑛*,*𝑚*n,m。*𝑛*n 表示需要排序的元素数量，第 11 到 *𝑛*n 个元素将用大写的 *𝐴*,*𝐵*,*𝐶*,*𝐷*A,B,C,D....表示。*𝑚*m 表示将给出的形如 *𝐴*<*𝐵*A<B 的关系的数量。
>
>  接下来有 *𝑚*m 行，每行有 33 个字符，分别为一个大写字母，一个 << 符号，一个大写字母，表示两个元素之间的关系。
>
>  #### 输出
>
>  若根据前 *𝑥*x 个关系即可确定这 *𝑛*n 个元素的顺序 *𝑦**𝑦**𝑦*..*𝑦*yyy..y（如*𝐴**𝐵**𝐶*ABC），输出
>
>  Sorted sequence determined after xxx relations: yyy...y.
>
>  若根据前 *𝑥*x 个关系即发现存在矛盾（如 *𝐴*<*𝐵*,*𝐵*<*𝐶*,*𝐶*<*𝐴*A<B,B<C,C<A），输出
>
>  Inconsistency found after xxx relations.
>
>  若根据这 *𝑚*m 个关系无法确定这 *𝑛*n 个元素的顺序，输出
>
>  Sorted sequence cannot be determined.
>
>  （提示：确定 *𝑛*n 个元素的顺序后即可结束程序，可以不用考虑确定顺序之后出现矛盾的情况）

```cpp
const int MAX_N = 26;
const char BEGIN_LETTER = 'A';

int n, m;
int ans[MAX_N + 5][MAX_N + 5], matrix[MAX_N + 5][MAX_N + 5];
int l[MAX_N + 5], r[MAX_N + 5], in_degree[MAX_N + 5];
char seq[MAX_N + 5];

int haveCycle(int n) {
    memset(in_degree, 0, sizeof(in_degree));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j]) in_degree[j]++;
        }
    }
    queue<int> que;
    for (int i = 0; i < n; i++) {
        if (in_degree[i] == 0) que.push(i);
    }
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        for (int i = 0; i < n; i++) {
            if (matrix[now][i] == 0) continue;
            in_degree[i]--;
            if (in_degree[i] == 0) que.push(i);
        }
    }
    for (int i = 0; i < n; i++) {
        if (in_degree[i]) return 1;
    }
    return 0;
}

int floyed(int n) {
    memset(ans, 0x3f, sizeof(ans));
    memset(l, 0, sizeof(l));
    memset(r, 0, sizeof(r));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j]) ans[i][j] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                ans[j][k] = min(ans[j][k], ans[j][i] + ans[i][k]);
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (ans[i][j] == 0x3f3f3f3f) continue;
            r[i]++;
            l[j]++;
        }
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (r[i] + l[i] == n - 1) cnt++;
        seq[l[i]] = i + BEGIN_LETTER;
    }
    seq[n] = '\0';
    return cnt == n;
}

int main() {
    cin >> n >> m;
    char str[10];
    int flag = 0, ind = -1;
    for (int i = 0; i < m; i++) {
        cin >> str;
        if (flag) continue;
        matrix[str[0] - BEGIN_LETTER][str[2] - BEGIN_LETTER] = 1;
        if (haveCycle(n)) {
            flag = 1;
            ind = i + 1;
        }
        if (floyed(n)) {
            flag = 2;
            ind = i + 1;
        }
    }
    if (flag == 0) {
        cout << "Sorted sequence cannot be determined." << endl;
    } else if (flag == 1) {
        cout << "Inconsistency found after "<< ind << " relations." << endl;
    } else {
           cout << "Sorted sequence determined after " << ind << " relations: " << seq << "." << endl;
    }
    return 0;
}

```





#### 21.0.0.14. ==638. 最长路==

> 给定一个有 *𝑁*N 个点的有向带权无环图，现求从 11 号点到 *𝑁*N 号点的最长路径。

判断是否可达，以及如何求最长路

------

```cpp
int bellman(int start) {
    memset(mask, false, sizeof(mask));
    queue<int> que;
    que.push(start);
    mask[start] = true;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        mask[start] = false;
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v;
            if (v == n) return 0;
            if (mask[v]) continue;
            mask[v] = true;
            que.push(v);
        }
    }
    return 1;
}

int main() {
    init();
    scanf("%d%d", &n, &m);
    for (int i = 0, u, v, w; i < m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        addEdge(u, v, w);
        in_degree[v]++;
    }
    if (bellman(1)) {
        cout << -1 << endl;
        return 0;
    }
    queue<int> que;
    for (int i = 1; i <= n; i++) {
        if (in_degree[i] == 0) que.push(i);
    }
    dist[1] = 0;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        for (int i = head[now]; i != -1; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            dist[v] = max(dist[v], dist[now] + w);
            in_degree[v]--;
            if (in_degree[v] == 0) que.push(v);
        }
    }
    printf("%d\n", dist[n]);
    return 0;
}

```







# 22. 习题

### 22.0.1. 一、预习资料-【数据结构】-逆波兰式

1. 表达式树，最有价值的是当成思维逻辑结构中的数据结构
2. 表达式求值程序，本质上就是对表达式树的递归遍历
3. 重点观察表达式树的特性：根节点是整个表达式中优先级最低的运算符，也就是最后一个被计算的运算符



#### 22.0.1.1. 表达式求解程序

1. **Step1：**找到表达式中优先级最低的运算符的位置
2. **Step2：**递归计算运算符左右两侧表达式的值
3. **Step3：**根据当前运算符获得运算结果



### 22.0.2. 输出逆波兰式

1. 表达式求解程序，本质上是对表达树的遍历
2. 所以，采用后序遍历的方式，输出逆波兰式的结果



#### 22.0.2.1. 二、预习资料-【数据结构】-根据三元组建立二叉链表

1. 本质就是一个模拟题
2. 模拟题的学习重点，就是学习各种各样的模拟技巧，以及对应的编码技巧
3. **技巧1：**用一个数组，记录字符所对应的节点地址



### 22.0.3. 三、预习资料-【数据结构】-植物大战僵尸

1. **题目建模：**每一轮，找到一个集合中的最大值，并且删掉这个最大值。所以，尝试用堆解决。
2. **题目难点：**僵尸之间的相对顺序，时刻发生改变，而堆中，数据是不变的。
3. **问题简化：**如果僵尸之间的相对顺序不变，这道题目，就可以用堆求解，甚至是简单的排序即可。
4. **发现突破口：**当两个僵尸速度相同时，两个僵尸之间的相对位置就不会发生改变。
5. 题目中，速度都是整数，且在1到100之间，也就是说，最多存在 100 种速度。
6. 根据速度，建立 100 个堆，将速度相同的僵尸，塞到一个堆中
7. 每一轮，在100个堆顶元素中，找到一个跑在最前面的僵尸，干掉即可



**Bug-1：**没有严格按照题目要求实现程序，没有考虑到位置相同的情况。

**Bug-2：**写程序中的小笔误，在堆的 pop 操作中，参与比较的两个元素的下标错误。



### 22.0.4. 逆波兰表达式

```cpp
#define INF 0x3f3f3f3f

int calc(char *str, int l, int r) {
    int pos = -1, pri = INF - 1, temp = 0;
    for (int i = l; i <= r; i++) {
        int cur = INF;
        switch (str[i]) {
            case '(': temp += 100; break;
            case ')': temp -= 100; break;
            case '+': 
            case '-': cur = temp + 1; break;
            case '*':
            case '/': cur = temp + 2; break;
            case '^': cur = temp + 3; break;
        }
        if (cur <= pri) {
            pos = i, pri = cur;
        }
    }
    if (pos == -1) {
        int num = 0;
        for (int i = l; i <= r; i++) {
            if (str[i] < '0' || str[i] > '9') continue;
            num = num * 10 + str[i] - '0';
        }
        return num;
    }
    int a = calc(str, l, pos - 1);
    int b = calc(str, pos + 1, r);
    switch (str[pos]) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        case '^': return (int)pow(a, b);
    }
    return 0;
}

char str[10000];

int main() {
    while (~scanf("%[^\n]s", str)) {
        getchar();
        printf("%s = %d\n", str, calc(str, 0, strlen(str) - 1));
    }
    return 0;
}
```

### 22.0.5. 三、预习资料料-【数据结构】-字符串串旋转矩阵

1. 首要解决的问题：还原原字符串
2. **Step1：**通过最后一列的字符，确定相应的第一列的字符
3. **Step2：**得出结论，相同字符的相对顺序在第一列和最后一列中相同
4. **Step3：**确定了每一个字符的编号，以及编号与编号之间的前后关系，即可还原原字符串
5. 由于反复标记 fail 指针链上的状态，导致时间超限，在这里有一个特殊的程序优化

![image-20210223222205261](/Image/C1.Algorithm-photo/image-20210223222205261.png)

## 22.1. 四、预习资料-【数据结构】-灌溉

### 22.1.1. 最小生成树问题-Kruskal 算法

1. Step1：对于所有边从小到大排序
2. Step2：依次取出每一条边，试着加入图中，边上的两个点不联通的情况下，才将边加入图中



除了学习一个新算法以外，这道题目，一无是处。



## 22.2. 五、Leetcode-05-最长回文子串

### 22.2.1. Manacher 算法

1. Step1：对原字符串进行特殊处理，在每两个字符中间加入 # 字符
2. Step2：依次求解每一个位置的最大回文半径
3. 在求解过程中，记录一个 c 点，$c+r[c]$ 最大
4. 求回文半径时：要不然借助原有信息，要不然就是暴力匹配，暴力匹配过程，均摊时间复杂度 O(1)
5. **时间复杂度：**O(n)

![image-20210223231847524](/Image/C1.Algorithm-photo/image-20210223231847524.png)

![image-20210223231903321](/Image/C1.Algorithm-photo/image-20210223231903321.png)

![image-20210223231909267](/Image/C1.Algorithm-photo/image-20210223231909267.png)

## 22.3. 二、剑指 Offer-56-数字出现的次数Ⅱ

1. 写出真值表，推导状态转化公式

![image-20210223221959426](/Image/C1.Algorithm-photo/image-20210223221959426.png)



**扩展问题：**只有一个数字出现次数不足 4 次，其他数字，都出现了 4 次，找到这个数字



## 22.4. 三、HZOJ-646-海贼王堆

1. 堆的裸题
2. 使用 set 模拟堆的行为



## 22.5. 四、面试题反馈

### 22.5.1. 字典树面试题1

**问题描述：**例如一个用户输入了一个字符串：hellu，那它是不存在于字典中的，那么我们怎么判断出来呢？

**要求：**

（1）定义存储所有正确单词的数据结构。

（2）写一个录入单词的函数。

（3）写一个判断用户输入的单词是否正确的函数。

**注：**忽略大小写，可以认为都是小写。

 

### 22.5.2. 字典树面试题2 

**问题描述：**出错的情况下，提示出正确的单词（可能有多个）。出错的情况很多，前中后的位置都有可能出错，可能错一个字母，也可能多一个或少一个字母。

**要求：**

（1）找出跟错误单词相差一个字母的正确单词即可。

（2）定义存储单词的数据结构。

（3）写出查询函数，返回n个正确的单词。





# 23. Linux命令

```shell
ls -l $(which cp) #参数替换
 echo $(($((5**2)) * 3))  #取幂， 括号
 mkdir {2006..2012}-0{1..9}  #括号展开
  mkdir $(echo a{A{1,2},B{3,4}}b) 
  #引用的第一种类型,双引号。如果你把文本放在双引号中,shell 使用的特殊字符,都失去它们的特殊含义,被当作普通字符来看待。有几个例外:$,\ (反斜杠),和 ‘(倒引号)。
# 这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效,然而参数展开、算术展开和命令替换仍然执行。使用双引号,我们可以处理包含空格的文件名。

echo $(cal)             #没有引用的命令替换导致命令行包含 38 个参数
echo "$(cal)"          #只有一个参数,参数中包括嵌入的空格和换行符。
#单引号如果需要禁止所有的展开
Ctrl-r 		#反向增量搜索。从当前命令行开始,向上增量搜索。
Alt-p 		#反向搜索,非增量搜索。(输入要查找的字符串,按下 Enter来执行搜索)。
Alt-n 		#向前搜索,非增量。
Ctrl-o 	 #执行历史列表中的当前项,并移到下一个。如果你想要执行历史列表中一系列的命令,这很方便。
!!  					#重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
!number 	#重复历史列表中第 number 行的命令。
passwd [user] #更改用户密码
vim 连接行 J
sudo sshfs -o nonempty,allow_other,exec yanzhiwei@aliyun/ /mnt/tecmint #远程挂载当前

find ~ ( -type f -not -perms 0600 ) -or ( -type d -not -perms 0700 )
find ~ -type f -name "*.JPG" -size +1M | wc -l
find ~ -type f -name 'foo*' -ok  ls -l '{}' ';'
"-exec"选项的作用是把 find 命令的结果放入"{}"中，再由命令 2 直接处理。
区别在于："-exec"的命令会直接处理；"-ok"的命令 2 在处理前会先询问
find ~ -iname "*.jpg" -print0 | xargs --null ls -l 
#find 命令的输出被管道到 xargs 命令,之后,xargs 会为 ls 命令构建参数列表
#xargs: 参数行过长  可用	print0
cat -A foo.txt
cat >> foo.txt
cat -ns foo.txt
 sort -t: -k 3n /etc/passwd
 ls -lh | sort -h -k 5
sort -t: -k1,1  /etc/passwd #以冒号隔开的第一个字段：用户名称进行排序
sort -t: -k4n,-k3n  /etc/passwd #以冒号隔开，先以第四段进行排序，然后以第三段进行排序
ls -l /usr/bin | sort -nr -k5 | head
sort foo.txt | uniq -cd
cut -d ':' -f 1 /etc/passwd | head
cut -f 3 distros.txt | cut -c 7-10
tr -d '\r' < dos_file > unix_file
tr a-zA-Z n-za-mN-ZA-M
```



# 24. end

![单词接龙.jpg](/Image/C1.Algorithm-photo/56202fa47f46b90f9de8a1ddae7826b76140eefb664ec29d598b0775764ef2c0-单词接龙.jpg)



qq347233593.

18632790270
