---
id : B1.算法设计
title : B1.算法设计
typora-root-url : ../
---



#  算法设计



# 算法

**算法**:对付一定规范的输入,能在有限时间内获得要求的输出


- 算法步骤无必须歧义
- 必须认真确定输入的值域
- 同一算法可有多种形式描述
- 同一问题,可能由多种算法
- 同一问题的算法可能基于完全不同的解题思路



算法设计(策略)要不懈努力,反复修正



#### 算法的分类

1. 按求解问题的类型分组
2. 按算法内在的设计技术分组

精确算法:

近似算法:平方根,解非线性方程,求定积分



#### 算法的表示

1. 流程图
2. 伪代码
   - for while if
   - <- 赋值
   - // 注释

3. code



# 算法效率分析



#### 算法效率

1. 时间复杂度:用输入规模的函数来度量
2. 空间复杂度:额外空间
3. 同等规模的输入,运行时间差距很大
   - 最差效率
   - 平均效率
   - 最有效率
4. 增长次数:当$输入规模 \to \infin$,算法运行时间表现出固定的增长次数

| 类型      | 名称     | 注释                                                         |
| --------- | -------- | ------------------------------------------------------------ |
| $1$       | 常量     |                                                              |
| $log(n)$  | 对数     | 每一次循环消去问题规模的一个常熟因子<br />一定不可能关注输入的每一个部分<br />eg:二分查找 |
| $n$       | 线性     | 单次循环扫描:顺序查找                                        |
| $nlog(n)$ | 线性对数 | 分支:合并排序,快速排序                                       |
| $n^2$     | 平方     |                                                              |
| $2^n$     | 指数     |                                                              |
| $n!$      | 阶乘     | 完全排列                                                     |



#### 伪随机数

1. 线性同余法



# 算法方法论

## 暴力法(brute force)

大整数计算$a^n \ mod \ m = \underbrace { a \times a \cdots \times a} _n \ mod\  m$

#### 选择排序

$$
\begin{aligned}
A_0 \le A_1 \le \cdots \le A_{i-1} &| A_i,\dots,A_{min},A_{n-1}\\
已经排好序&|交换A_{min}与A_i\\
C(n) = \sum_{i = 0}^{n - 2} \sum_{j = i+1}^{n - 1} &= \frac{(n-1)n}{2}
\end{aligned}
$$

#### 冒泡排序

$$
\begin{aligned}
A_0,\dots,A_j,\bigvee ,A_{j+1},\cdots,A_{n- i +1}&| A_{n - i} \le \cdots \le A_{n-1} \\
如果A_j与A_{j+1}逆序就交换&|已经排好序\\
C(n) = \sum_{i = 0}^{n - 2} \sum_{j = 0}^{n- 2- i} &= \frac{(n-1)n}{2}
\end{aligned}
$$



#### 顺序查找+暴力字符串匹配



### 减治法(decrease-conquer)

或称为增量法(increment approach)

3种变化形式

1. 减去一个常量:每次迭代减1
2. 减去一个常量因子:每次迭代减半
3. 减去的规模是可变的:$gcd(m,n)=gcd(n, m \ mod \ n)$

#### 插入排序

$$
\begin{aligned}
A_0 \le \cdots \le A_j \ |& \lt A_{j+1}\le \cdots \le A[i]\cdots A_{n-1}\\
小于等于A_i\ |&\ 大于A_i
\end{aligned}
$$



#### ==希尔排序==



#### 拓扑排序

在有向图中:是否可以按照某种次序列出顶点,使得任意一条边的起点在终点之前

$有向图没有回路=拓扑排序有解$

求解拓扑排序

1. 深搜
2. 减常量:不断在剩余有向图中求解一个入度为0的源(source)



#### 生成组合对象

##### 生成排列

对n个元素的集合$\{a_1,\cdots,a_n\}$的下标,生成$\{1,\cdots,n\}$所有$n!$排列的问题

减一法:生成所有$(n-1)!$的排列,将n插入到n-1个元素的所有排列中








# 算法问题



### 最大公约数

#### 欧几里得算法

$$
gcd(m, n) = gcd(n, m \ mod \ n)
$$

拓展欧几里得:$gcd(m, n) = d \to mx + ny = d$

带锁的门:因数个数的奇偶性





### 排序问题

1. 稳定性:保证两个键值相同的元素,维持相对顺序
2. 额外存储空间



### 查找问题

1. 顺序查找
2. 二分查找->应用受限
3. 将原集合用另一种形式表示->大型数据库的存取



### 字符串处理问题

1. 字符串匹配



### 图问题

图:若干相连的节点构成的集合

1. 遍历算法:一次访问所有节点
2. 最短路径算法:另个节点见得最短路径
3. 有向图的拓扑排序



1. 旅行商问题:找出访问n个城市的最短路径,并保证每个城市只访问一次
2. 图填色问题:最少种类的颜色为图的顶点填色,并保证以边相连的两个顶点颜色不同



### 组合问题

1. 随问题规模的增大,组合对象的数量增长极快
2. 绝大多数问题没有一种可接受时间的算法



### 几何问题

处理点,线,多面体等几何对象



1. 最近对问题:给定平面上n个点中,求最近的两个点
2. 凸包问题:求一个能把给定集合中所有点包含在内的最小凸多边形



### 数值问题

1. 具有连续性的数学问题:解方程和方程组,计算定积分,求函数的值,
   - 一方面:问题本身只能近似求解
   - 另一方面:计算机对浮点数只能近似表示





# 数据结构

### 最重要的DataStructure

1. 数组:用于实现字符串,二进制串
2. 链表:节点(头结点)+指针,双链表

用来封装更抽象的ADT

### 线性数据结构

1. 栈
2. 队列
3. 优先队列:有序数组,堆来实现

### 图

图:若干相连的节点构成的集合 

#### 基础定义

$$
\begin{aligned}
&G =<V,E>\\
&有限集合V:顶点(vertex); \\
&有限集合E:边(edge);\\
&顶点对(u,v):u与v为边(u,v)的端点(endpoint);u和v相互邻接(adjacent)\\
&有向边:顶点对(u,v)不等同于(v,u); u \to v : u为尾,v尾头\\
&有向图(digraph):所有边有向\\
&无向图(undirected \ graph):所有边无向\\
&完全图(complete):任意两个顶点相连,K_{|V|}, |E| = \frac {|V| \times (|V| - 1)}{2}\\
&稠密图(dense):\\
&稀疏图(sparse):
&边的权重或成本:有向边的值
\end{aligned}
$$

#### 图的表示

1. 邻接矩阵(adjacent matrix)
   $$
   Edge =
   \begin{matrix}
   \quad  & a & b & c & d\\
   a & 0  & 1 & 0 & 1\\
   b & 1 & 0 &  0 & 0\\
   c & 0 & 0 &  0 & 1\\
   d & 1 & 0 & 1 & 0\\
   \end{matrix}
   $$

2. 邻接表(list)
   $$
   \begin{aligned}
   &[a] \to  b \to d\\
   &[b] \to a\\
   &[c  \to d\\
   &[d] \to a \to c
   \end{aligned}
   $$

#### 路径和环

**序列**:图G中,始于u,止于v的邻接

**简单路径**:路径上所有顶点不同

**连通**:图G中任意一对(u,v)都有从u到v的路径

**连通分量**:非连通图中,极大连通子图



### 树

#### 基础知识

**树**:连通无回路图

**祖先**:从根(root)到v的简单路径上的所有顶点为v的祖先

**深度**:从根到v的简单路径的长度

**树的高度**:从根到叶节点的最长简单路径的长度,最大深度



### 集合与字典

**集合**(set):互不相同项的无序组合

