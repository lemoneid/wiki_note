---
id : B99.专题
title : B99.专题
typora-root-url : ../
---

# 专题

# 回文

## [回文串个数](https://leetcode-cn.com/problems/palindromic-substrings/description/)

直接递归。

```cpp
#include <string>
#include <vector>

class Solution {
public:
    int countSubstrings(std::string str) {
      
      int count=0;
      for(int i=0; i < str.size(); ++i) { 
        __count(str, i, i, count);
        __count(str, i, i+1, count);
      }
      return count;
    }
  private:
    void __count(const std::string& str, int begin, int end, int& count) { 
      while(begin >=0 && end <= str.size() && str[begin] == str[end])
      {
        ++count;
        --begin;
        ++end;
      }
    }
};
```

## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)

### 暴力算法

暴力算法即以每个字符为中心中，看每个字符的能外扩的最长回文字串的长度，时间复杂度为 `O(n^2)`。但是需要加入额外的字符处理 `#` ，否则无法同时应对奇回文和偶回文。

```
  原始串：0 1 2 1 3 1 2 1 0 

  下标 ： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
  填充后：# 0 # 1 # 2 # 1 # 3  # 1  #  2  #  1  #  0  # 
```

填充算法可如下完成：

```cpp
  void __preProcess(std::string& str) { 
      int length = str.size();

      std::string padding((length<<1) +1, '#');
      
      for(int i=0;  i<length; ++i) { 
          padding[(i<<1) +1]   = str[i];
      }

      str.swap(padding);
  }
```

### 马拉车算法

马拉车算法，是通过 `O(n)` 的辅助空间，获取 `O(n)` 的时间复杂度。马拉车算法是在上述暴力算法上的一点改进，有几个基本概念：

+ 回文半径`r`：表征以每个字符 `i` 为中心的扩充范围 `[i-r, i+r]`。
+ 回文右边界：`R =i+r`
+ 回文右边界最早中心`C`：即到达右边界`R`最早的`C=i`。

需要用法一个数组`radius`记录每个位置 `i` 的回文半径，因此每个位置 `i` 对应的回文右边界 `R = i + radius[i]`。

#### 分析

在当前位置 `i` 之前已经存储了一部分 `radius` 信息了。在当前位置 `i`：

+ 当前字符 `i` 不在当前最大回文右边界 `R` 内，即使 `R < i` 时，和暴力方法一样暴力扩充，获得 `i`的回文半径。

  ```cpp
      while(0 <= i - radius[i] && i + radius[i] < str.size()) { 
        if(str[i + radius[i]] != str[i - radius[i]]) 
            break;
        ++radius[i];
      }
  ```

+ 在回文右边界内 `i <=R`。设`i`关于`C`的对称点为`i'`，`R`关于`C`的对称点为 `L`。根据`i'`的回文半径大小 `radius[i']` 可以情况细分为3种，：

  + `L < i-radius[i']'`时，可以直接确定`i`的回文半径 `radius[i]`

    因为`[L,R]`区间都是回文串，而以`i'`为中心的回文字串`[i'-radius[i'], radius[i'] + i']`也在`[L, R]`范围内，因为 `i` 的回文半径也是`radius[i']`。

    ```
      下标 : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
      字串 : # 0 # 1 # 2 # 0 # 3  # 0  #  2  #  1  #  1  # 
                 ^ ^   ^   ^   ^    ^     ^     ^  ^
                 L a   i'  b   C    b'    i     a' R
    ```

    比如上图，`a, b`分别是`i'`回文半径范围外前后一个位置，`a', b'`是关于`C`的对称位置。`a!=b`，所以`a'!=b'`，因此`i`所能扩的最大范围也是`[a'+1, b'-1]`，由于对称性可知，这和 `i` 的回文区域 `[a+1, b-1]`长度是一样的。

    因此，这种情况下，`i` 的回文半径 `radius[i] = radius[i']`。在 `O(1)` 时间内就可以确定。

  + `L > i-radius[i']`，也能直接确定`i`的回文半径 `RADIUS[i]`

    ```
      下标 : 0 1 2 3 4 5 6 7 8 9 10  11 12 13 14  15 16 17 18
      字串 : # 0 # 1 # 2 # 1 # 3  #  1  #  2  #   4  #  0  # 
                   ^ ^ ^   ^   ^     ^     ^  ^   ^
                   a L i'  b   C     b'    i  R   a'
    ```

    设`R+1`的位置为 `a'` ，`L-1` 的位置为 `a`，可知道 `a`和 `a'`关于 `C`对称。`a`关于`i'`的对称位置是`b`，`b`关于`C`的对称点是`b'`。因此`b'`和`a'`关于`R`对称。

    因为当前最大回文区间是 `[L, R]`，也就是说 `a != a'`，而 `a`和`b`同在`i'`的回文区间里：`[a, b] < [i'-radius[i'] , i' + radius[i']]`。因此 `a == b`，又因`b == b'`，因此`a = b'`。又由`a != a'`，可得` b' != a'`。也因此 `i`的回文区间`[b'+1, a'-1]`。`radius[i] = R-i`。此时，`i`的回文右边界就是`R`。

    **前面两种直接确定的，就看 `L`到`i`的距离和 `radius[i]'`谁更小，更小的就是作为 `i` 的回文半径**。 因此：

    ```cpp
       radius[i] =  R > i ? std::min(radius[2*C - i], R -i) : 1; 
    ```

  + `L = i-radius[i']`时，`radius[i]` 不能直接确定，还是需要从 `R`的右边向外扩。

    ```
      下标 : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
      字串 : # 0 # 1 # 2 # 1 # 2  # 1  #  2  #  1  #  0  # 
                 ^ ^   ^   ^ ^ ^
                 L i'  C   i R a'
                       b'
    ```

    如图，上面`i'=1`，它的回文半径时1，左边刚好落在了`L`。此时是不能直接确定的。因为此时不能直接判断`a'==b'?`，仍然需要继续扩，来判断。

#### 代码实现

实现上，有几个注意点：

+ 加入填充后，以字符为中心所得的回文半径`radius[i]`及最大回文半径总是比实际的大1

  ```
    原串：c b b d 
    填充：# c # b # b # d #
            ^   ^ ^ ^   ^
            2   2 3 2   2
  ```

+ 怎么根据`(i, radius[i])`计算得到源字符串中的起始位置?

  + 在填充字符串中的起始位置 ***`pos = i - [radius[i]-1]`***  
  + 在源字符串中的起始位置 ***`start = pos/2`***  

完整代码如下：

  ```cpp
  class Solution {
  public:
      string longestPalindrome(string s) {
        if(s.empty()) return s; 

        std::string str = __preProcess(s); // 上面的代码
        int* radius = new int[str.size()]; 

        int C = -1, R = -1;
        int maxLen = 0, maxPos =0;       

        for(int i=0; i < str.size(); ++i) {  

            radius[i] =  R > i ? std::min(radius[2*C - i], R -i) : 1;  
        
            while(0 <= i - radius[i] && i + radius[i] < str.size()) { 
                if(str[i + radius[i]] != str[i - radius[i]]) 
                    break;
                ++radius[i];
            }

            if(i + radius[i] > R) { 
                R = i + radius[i];
                C = i;
            }

            if(maxLen < radius[i]) { 
                maxLen = radius[i];
                maxPos = (i - (maxLen-1))>>1;
            }
        }

        delete[] radius;
        return s.substr(maxPos, maxLen-1);
    }
  };
  ```

## [最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

使用`KMP`方法进行求解。

因为求的是以首字符开始的最大回文串，那么将该字符串逆序后拼接在一起，用`KMP`求一个`next`表，那么`next`的最后一个值就是以首字符的开始的最大回文串。然后就后面的反转贴到首字符前面皆可。

```cpp
class Solution {
public:
  std::string shortestPalindrome(std::string str) {

    std::string reverStr = str;
    std::reverse(reverStr.begin(), reverStr.end());

    std::string newStr(str + '#' + reverStr);
    int M =newStr.size();
    std::vector<int> next(M, -1);

    for(int t=-1, j=0; j <M-1;) { 
      if(t <0 || newStr[t] == newStr[j]) 
      { 
        ++t;
        ++j;
        next[j] = t;
      }
      else 
      {
        t =next[t];
      }
    } // for
    return  reverStr.substr(0, str.size()-next.back()-1) + str;
  }
};
```

## 最长回文子序列

```
题目：给定一个字符串str1，求最长的回文子序列
```

#### 间接求 

求出`str1`的逆序`str2`。那么问题就转换为求`str1`和`str2`的最长公共子序列。


#### 直接求

定义状态`dp[i][j]` 表示`i ~ j`区间的最长回文子序列。 最终的目标是求`0 ~ str.length`得最长回文子序列，即在表格的右上方。

+ `dp[0][0]`表示`0~0`的最长子序列，因此`dp[0][0] =1`。同理，第一条对角线上的都满足`dp[i][i]=1`。第二条对角线也能不依赖就填充，因此此时只有两个字符，相等就是1，不等就是0，下面表格中标记为`a'`

  ```
      0   1   2   3   
     ———————————————
   0| 1   a'     target  
   1|     1   a'            
   2|         1   a'
   3|             1
  ```

+ 而在对角线下方的点都用不到，因为在下方`i < j`，都是0.

+ 在普通位置`dp[i][j]`的依赖关系：

  + `str[i] != str[j]`，那么可能：
    + `dp[i][j] = dp[i+1][j]`
    + `dp[i][j] = dp[i][j-1]`
  + `str[i] == str[j]`，那么`dp[i][j] = dp[i+1][j-1] +2`

  ```
        0   1   2   3   
      ———————————————
    0|     
    1|         b   a         
    2|         c   d
    3|             
  
    dp[i][j]=a依赖的是 dp[i+1][j-1]的c，dp[i+1][j]的d和dp[i][j-1]的b。
  ```

  `dp[i][j]`在三者中取最大。

递推方程出来后，最终目标是右上方因此要从对角线上：**从左到右边，从下到上**依次递推。

```cpp
  class Solution {
  public:
      int longestPalindromeSubseq(std::string str) {
          if(str.empty()) return 0;

          int length = str.size();
          int dp[length ][length];  // 最终目标是 dp[0][length-1]
          ::memset(dp, 0, sizeof(dp));

          for(int i=0; i < length; ++i) { 
              dp[i][i] = 1;
          }

         for(int i=1, j=2; j < length; ++j, ++i) { 
            dp[i][j] = str[i] == str[j] ? 2 : 0;
         }
      
         for(int i =length-2; i>=0; --i) { 
            for(int j =i+1; j < length; ++j) { 
                if(str[i] == str[j]) 
                    dp[i][j] = dp[i+1][j-1] + 2; 
                else 
                    dp[i][j] = std::max(dp[i][j-1], dp[i+1][j]);
            }
         }

         return dp[0][length-1];
      }
  };
```

## [统计回文子序列个数](https://leetcode-cn.com/problems/count-different-palindromic-subsequences/description/)

详细可见代码。
子序列问题，定义状态：`dp[i][j]`表示`str[i...j]`的回文子序列个数，那么如何递推？ 

+ `str[i]==str[j]`：那么就查看`dp[i+1][j-1]`的信息。但是这个子序列问题比较复杂

  如果`str[i+1, j-1]`也存在`str[i]`那么肯定会增加子序列个数·

  + `"aba"`类型：即中间没有`str[i]`，此处即没有`a`。那么 `dp[i][j] = dp[i+1][j-1]*2 + 2`。2表示 "a " 和"aa"两种情况
  + `abaca`类型：即中间存在一个`str[i]`，那么此时 `dp[i][j] = dp[i+1][j-1]*2 + 1;`
  + `abacada`类型，即存在多个，`dp[i][j] = dp[i+1][j-1]*2  - dp[left+1][right-1]`; `left` 和 `right`是内部`a`的左右边界

+ `str[i]!=str[j]`，那么就简单多，`dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]`。减去一部分是因为计算重复。

```cpp
class Solution {
public:
    int countPalindromicSubsequences(std::string S) {
      int N   = S.size();
      int Mod = 1e9+7; 
      // dp[i][j]:i 到 j的回文子序列个数
      std::vector<std::vector<int>> dp(N, std::vector<int>(N));

      for(int i=0; i <N; ++i) { 
        dp[i][i] = 1;  
      }

      for(int i=N-2; i >=0; --i) { 
        for(int j=i+1; j < N; ++j) { 
          
          /// @brief:
          //  如果str[i] ==str[j]，那么就需要查询 dp[i+1][j-1]的信息，但是因为题目是回文子序列，如果在str[i..j]中还存在
          /// str[i]，那么势必会增加回文子序列个数，因此需要如下判断
          if(S[i] ==S[j]) {
            int left=i+1, right = j-1;
            while(left <= right && S[i] != S[left]) ++left;
            while(left <= right && S[i] != S[right]) --right;
            /// @biref:
            /// 为什么下面的求值中都x2了?
            /// 比如说 "abca"，内部的"bc"会回文子序列 "b","c"，。内部又是可以和外面的"a"再组合："aba","aca"，因此需要x2
            if(left > right) 
            { 
              dp[i][j] = dp[i+1][j-1]*2 + 2;
            }
            else if(left ==right) 
            { 
              dp[i][j] = dp[i+1][j-1]*2 + 1;
            }
            else 
            {
              // abacada
              // 内部的 aca 已经包含了 a aa 的情况不需要再单独加上
              // 因为这个部分被计算了两次，因此减去
              dp[i][j] = dp[i+1][j-1]*2  - dp[left+1][right-1];
            }
          }
          else 
          {
            dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1];          
          }

          dp[i][j] = dp[i][j] < 0 ? dp[i][j] +Mod : dp[i][j] %Mod;
        }
      }

      return dp[0][N-1];
    }
};
```

## [分割回文串I](https://leetcode-cn.com/problems/palindrome-partitioning/) 

[内容来自题解](https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/)

以 basecase 为例子，画出递归树。 

![递归树](/Image/B99.专题-photo/分割回文串_递归树.png) 

思考如何根据这棵递归树编码：

+ 每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；
+ 产生前缀字符串的时候，判断前缀字符串是否是回文。(这一步需要可以预处理，来加速判断)
  + 如果前缀字符串是回文，则可以产生分支和结点；从当前位置下一个进入递归。
  + 如果前缀字符串不是回文，则不产生分支和结点， **这一步是剪枝操作**。
+ 在叶子结点是空字符串的时候结算，此时从根结点到叶子结点的路径，就是结果集里的一个结果。使用深度优先遍历，记录下所有可能的结果。

### 预处理

如果直接判断一个字串是否是回文串，每次检测一个前缀都要消耗`O(n)`时间复杂度。**当发现某个技巧特别频繁的时候，能不能用一个矩阵或者数组来代替它**。将每段回文字串都存储在一个表格中，可以直接在`O(1)`时间复杂度内查询。设置一个预处理矩阵 ***`table[i][j]`*** ，表示 `i~j`是否是回文。

### [代码参考来源](https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/)

```cpp
class Solution {
public: 
    typedef  std::vector<std::vector<std::string>> vectorStringSet;

    vectorStringSet partition(std::string str) {

        if(str.empty()) return resultSet_;

        int length = str.length(); 
        
        std::vector<std::vector<bool>> table(length, std::vector<bool>(length, false));

        for(int i=0; i < length; ++i) { 
            __prePocess(str, i, i,   table);
            __prePocess(str, i, i+1, table);
        }

        __partition(str, 0, std::vector<std::string>{ }, table);

        return resultSet_;
    }

private:
    void __prePocess(std::string& str, int left, int right, std::vector<std::vector<bool>>& table) { 

        while( 0<= left && right < str.length() && str[left] == str[right]) { 
            table[left][right] = true;
            --left;
            ++right;
        }
    }

    template<typename vectorString>
    void __partition(std::string& str, int index, vectorString&& path ,std::vector<std::vector<bool>>& table) { 
        if(index == str.length()) { 
            resultSet_.push_back(path);
            return;
        }

        for(int i=index; i < str.length(); ++i) { 
            if(!table[index][i]) continue;
            
            path.emplace_back(std::move(str.substr(index, i-index+1)));
            // 这里进入下一层的是下个位置
            __partition(str, i+1, path, table);

            path.pop_back(); // 回溯
        }
    }

    vectorStringSet resultSet_;
};
```

## [分割回文串II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/description/)

```
给定一个字符串str，返回把str全部切成回文子串的最小分割数。

举例：
str="ABA"。不需要切割，str本身就是回文串，所以返回0。
str="ACDCDCDAD"。最少需要切2次变成3个回文子串，比如"A"、"CDCDC"和"DAD"，所以返回2。
```

### 定义状态

`dp[i]` 表示字符串`i`位置以后要切的刀数。 

如果一个字符串前缀就是一个回文字符串，那么就切一刀让这个前缀作为一个整体，然后去查看后缀能切几刀。

```
字符串： aba3aba...

1) a       ...   以a作为第一个部分，后面剩余部分切X刀，总共是 X+1刀
2) aba     ...   以aba作为第一个部分，后面剩余部分切Y刀， 总共是 b' +1刀
3) aba3aba ...   以aba3aba作为第一个部分，后面剩余部分切Z刀，总共是 Z+1刀
...

然后，取可能性中最小值。
```

这个算法是`O(n^2)`时间复杂度。因为每次一个前缀要逐次的尝试以每个字符开始的最长前缀位置。

```
序列：aaaaaa

1) a     ...
2) a a   ...
3) a a a ...
```

为了一次性质定位 `i`开始的前缀中的最长回文。采用和上一道题一样的思想，建立一个`table[i][j]`，表示以`i`开始的最长回文前缀区间是 `[i,j]`。就直接在`O(1)`时间复杂度内查询以 `i` 开始的最长回文前缀位置。

+ **对角线都是回文**
+ **次对角线根据两个字符是否相等就可以直接判断**
+ `table[i][j]`是否是回文：`str[i]==str[j] & table[i+1][j-1]`。当前位置只是依赖左下角的元素。

```
字符串： aba3aba...

aba3aba |  ...   
        ^ 
        第一刀就直接切在这，而不是在a处
```

通过预处理表格加速整个过程，使得变为`O(n)`。

### 代码实现

```cpp
class Solution {
public:
    int minCut(std::string str) {
        if(str.empty()) return 0; 

        int length = str.length(); 

        std::vector<int> dp(length+1, INT_MAX); // dp[i] 表示 i~end 最少切几刀 
        dp[length] = -1;
        
        std::vector<std::vector<bool>> table(length, std::vector(length, false)); 

        for(int i=length-1; i>=0; --i) {
            for(int j=i; j < length; ++j) {
                // dp[i, j] 是回文，才计算
                if(str[i] == str[j] && ( j -i < 2 || table[i + 1][j - 1])) { 
                    table[i][j] = true;
                    dp[i] = std::min(dp[i], 1+dp[j+1]); 
                }
            }
        }

        return dp[0];
    }
};
```
# topK
`topK`没有第0大，都是第一大或者第一小开始。 第一小/大就是对应有序数组的`arr[0]/arr[N-1]`。

## [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
#### 基于快排的方法
先将数组排序，再取出前k个数。这个方法是就地执行，会改变数组本身。

注意：选择第K小的元素，使用快排的选择算法，而这道题是求取最小的k个数，需要先对他们进行排序。
```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if(arr.empty() || k<=0 || arr.size() < k) 
            return resultSet_;
         
        for(int lo=0, hi=arr.size()-1;lo < hi;) {  
            int L=lo, R=hi;
            int pivot = arr[lo];

            while(L < R) { 
                while(L < R && pivot <= arr[R]) --R; arr[L] = arr[R]; //将大于轴点数子换到左侧
                while(L < R && arr[L]<= pivot)  ++L; arr[R] = arr[L];
            } //L == R
            // 每次经过一轮循环，pivot左侧的元素都不大于它，右侧的元素都不小于它
            arr[L] = pivot;
            
            if(L <= k) lo = L+1; // 进入右侧
            if(L >= k) hi = L-1; // 进入左侧
        } // lo == hi 时 lo <=k<=hi，因此 lo == hi==k

        while(k) 
        { 
            --k;
            resultSet_.push_back(arr[k]);
        }

        return resultSet_;
    }

private:
    std::vector<int> resultSet_;
};
```
#### 基于最大堆的方法 
维持一个大小为`k`的大顶堆，使得堆顶元素最大。元素个数不足`k`就直接放入堆中，超过k个元素，和堆顶元素进行比较，小于堆顶就弹堆顶，放入当前元素。 

时间复杂度是`O(n*logk)`，空间复杂度是`O(k)`。

这个优点在于：不用一次性的将全部数据加载进入内存，适合海量数据。
```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if(arr.empty() || k<=0 || arr.size() < k) return std::vector<int>{ };
        std::vector<int> resultSet_(k);
        std::priority_queue<int> big_;  // 优先级队列
        
        for(int& num : arr) { 
            if(big_.size() < k) { 
                big_.push(num);
            }
            else { 
            // 满了 
            // 将大的元素取出来，将小的元素压入
                if(big_.top() > num) { 
                    big_.pop();
                    big_.push(num);
                }
            }
        }
        
        while(k) { 
            resultSet_[k-1] =big_.top();
            big_.pop();
            
            --k;
        }
            
        return resultSet_;
    }
};

```
上面这两种解法各有优缺点， 各自适用于不同的场合， 因此应聘者仵动手做题之前要先问消楚题目的要求， 包括输入的数据揽有多大、能否－次性载入内存、是否允许交换输入数据中数字的顺序等

## [两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
```题目
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。 
```
### `topK`
利用求`topK`问题的思路。假设有数据：
```
A: 1, 3, 4, 9
B: 1, 2, 3, 4, 5, 6, 7, 8
k = 7 
```
`A`的中位数是`k/2=3`。表示的是第3个，即下标为`2 = k/2-1`。`A[2] > B[2]`，因此`B[2]`前面面的元素不可能是中位数，比如`B[1]`最多也只是第4大。
而`A`中都是有可能的。比如`A[0]`只要比`B[5]`大，那么就是第7大，`A[0]`只要比`B[2]`大，那么`A[3]`就是第7大。下一次比较：
```
A: 1, 3, 4, 9
B: 4, 5, 6, 7, 8
```
> 引理
>
>一般地， 两个有序数组 **`A[0], A[1], A[2] ... A[k/2-1], A[k/2] ... A[n]`** 和 **`B[0], B[1], B[2] ... B[k/2-1], B[k/2]...B[m]`** 。如果 *`A[k/2-1] < B[k/2-1]`* ，那么  *`A[0], A[1], A[2] ... A[k/2-1]`* 都不可能是第 *`k`* 小的数字。  
>
>`A` 数组中比 `A[k/2-1]` 小的数有 `k/2-1`个。B数组中，`B[k/2-1]`前面有`k/2-1`。在最好的情况下`B[k/2-1]`前面最大的一个元素`B[k/2-2] < A[0]`，那么此时`A[k/2-1]`也只是第`k/2-1 + k/2`小，即最好的情况下，`A[k/2-1]`也是只是第`k-1`小。因此 `A[k/2-1]` 前面的元素都不可能满足条件。

因此，根据这个结论，可以在每次从两个有序数组中选出中位数，且比较出大小后，**较小的中位数及其所在数组前面的部分都可以抛弃**（减而治之）。比如，上面`A[0] ~ A[k/2-1]`都可以抛弃。直接从`A[k/2]`再次寻找。此时`k`将会减少`k/2`，即从剩余的数组中查找 ***`k = k - k/2`*** 小的元素。

+ `A[k/2-1] = B[k/2-1]`时，就可以直接返回了，此时两个数就是原问题的第K小的数。
+ 某个数组到头了。比如`A`序列到达`A[n]`，而`B`还没到达`B[n]`。

  如果`A[n] < B[k/2-1]`，那么根据上面的结论，`A[n]`及其前面可以全部抛弃，`A`剩余长度就是0。然后 ***`k = k - k/2`*** 那么最终的结果肯定就是在`B`中，此时可以直接访问得到`B`得到。 
  如果`A[n] > B[k/2-1]`，自然抛弃`B[k/2]`前面的所有元素。下次对比时:
  ```
    A: A[n]
    B: B[k/2], ..., B[m]
  ```
  注意：每次`k`在抛弃一段之后都是会减少一半的。
#### 根据topK求中位数
有了求 *`topK`* 的算法。可以利用 *`topk`* 来求解中位数，第`k`小的元素对应的下标是`k-1`：
+ 当两个数组长度和是奇数时， `k = length /2 + 1 =(2 * n + 1) /2 + 1 = n + 1`。
+ 当两个数组长度和是偶数时， k 是上中位数和下中位数和的平均数:   
    上中位数：`left  = length /2    = n`  
    下中位数：`right = length /2 +1 = n +1;` 

  为统一这两个写法:  
    + `left  = (length +1) / 2`  
    + `right = (length +2) / 2`
#### 代码实现 
```cpp 
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

        int n = nums1.size(); 
        int m = nums2.size(); 

        int length = n + m;
        int left  = (length +1) /2;
        int right = (length +2) /2;   

      return  static_cast<double>(__getTopK(nums1, 0, n, nums2, 0, m, left) + 
                                  __getTopK(nums1, 0, n, nums2, 0, m, right)) /2;
    }

    int __getTopK(std::vector<int>& nums1, int s1, int e1, 
                  std::vector<int>& nums2, int s2, int e2, 
                  int k) 
    { 
      int len1 = e1 - s1, len2 = e2- s2;

      if(len1 ==0) { return nums2[s2 +k-1]; }
      if(len2 ==0) { return nums1[s1 +k-1]; }

      if(k==1) return std::min(nums1[s1], nums2[s2]);

      // 求取此时的中点索引
      // 有可能 s1 + k/2直接越界了，因此要么到达 nums1 的中点，要么到达 nums1 的终点
      int i = s1 + std::min(len1, k/2)-1; 
      int j = s2 + std::min(len2, k/2)-1;
      
      int result = 0;
      
      if(nums1[i] < nums2[j]) 
      { 
        // 要抛弃的长度就是 [s1, i]， 因此 k - (i+1 -s1)
        result =__getTopK(nums1, i+1, e1, nums2, s2, e2, k - (i+1 - s1)); 
      }
      else 
      {
        result = __getTopK(nums1, s1, e1, nums2, j+1, e2, k-(j+1 - s2));
      }

      return result;
    }
};
```

## [无序数据流的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
```
题目描述：

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
```
#### 分析

整个数据可以看作被中位数分为两部分：左边的不大于中位数，右边的不小于中位数。用一个数据结构保存中位数两边的数据，**使得左边的数据都小于右边的数据**。

大顶堆和小顶堆：因为大顶堆头部最大，尾部最小，因为可以让小于中位数的存在大顶堆，反之大于中位数的位于小顶堆。使得数据流中的数据均匀分布在两个堆中。

问题是怎么分布均匀，两队数据个数之差不超过1？ 让数据流中的数，先进入大顶堆，然后将大顶堆首部的元素移到小顶堆，就能使得左边的永远不大于右边的。如果导致小顶堆元素个数多于大顶堆，就从小顶堆顶取出一个给大顶堆，仍保持总体的有序性。
+ 如果总数个数是奇数，大顶堆个数是m，那么小顶堆个数是m-1。大顶堆顶即中位数。
+ 如果总数个数是偶数，大顶堆个数是m，那么小顶堆个数是m。两堆顶和的平均数就是中位数。

#### 代码实现 
```cpp
class MedianFinder {
public:    
    void addNum(int num) {
        //每次都先加入大顶堆
        big.push(num);

        small.push(big.top());
        big.pop();

        if(big.size() < small.size()) {  
            big.push(small.top());
            small.pop();
        }
    }
    
    double findMedian() {
        return big.size() > small.size() ? 
                    static_cast<double>(big.top()) :
                    static_cast<double>(big.top() + small.top()) /2 ;
    }
private:
    std::priority_queue<int> big;
    std::priority_queue<int, std::vector<int>, std::greater<int>> small;
};
```


## [前k个高频数](https://leetcode-cn.com/problems/top-k-frequent-words/submissions/)
还是利用堆实现：达到 `O(n*log(k))` 的时间复杂度，并在空间复杂度为`O(n)`，因为还有个map使用了空间。

比较无语的是比较器：先比较频率，频率相同时，字符小的优先级别高。
```cpp
class Solution {
public:
    typedef std::vector<std::string> vectorStr;

    vectorStr topKFrequent(vectorStr& words, int k) {
        if(words.empty() || k<=0) return resultSet_; 
       
        for(const auto& word : words) ++map_[word];

        for(const auto& entry: map_) { 
            if(heap_.size() < k) 
            { 
              heap_.push({entry.second, entry.first});
            }
            else 
            {   
              if(entry.second < heap_.top().first || 
                (entry.second == heap_.top().first && entry.first > heap_.top().second)) 
                continue;

              heap_.pop();
              heap_.push({entry.second, entry.first});
            }
        }

        resultSet_.resize(k);
        while(k--) 
        { 
            resultSet_[k] = heap_.top().second;
            heap_.pop();
        }
        return resultSet_;
    }
private:
    struct Comparator { 
      bool operator()(const std::pair<int, std::string>& lhs, 
                      const std::pair<int, std::string>& rhs) const
      { 
        return lhs.first == rhs.first ? 
               lhs.second < rhs.second:   // 频率一致，字母顺序小的 优先级更高
               lhs.first  > rhs.first;    // 先按照频率比较
      }  
   };

    std::priority_queue<std::pair<int, std::string>,
                        std::vector<std::pair<int, std::string>>,
                        Comparator> heap_;
    std::unordered_map<std::string, int> map_;
    vectorStr resultSet_;
};
```

# 两数之和系列

+ 针对的都是有序数组，如果给定的数组是无序的，那么先排序。
+ 两数之和系类都是双指针的使用，一个指向开头，一个指向结尾。
+ 根据 `nums[L] + nums[R]` 与 `target` 的大小来判断是 `++L` 还是 `--R` 。

### [两数之和II](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

只有一对答案，因此只需要一前一后靠近。
数组已经排序这点很重要

+ `nums[L] + nums[R] < target` ：小于`target`，`++L` 来增大区间和
+ `nums[L] + nums[R] > target` ：大于`target`，`--R` 减少区间和
+ `nums[L] + nums[R] == target` ：可以直接得到结果返回

```cpp
  class Solution {
  public:
      std::vector<int> twoSum(const std::vector<int>& nums, int target) {
        int L=0, R =nums.size()-1;
        std::vector<int> result(2);

        while(L < R) { 
          
          if(nums[L] + nums[R] == target) 
          { 
            result[0] = L+1;
            result[1] = R+1;
            return result;
          }
          else if(nums[L] + nums[R] < target) 
          { 
            ++L;
          }
          else 
          {
            --R;
          }
        }

        return result;
      }
  };
```

### [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

对于`nums`中每个数，从其位置右边开始选出来两个数，使得三数之和最接近`target`。于是使用三个指针：`cur`，`L=cur+1`，`R=length-1`。需要先对数组进行排序，根据三个指针的和，来调整指针位置。

+ 如果 `sum = nums[cur] + nums[L] +nums[R] > target`，需要 `--R` 来缩小，
+ 如果 `sum = nums[cur] + nums[L] +nums[R] < target`，需要 `++L` 来扩大，
+ 如果 `sum == target` 找到答案，直接返回。

```cpp
  class Solution {
  public:
      int threeSumClosest(std::vector<int>& nums, int target) {
        std::sort(nums.begin(), nums.end());

        int64_t result = INT_MAX;

        for(int cur=0, length = nums.size(); cur < length; ++cur) { 
          for(int L =cur+1, R =length-1; L < R;) { 
            int64_t sum = nums[cur] + nums[L] + nums[R];
            if(std::abs(target - sum) < std::abs(target - result))
            {
              result = sum;
            }  

            // 更新指针
            if(sum < target) 
            {
                ++L;
            }
            else if(sum > target) 
            { 
                --R;
            }
            else 
            { 
                // sum == target
                return static_cast<int>(result);
            }
          }  // inside-for -end
        }  // outside-for -end

        return static_cast<int>(result);
      }
  };
```

这个问题的解法思想，类似于[盛水最多的容器](https://leetcode-cn.com/problems/container-with-most-water/)，或者说是一种滑动窗口的思想：移动左指针变大，移动右指针变小。

### [三数之和](https://leetcode-cn.com/problems/3sum/)

这道题和上一道几乎异曲同工。只是这道题是找出所有不重复的答案，因此在每次找到答案后需要剔除重复的元素。原理和上题一模一样。

```cpp
  class Solution {
  public:
      std::vector<std::vector<int>> threeSum(std::vector<int>& nums) {
        std::vector<std::vector<int>> result;
        if(nums.size() <3) 
          return result;

        std::sort(nums.begin(), nums.end());
        
        for(int curr =0, numsLen = nums.size(); curr < numsLen; ) { 

          for(int L=curr+1, R =numsLen-1; L <R; ) { 
            
            int sum = nums[curr] + nums[L] + nums[R];
            if(sum < 0) 
            { 
              ++L;
            }
            else if(sum >0) 
            { 
              --R;
            }
            else 
            { 
              result.emplace_back<std::vector<int>>({nums[curr], nums[L], nums[R]});
              ++L;
              while(L < R && nums[L-1] == nums[L]) ++L; // 为了剔除重复元素
              --R;
              while(L < R && nums[R] == nums[R+1]) --R; // 为了剔除重复元素
            }
          }

          ++curr;
          while(curr < numsLen && nums[curr-1] == nums[curr]) ++curr; // 为了剔除重复元素   
        }

        return result;
      }
  };
```

### [四数之和](https://leetcode-cn.com/problems/4sum/)

最直接的想法就是在 **三数之和** 外面再套一层循环。

```cpp
  class Solution {
  public:
      vector<vector<int>> fourSum(vector<int>& nums, int target) {  
        std:vector<std::vector<int>> result;
        if(nums.size() < 4) 
          return result;
        
        std::sort(nums.begin(), nums.end());

        for(int curr=0, numsLen =nums.size(); curr < numsLen; ) { 
          M_threeSum(nums, curr, target-nums[curr], result);

          ++curr;
          while(curr < numsLen && nums[curr-1] == nums[curr]) ++curr; // 为了剔除重复元素   
        }

        return result;
      }

  private:
      void M_threeSum(const std::vector<int>& nums, 
                      int start, 
                      int target, 
                      std::vector<std::vector<int>>& result) {
        
        for(int curr =start+1, numsLen = nums.size(); curr < numsLen; ) { 

          for(int L=curr+1, R =numsLen-1; L <R; ) { 
            
            int sum = nums[curr] + nums[L] + nums[R];
            if(sum < target) 
            { 
              ++L;
            }
            else if(sum > target) 
            { 
              --R;
            }
            else 
            { 
              result.emplace_back<std::vector<int>>({nums[start], 
                                                     nums[curr], 
                                                     nums[L], 
                                                     nums[R]});
              ++L;
              while(L < R && nums[L-1] == nums[L]) ++L; // 为了剔除重复元素
              --R;
              while(L < R && nums[R] == nums[R+1]) --R; // 为了剔除重复元素
            }
          }

          ++curr;
          while(curr < numsLen && nums[curr-1] == nums[curr]) ++curr; // 为了剔除重复元素   
        }
      }
  };
```

至此，两数之和系列已经全数解决，都是一个双指针模板。

# 股票问题 

`Leetcode`上买卖股票的6道题目 

## [买卖股票的最佳时机I](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
这个问题就是求当前元素`j`左侧最小的元素`i`，那么在`j`天卖出的时能获得的最大利润就是`j-i`。如果获得左侧最小的元素？
### 单调栈解法 
使得单调栈从小到大的顺序入栈，用栈底一直保持为当前元素`i`之前的最小值。当有更大的元素入栈时，弹出栈顶元素，一直弹到满足有序性，在弹出栈顶元素时，计算每个栈顶元素的最大利润，即栈顶-栈底，就是该天股票卖出时能获得的最大利润。

[代码](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/c-li-yong-shao-bing-wei-hu-yi-ge-dan-diao-zhan-tu-/) 引入了两个小技巧：
+ 这里直接使用动态数组来模拟栈，可以方便的访问栈底元素。
+ 加入哨兵，一次遍历完成。
    ```cpp
    class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            int ans = 0;
            vector<int> St;
            prices.emplace_back(-1); 
            for (int i = 0; i < prices.size(); ++ i)  {
    
                while (!St.empty() && St.back() > prices[i]) { 
                    ans = std::max(ans, St.back() - St.front()); 
                    St.pop_back();
                }
                St.emplace_back(prices[i]);
            }
    
            return ans;
        }
    };
    ```
### 动态规划 
直接用一个遍历记录下当前日期 `j` 前的最小值`i`。一边计算在 `j`天卖出，在`i`买入时获得的利润，一边更新历史最小值。一次遍历就可以完成。[代码](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/)
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int minprice = INT_MAX;
        int maxprofit = 0;

        for (const int& price: prices) {
            maxprofit = max(maxprofit, price - minprice);
            minprice = min(price, minprice);
        }

        return maxprofit;
    }
};
```

## [买卖股票的最佳时机II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
### 贪心
假设给定的股票价格：`[7, 1, 5, 3, 6, 4]` 

```
    maxProfit = peek(i)-vally(j),  0 <= i < n
```
如图，如果将股票价格画在图上，可以总利润最大值，就是个小利润之和：只要位置`i`处的价格小于`i+1`位置，那么在`i`位置买入`i+1`位置卖出，那么就可以获得利润。所有的这些小利润加起来就是大利润。这就是贪心思想。
```cpp
  class Solution {
  public:
      int maxProfit(vector<int>& prices) {
          if(prices.empty()) return 0; 
          int maxProfit_ =0; 

          for(int i=0; i < prices.size()-1; ++i) { 
              if(prices[i] < prices[i+ 1]) 
              { 
                  maxProfit_ += prices[i+1] - prices[i];
              }
          }

          return maxProfit_;
      }
  };
```
### 动态规划 
能用贪心解决的问题，一般都是可以用动态规划。
#### 定义状态 
`dp[i][j]` 
+ `i`：表示在 `i`天能获得的最大利润 
+ `j`：取值0/1，0表示持有现金（不买股票），1表示持有股票

因此，在`i`能的最大收益有两种可能：
+ `i`天持有现金：手里没有股票，只有前一天的现金，今天没有收益；或者手机有股票，今天卖出股票收益就是`prices[i]`：`dp[i][0] = std::max(dp[i-1][0], dp[i-1][1] + prices[i])`
+ `i`天持有现金：`i-1`天就有股票；或者`i`天买入股票，收益降低`prices[i]`： `dp[i][1] = std::max(dp[i-1][1], dp[i-1][0] - prices[i]`  
  
  [代码](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/):

    ```java
    public class Solution {
        public int maxProfit(int[] prices) {
            int len = prices.length;
            if (len < 2) {
                return 0;
            }
  
            // 0：持有现金
            // 1：持有股票
            // 状态转移：0 → 1 → 0 → 1 → 0 → 1 → 0
            int[][] dp = new int[len][2];
            // 初始化状态
            dp[0][0] = 0;
            dp[0][1] = -prices[0];
  
            for (int i = 1; i < len; i++) {
                // 这两行调换顺序也是可以的
                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            }
            return dp[len - 1][0];
        }
    }
    ```
    可以用滚动更新，压缩空间。

## [买卖股票的最佳时机III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
分析可直接参考[股份问题分析](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/)

在这说下代码中的basecase，就是`dp[0][k][0]`和`dp[0][k][1]`。
+ `dp[0][k][0]`：第0天手中持有现金，本质上是没有产生交易，利润是`dp[0][k][0]=0`。而交易多次`k`是不可能发生的。
+ `dp[0][k][1]`：第0天手中持有股票，即将手中现金换成了股票，因此利润减少了`-prices[0]`。
```cpp
class Solution {
public:
    int maxProfit(std::vector<int>& prices) {
        if(prices.empty()) return 0;
        
        int n = prices.size(); 
        int max_k = 2;
        int dp[n][max_k+1][2]; ::memset(dp, 0, sizeof(dp));

        for(int i=0; i < n; i++) { 
    
            for(int k=1; k <= max_k; ++k) { 
                
                if(i==0) { 
                    dp[0][k][0] =0;
                    dp[0][k][1] =-prices[0];
                    continue;
                }

                dp[i][k][0] = std::max(dp[i-1][k][0], dp[i-1][k][1]   + prices[i]);
                dp[i][k][1] = std::max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }

        return dp[n-1][max_k][0];
    }
};
```
在这个问题中，`k=2`只有两个状态，因此可以不使用三维数组，可以直接枚举出每个状态。
```
dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])

 dp[i-1][0][0]：交易0次，且手中持有现金，因此利润肯定是0。
```
根据这个枚举，就可以写出牛逼又装逼的代码
```cpp
    class Solution {
    public:
    int maxProfit(std::vector<int>& prices) {
        if(prices.empty()) return 0;
        // i 开始是0，因为 dp_i11 / dp_i21 都是初始化为 -prices[0]
        int dp_i10 = 0, dp_i11 = -prices[0];
        int dp_i20 = 0, dp_i21 = -prices[0];

        for(int price : prices) { 
            dp_i20 = std::max(dp_i20, dp_i21 + price);
            dp_i21 = std::max(dp_i21, dp_i10 - price);
            dp_i10 = std::max(dp_i10, dp_i11 + price);
            dp_i11 = std::max(dp_i11, - price);
        }

        return dp_i20;
    }
};
```

## [买卖股票的最佳时机IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

在此时，对于任意给定的交易次数K，求能获得的最大利润是多少。这是对上面三个问题的总结。

当 `k >= n/2`时，相当于就是在给定的天数内，不限次数的交易。因为完整地交易一次需要2天时间，`k`次交易需要`2*k`天时间，如果`k>=n/2`，那么就是相当于在n天内不限次数交易，此时可以直接调用问题II的贪心算法。否则使用问题3的解法。

```cpp
class Solution {
public:
    int maxProfit(int max_k, vector<int>& prices) {

        if(prices.empty()) return 0 ;

        int n = prices.size(); 
        if(max_k >= n/2) 
        { 
            return __greddy(prices);
        }

        int dp[n][max_k+1][2]; ::memset(dp, 0, sizeof(dp));

        for(int i=0; i < n; i++) { 
    
            for(int k=1; k <= max_k; ++k) { 
                
                if(i==0) { 
                    // dp[0][k][0] =0;
                    dp[0][k][1] =-prices[0];
                    continue;
                }

                dp[i][k][0] = std::max(dp[i-1][k][0], dp[i-1][k][1]   + prices[i]);
                dp[i][k][1] = std::max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }

        return dp[n-1][max_k][0];
    }

private:
    int __greddy(vector<int>& prices) {
        if(prices.empty()) return 0; 
        int maxProfit_ =0; 

        for(int i=0; i < prices.size()-1; ++i) { 
            if(prices[i] < prices[i+ 1]) 
            { 
                maxProfit_ += prices[i+1] - prices[i];
            }
        }

        return maxProfit_;
    }
};
```

### 空间压缩
上面的三维`dp`数组，可以压缩为二维。如何压缩？你会发现，每天`i`的状态都只是依赖前一天`i-1`的状态，因此可以实现滚动更新。

```cpp
class Solution {
public:
    int maxProfit(int max_k, vector<int>& prices) {

        if(prices.empty()) return 0 ;

        int n = prices.size(); 
        if(max_k >= n/2) 
        { 
            return __greddy(prices);
        }

        int dp[max_k+1][2]; ::memset(dp, 0, sizeof(dp));

        for (int j = 1; j <= max_k; j++) {
            dp[j][1] = -prices[0];
        }

        for(int price : prices) { 
    
            for(int k=1; k <= max_k; ++k) { 
                
                dp[k][0] = std::max(dp[k][0], dp[k][1]   + price);
                dp[k][1] = std::max(dp[k][1], dp[k-1][0] - price);
            }
        }

        return dp[max_k][0];
    }
}
```

## [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)
这是第二题的变形。`k`仍然不受限制，但是冷冻一天，就是说`当持有股票时，要么是前二天的卖出，现在买入，或者是前一天就持有股票。而不持有股票，可能昨天就不持有，或者昨天持有股票今天卖出。

可得状态方程：
```
  dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
  dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
```
因而可得代码，用滚动更新压缩空间。
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0; 

        int dp_i0 = 0, dp_i1 = -prices[0];
        int prev = 0;

        for(const int& price : prices) { 
            int next = dp_i0;
            dp_i0 = std::max(dp_i0, dp_i1 + price);
            dp_i1 = std::max(dp_i1, prev - price);
            prev = next;
        }

        return dp_i0;
    }
};
```



# 石头合并问题

## [美团2020系统开发题目](https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0?toCommentId=6260901)

这是以最小的代价从相邻的两堆中选择的方式。结合代码和下面的参考连接也比较容易理解。

```cpp
#include <algorithm>
#include <limits.h>
#include <iostream>
#include <vector>

class Solution{ 
public:
  template<typename T> using Matrix = std::vector<std::vector<T>>;

  static void solve(const std::vector<int>& data, int length) {
    int N = length;
    Matrix<int> dp(N+1, std::vector<int>(N+1, INT_MAX));
    Matrix<int> sum(N+1, std::vector<int>(N+1));

    // 初始化,basecase
    for(int i=1; i <= N; ++i) { 
      sum[i][i] = data[i];
      dp[i][i] = 0;
    }

    for(int interval=1; interval < N; ++interval) {   // 区间长度
      // 对于同一个区间长度，不同起点，寻找最小的相邻的两堆
      // 区间最大的终点是数组的最后一个元素 index：N
      for(int begin=1; begin + interval <= N; ++begin) { // 区间起点
        int end = begin + interval;                      // 区间终点 

        /*** @brief: 思路，在区间[begin, end]找到和最小的两个，加起来，作为 dp[begin][end]的值
         * 动态方程解释：dp[begin][k] + dp[k+1][end] + sum[begin][end]
         *     因为之前合并成 [begin][k]、[k+1][end]这两堆所需的代价，
         *     将他们合并成新的堆，所需的代价，就需要在此基础上加上新的和: sum[begin][end]
         * 
         *  dp[begin][end] = std::min(dp[begin][end], 
         							  dp[begin][k] + dp[k+1][end] + sum[begin][end]);
         * 
         * 就是为了找个最小值：相同的区间长度，不同的起点。
         * 
         */
        
        for(int k=begin; k < end; ++k) {
          sum[begin][end] = sum[begin][k] + sum[k+1][end];
          dp[begin][end] = std::min(dp[begin][end], 
                                    dp[begin][k] + dp[k+1][end] + sum[begin][end]);
        }
      }
    }

    std::cout<< dp[1][N]<<std::endl;
  }
};

int main(int argc, char const *argv[]) {

  int N;
  std::cin>>N;
  std::vector<int> data(N+1, 0);

  for(int i =1; i <= N; ++i) { 
     std::cin>> data[i];
  }

  Solution::solve(data, N);
  return 0;
}
```

## 环形合并石头

```cpp
在一个圆形操场的四周摆放着n堆石子。现要将石子有次序地合并成一堆。
规定每次只能选相邻的2 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。

试设计一个算法，计算出将n堆石子合并成一堆的最小得分和最大得分。对于给定n堆石子,计算合并成一堆的最小得分和最大得分。
```

这题的思想：是将环展开成上面的直线来处理。那么元素个数就由原来的`N`编程`2N-1`。比如`[1,2,3,4]`因为首尾可以相连变成`[1,2,3,4,3,2,1]`。


## 参考连接

+ [石头合并问题大总结](https://blog.csdn.net/weixin_43939593/article/details/105406704)

# 环形单链表的约瑟夫问题

```
题目：

据说著名犹太历史学家Josephus有过以下故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。

输入：一个环形单向链表的头节点head和报数的值m。
返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。
进阶：如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎么实现？
```

#### 锯齿函数

利用的是一个函数`y = x % target`，其中`target`是一个给定值，y的形状是一个锯齿形

![锯齿](/Image/B99.专题-photo/约瑟夫环_函数.png) 

每次删除一个节点之后就重新编号，当只是剩下最后一个节点的时候，唯一的那个节点是1。思路是，如果能将最终被删除的那个节点的编号，在原始的链表中的编号直接算出来，那么直接返回这个原始编号即可。整个时间复杂度是`O(N)`。

```
    剩余节点数          存活节点编号
        N                   ?
        N-1                 ?
        ...                 ...
        1                   1
```

那，这个之间的关系是怎么算出来的？ 假设有N个节点的单向环形链表，

```
        编号            报数           
        1                1
        2                2
       ...              ...
        N                N
        1                N+1
        2                N+2
       ...              ...
        N                N+N
```

因此，节点和报数之间的关系：也是锯齿波形：`y =( x-1) % N + 1`，其中x表示报数，y表示编号，N表示节点个数。

#### 新号与旧号之间关系

```
序列：[2, 10, 31,  4, 3, 7, 9, 1],  m =3 
编号： 1   2   3   4  5  6  7  8

第一次删除后重新编号：
序列：[2, 10,     4, 3, 7, 9, 1]
编号：[6,  7      1, 2, 3, 4, 5]

第二次删除后重新编号：
序列：[2, 10, 4, 3, 9, 1]
编号：[3, 4, 5， 6, 1, 2]
...
```

假设被删除的节点编号是`S`，那么`S = (m-1) % N + 1`，`m`是肯定的步数，`N`是每次的链表节点个数。 删除指定节点之后和原来节点之家的编号关系：

以第一次删除为例：`S`编号被删除后，`S+1`就是新编号的1，`S-1`就是`N-1`，新旧之间的编号关系：

```
旧编号      新编号
S+1          1
S+2          2 
...         ...
N           N - S
1          N- S + 1
2          N- s + 2
...         ...
S-1         N - 1 
```

如何根据旧编号关系`y = (x -1) % N + 1`，得到新编号关系：

+ 在第一段曲线上旧坐标`[S+1, S+1]`变成了新坐标`[1, S+1]`，是通过新坐标向左平移S个单元，
+ 在第二段曲线上旧坐标`[N+1, 1]`变成了新坐标中的`[N-S+1, 1]`，也可以通过新坐标向左移了S个单元

综上可得，可以得出`旧 = (新 - 1 + S) % N + 1` 

#### 推理

```
S与m关系 ： S = (m-1) % N + 1           // 1
旧编号关系：y = (x -1) % N + 1          // 2
编号关系 ：旧 = (新 - 1 + S) % N + 1    // 3

其中，x是第几个数，m是步数，S是被删除节点编号，N是节点数，N是不断减少的
```

根据这个公式，从删除到节点只剩一个节点开始逆推到原始`N`个节点，推理出留下的节点对应的。就可以知道是哪个了。

```
假设；m=3，那么只是剩下一个节点时的逆推，N = 2
N-1:
  S  = (m-1) % i + 1 = 2 % 2 + 1 = 1
  旧 = (1 - 1 + 1) % 2 + 1 = 2     // 只留下一个节点的编号是 1， 对应的只剩两个节点时，这个节点的编号是2
N-2: 
  S  = (m-1) % i + 1 = 2 % 3 + 1 = 3
  旧 = (2 - 1 + 3) % 3 + 1 =  2    // 此时待返回的节点在只剩三个节点时，这个节点的编号是2
N-3:
  S  = (m-1) % i + 1 = 2 % 4 + 1 = 3
  旧 = (2 - 1 + 3) % 4 + 1 = 1   // 待返回的节点在只剩四个节点时，这个节点的编号是1

...

一直推算到 i == N时， 即原始链表，待返回的节点在原始链表中的编号，就可以算出是第几个节点。
```

公式1和3，可以化简为 **`旧 = (新  + m -1）% i + 1`**。

```java
public calss Solution { 
	public static Node josephusKill(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node cur = head.next;
		int numsOfNode = 1;     // numsOfNode -> list size
		while (cur != head) {
			numsOfNode++;
			cur = cur.next;
		}
		
		numsOfNode = getLive(numsOfNode, m); // numsOfNode -> service node position
		while (--numsOfNode != 0) {
			head = head.next;
		}
		head.next = head;
		return head;
	}

    // i 是节点数
    // getLive(i, m) 表示的就是编号 
	public static int getLive(int i, int m) {
		if (i == 1) 
        	return 1;
		
		return (getLive(i - 1, m) + m - 1) % i + 1; // 返回旧的编号
	}
}
```

