---
id : A10.字典树
title : A10.字典树
typora-root-url : ../
---

# 字典树

名称：trie， 字典树，单词查找树，前缀树

作用：单词查找，字符串排序

  1. 也叫做：前缀索引树
  2. 把每个字符串按照前缀的顺序插入到树形结构中
  3. 字典树可以用于字符串的排序，时间复杂度 $O(n)$

字典树等价于单词表

![image-20210126235307421](/Image/A10.字典树-photo/image-20210126235307421-1623756908422.png)

9 < 11 字典序:09 < 11 ->文件夹命名排序

红色节点可做结尾，独立成词，边代表字母

比较操作的时间下限为O(nlogn);

字典序排序单词：为O(n); 

小点：系统命名是1,2,3，...10直接排前，字典序

计算机：学习信息的表示

操作系统：如何表示文件，配置文件，

计算机网络：如何合理封装信息，如何保证，协议

+ 找到具有同一前缀的全部键值。
+ 按词典序枚举字符串的数据集

```cpp
#define BASE 26
#define BASE_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

inline int code(char ch) {
    return ch - BASE_LETTER;
}

void insert(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();
        p = p->next[code(str[i])];
    }
    p->flag = 1;
    return ;
}

int query(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        p = p->next[code(str[i])];
        if (p == NULL) return 0;
    }
    return p->flag;
}

void output(Node *root, int k, char *buff) {
    if (root == NULL) return ;
    if (root->flag) printf("%s\n", buff);
    for (int i = 0; i < BASE; i++) {
        buff[k] = BASE_LETTER + i;
        buff[k + 1] = '\0';
        output(root->next[i], k + 1, buff);
    }
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    char str[1000];
    int n;
    Node *root = getNewNode();
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    output(root, 0, str);
    while (~scanf("%s", str)) {
        printf("query %s, result = %s\n", str, query(root, str) ? "Yes" : "No");
    }
    return 0;
}
```

指针变量-8字节(sizeof(int *))



# ==双数组字典树==

![image-20201017104134948](https://raw.githubusercontent.com/worst0/picture/master/img/image-20201017104134948.png)

## 传统字典树的缺点

1. 完全二叉树，实际存储结构是连续数组空间，思维逻辑结构是树型的
2. 完全二叉树，节省了大量的存储边的空间
3. 优化思想：记录式 改 计算式
4. $n$ 个节点的字典树，有效使用 $n-1$ 条边，浪费了 $(k-1)*n+1$ 条边的存储空间
5. 参考完全二叉树的优点，提出了双数组字典树

**==信息的等价==** 只是修改了字典树的表示方式---计算机本质就是信息的表示

双数组字典树是离散构建的，不太支持动态插入，其实它是字典文件->建立对应字典树->转为相应双数组字典树

## 双数组字典树

1. 顾名思义，两个数组代表一棵字典树结构
2. base 数组信息与子节点编号相关，base + i 就是第 i 个子节点编号
3. check 数组信息负责做【亲子鉴定】，check 数组中用正负表示是否独立成词
4. 不擅长进行动态插入操作
5. 一次建立，终身使用
6. 为了方便，基于普通字典树实现的双数组字典树
7. 增加了 fail 数组，可以完成基于双数组字典树的 AC 自动机
8. 超小规模实验结果：双数组字典树压缩效率是 25 倍
9. 非常方便的输出到文件中，进行机器之间的共享
10. 课后作业：利用真实数据集，测试双数组字典树的压缩效率
11. base值可以相同,base的子节点的值才重要,不可以冲突



## 二叉字典树

1. 计算机中所有信息都是二进制存储的
2. 任何信息都可以看成一个二进制串
3. 插入二进制串的字典树，就是二叉字典树
4. 二叉字典树可以存储任意信息
5. 节省空间，浪费时间，本质：时间换空间的算法思维
6. 哈弗曼编码 + 二叉字典树 可能更配哦，既节省了空间，又在最大限度上节省了查找时间



不积跬步，无以至千里。不积小流，无以成江海。



**建议：**多看几本基本的算法书、【数论基础】、多接触离散型数学思维



字典树叶子节点浪费空间过大

记录式转计算式

### 双数组字典树

![image-20201017104134948](/Image/A10.字典树-photo/image-20201017104134948.png)


**==信息的等价==**

只是修改了字典树的表示方式---计算机本质就是信息的表示

双数组字典树是离散构建的，不太支持动态插入，其实它是字典文件->建立对应字典树->转为相应双数组字典树

父节点与子节点的关系的计算式表示：

- base[]：计算父子节点的边的中间量

  ​	father的第i个孩子(i是字符编码) ： child_i = base[father] + i;

- check[]：记录每个子节点的真正父节点, 以及是否独立成词(正负)

  ​	check[child_i] = father;

  ​	check[child_i] = -father; 负数额外代表独立成词

  ​	不可记录0号，从1号开始；相应节点的父节点不可为0号

  ​	初始check[]为0，代表未占用，一旦记录一定非0；

- base[child_i] = 

记录更多的信息，可通过封装结构体，多个数组

### 二叉字典树+哈夫曼编码

编码：根据问题场景来等价信息表示。

哈夫曼编码：将信息表示为最短

回答：

- 哈夫曼编码算出：需要的信息，统计问题场景下的概率；

- 对中文字符集编码：一个中文占若干编码，对每个字节编码

### 基于字典树的 AC 自动机

```cpp
/*************************************************************************
   > File Name: 12.double_array_trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  8/21 14:14:38 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DATrie {
    int *base, *check;
    int root, size;
} DATrie;

DATrie *getDATrie(int n) {
    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);
    tree->root = 1;
    tree->size = n;
    tree->base = (int *)calloc(sizeof(int), n);
    tree->check = (int *)calloc(sizeof(int), n);
    tree->check[tree->root] = 1;
    return tree;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int getBaseValue(Node *root, DATrie *tree) {
    int base = 0, flag;
    do {
        flag = 1;
        base += 1;
        for (int i = 0; i < BASE; i++) {
            if (root->next[i] == NULL) continue;
            if (tree->check[base + i] == 0) continue;
            flag = 0;
            break;
        }
    } while (!flag);
    return base;
}

int buildDATrie(int ind, Node *root, DATrie *tree) {
    int base = tree->base[ind] = getBaseValue(root, tree);
    int ans = ind;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree->check[base + i] = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        int temp = buildDATrie(base + i, root->next[i], tree);
        if (temp > ans) ans = temp;
    }
    if (root->flag) tree->check[ind] = -tree->check[ind];
    return ans;
}

int query(DATrie *tree, const char *str) {
    int p = tree->root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;
        p = tree->base[p] + ind;
    }
    return tree->check[p] < 0;
}

void clearDA(DATrie *tree) {
    if (tree == NULL) return ;
    free(tree->base);
    free(tree->check);
    free(tree);
    return ;
}

int main() {
    int n, cnt1 = 1, cnt2;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    while (n--) {
        scanf("%s", str);
        cnt1 += insert(root, str);
    }
    DATrie *tree = getDATrie(cnt1 * BASE + 5);
    cnt2 = buildDATrie(tree->root, root, tree) + 1;
    while (~scanf("%s", str)) {
        printf("search %s, result = %s\n", str, query(tree, str) ? "YES" : "NO");
    }
    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;
    printf("Trie memory : %d Bytes\n", mem1);
    printf("Double Array Trie memory : %d Bytes\n", mem2);
    printf("memory rate : %.4lf%%\n", 1.0 * mem2 / mem1 * 100);
    clearDA(tree);
    clear(root);
    return 0;
}
```

### 基于双数组字典树的 AC 自动机

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BASE 26
#define BEGIN_LETTER 'a'
#define max(a, b) ((a) > (b) ? (a) : (b))
#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)

typedef struct DANode {
    int base, check, fail;
    char *str;
} DANode;

typedef struct Node {
    int flag;
    char *str;
    struct Node *next[BASE];
} Node, *Trie;

int node_cnt = 0;

Node *get_new_node() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    node_cnt += 1;
    return p;
}

void clear(Trie root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    if (root->flag) free(root->str);
    free(root);
    return ;
}

Node *insert(Trie root, const char *str) {
    if (root == NULL) root = get_new_node();
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = get_new_node();
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return root;
}

int get_base(Node *node, DANode *data) {
    int base = 2, flag = 0;
    while (!flag) {
        flag = 1;
        for (int i = 0; i < BASE; i++) {
            if (node->next[i] == NULL) continue;
            if (data[base + i].check == 0) continue;
            flag = 0;
            break;
        }
        base += (!flag);
    }
    return base;
}

int build(Node *node, DANode *data, int ind) {
    if (node == NULL) return 0;
    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;
    int max_ind = ind;
    data[ind].base = get_base(node, data);
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        data[data[ind].base + i].check = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        int temp = build(node->next[i], data, data[ind].base + i);
        max_ind = max(max_ind, temp);
    }
    return max_ind;
}

void build_ac(DANode *data) {
    #define MAX_N 100000
    int *queue = (int *)malloc(sizeof(int) * MAX_N);
    int head = 0, tail = 0;
    data[1].fail = 0;
    queue[tail++] = 1;
    while (head < tail) {
        int ind = queue[head++];
        for (int i = 0; i < BASE; i++) {
            if (!has_child(data, ind, i)) continue;
            int p = data[ind].fail;
            while (p && !has_child(data, p, i)) p = data[p].fail;
            if (p == 0) p = 1;
            else p = data[p].base + i;
            data[data[ind].base + i].fail = p;
            queue[tail++] = data[ind].base + i;
        }
    }
    return ;
    #undef MAX_N
}

void search_ac(DANode *data, const char *str) {
    int p = 1;
    for (int i = 0; str[i]; i++) {
        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;
        if (p == 0) p = 1;
        else p = data[p].base + str[i] - BEGIN_LETTER;
        int q = p;
        while (q) {
            if (data[q].check < 0) printf("find string : %s\n", data[q].str);
            q = data[q].fail;
        }
    }
    return ;  
}

void output_da(DANode *data, int n) {
    for (int i = 1; i <= n; i++) {
        if (i - 1 && i % 5 == 1) printf("\n");
        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);
    }
    printf("\n");
    return ;
}

int main() {
    Trie root = NULL;
    #define INSERT_CNT 5
    root = insert(root, "hai");
    root = insert(root, "zei");
    root = insert(root, "ha");
    root = insert(root, "ab");
    root = insert(root, "ehz");
    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));
    int da_cnt = build(root, data, 1);
    build_ac(data);
    output_da(data, da_cnt);
    search_ac(data, "sasherhs");
    #undef INSERT_CNT 
    return 0;
}
```



### 双数组字典树-kai

```cpp
/*************************************************************************
	> File Name: 1.double_array_trie.cpp
	> Author: huguang
	> Mail: hug@haizeix.com
	> Created Time: 
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;

#define BASE 26
#define MSG_LEVEL 2
#define DEBUG_LEVEL 1
#define INFO_LEVEL 2

#define LOG(level, frm, args...) { \
    if (level >= MSG_LEVEL) { \
        printf(frm,##args); \
    } \
}

#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args)
#define LOG_INFO(args...) LOG(INFO_LEVEL, args)

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DANode {
    int base, check, fail;
} DANode;

Node *getNewNode() {
    Node *p = (Node *)malloc(sizeof(Node));
    p->flag = 0;
    memset(p->next, 0, sizeof(p->next));
    return p;
}

inline int code(char c) { return c - 'a'; }

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = code(str[i]);
        if (p->next[ind] == NULL) {
            cnt += 1;
            p->next[ind] = getNewNode();
        }
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear_trie(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear_trie(root->next[i]);
    }
    free(root);
    return ;
}

int get_base_value(Node *root, DANode *tree, int ind) {
    int base = 1, flag;
    do {
        base += 1;
        flag = 1;
        for (int i = 0; i < BASE && flag; i++) {
            if (root->next[i] == NULL) continue;
            if (tree[base + i].check) flag = 0;
        }
    } while (flag == 0);
    return base;
}

int transform_double_array_trie(Node *root, DANode *tree, int ind) {
    if (root == NULL) return 0;
    if (root->flag) tree[ind].check = -tree[ind].check;
    int base = get_base_value(root, tree, ind);
    tree[ind].base = base;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree[base + i].check = ind;
    }
    int max_ind = ind;
    for (int i = 0; i < BASE; i++) {
        int a = transform_double_array_trie(root->next[i], tree, base + i);
        if (a > max_ind) max_ind = a;
    }
    return max_ind;
}

void dump_double_array_trie(DANode *tree, int n) {
    LOG_INFO("%d\n", n);
    for (int i = 0; i <= n; i++) {
        LOG_INFO("%d %d %d\n", tree[i].base, tree[i].check, tree[i].fail);
    }
    return ;
}

void build_ac_base_double_array_trie(DANode *tree, int max_ind) {
    int *que = (int *)malloc(sizeof(int) * (max_ind + 5));
    int head, tail;
    head = tail = 0;
    tree[1].fail = 0;
    for (int i = 0; i < BASE; i++) {
        int child_ind = tree[1].base + i;
        if (abs(tree[child_ind].check) != 1) continue;
        tree[child_ind].fail = 1;
        que[tail++] = child_ind;
    }
    while (head < tail) {
        int p = que[head++];
        for (int i = 0; i < BASE; i++) {
            int c = tree[p].base + i, k = tree[p].fail;
            if (abs(tree[c].check) != p) continue;
            while (k && abs(tree[tree[k].base + i].check) != k) k = tree[k].fail;
            if (k == 0) k = 1;
            if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;
            tree[c].fail = k;
            que[tail++] = c;
        }
    }
    free(que);
    return ;
}

int main() {
    int n, cnt = 1;
    char str[1000];
    scanf("%d", &n);
    Node *root = getNewNode();
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    size_t tree_size = sizeof(DANode) * (cnt * BASE);
    DANode *tree = (DANode *)malloc(tree_size);
    memset(tree, 0, tree_size);
    int max_ind = transform_double_array_trie(root, tree, 1);
    size_t s1 = cnt * sizeof(Node);
    size_t s2 = max_ind * sizeof(DANode);
    LOG_DEBUG("trie(%lu Byte), double array trie(%lu Byte)\n", s1, s2);
    LOG_DEBUG("rate : %.2lf\n", 1.0 * s2 / s1);
    for (int i = 0; i <= max_ind; i++) {
        LOG_DEBUG("(%d | %d, %d)\t", i, tree[i].base, tree[i].check);
        if ((i + 1) % 5 == 0) LOG_DEBUG("\n");
    }
    LOG_DEBUG("\n");
    build_ac_base_double_array_trie(tree, max_ind);
    dump_double_array_trie(tree, max_ind);
    free(tree);
    clear_trie(root);
    return 0;
}
```





### AC 自动机的递归建立



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode* fail, *father;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->fail = NULL;
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
            p->childs[buffer[i] - BASE]->father = p;
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    #define next childs
    #define Node TrieNode
    if (node == NULL) return ;
    if (node->fail == NULL) build_automaton(node->father);
    for (int i = 0; i < SIZE; i++) {
        if (node->next[i] == NULL) continue;
        if (node->next[i]->fail) continue;
        Node *p = node->fail, *pre_p = node;
        while (p && p->next[i] == NULL) {
            if (p->fail == NULL) build_automaton(p->father);
            pre_p = p;
            p = p->fail;
        }
        if (p == NULL) p = pre_p;
        else p = p->next[i];
        node->next[i]->fail = p;
        build_automaton(node->next[i]);
    }
    return ;
    #undef next
    #undef Node
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        while (p && p->childs[str[0] - 'a'] == NULL) p = p->fail;
        if (p == NULL) p = ac_tree;
        else p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        str++;
    }
    return ret;
}

int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```

### AC 自动机的线索化

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode *fail;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));
    int head = 0, tail = 0;
    queue[tail++] = node;
    while (head < tail) {
        TrieNode *now = queue[head++];
        for (int i = 0; i < SIZE; i++) {
            if (now->childs[i] == NULL) {
                if (now != node) now->childs[i] = now->fail->childs[i];
                continue;
            }
            TrieNode *p = (now->fail ? now->fail->childs[i] : node);
            if (p == NULL) p = node;
            now->childs[i]->fail = p;
            queue[tail++] = now->childs[i];
        }
    }
    free(queue);
    return ;
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        if (p == NULL) p = ac_tree;
        str++;
    }
    return ret;
}
int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    printf("insert done\n");
    fflush(stdout);
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```



## 最大异或和子数组 

```
题目：给定一个数组，求子数组的最大异或和。其中，一个数组的异或和定义为数组中所有的数异或起来的结果。
```

### 常规解法

涉及子数组的题目，总体思路一样：以`i`结尾的子数组异或和，再将`i`从`0 < i <= n`遍历一遍，求出所有位置的子数组异或和，最大值就在其中。但是如此的时间复杂度分析：

```
以i为例：
    i-1~i
    i-2~2
    ...
    0 ~ i
```

需要求出i个子数组的异或和，每个子数组异或和时间复杂度为`O(n)`,因为仅仅求一个位置i的子数组异或和就高达`O(n^2)`的复杂度。外层再将i从`0 < i <= n`遍历一遍，时间复杂度`O(n^3)`

```cpp
int maxXor(int* arr, int length) {
    int outside_xor =0;
    int max_=0;

    for(int i=0; i < length; ++i) { 
        outside_xor ^= arr[i];   // 记录以 i 位置结束的 0~i的数组异或和
        max_ = std::max(max_, outside_xor);
        // 求取以i位置结尾的所有子数组异或和
        for(int j=0; j < i; ++j) { 
            int inside_xor = 0;
            for(int k=0; k < j; ++k) { 
                inside_xor ^= arr[k];                //  0~ j-1 位置的异或和 
                int x = outside_xor ^ inside_xor;    // j ~ i 位置的异或和，其中 0 <= j <i，这就是以i结尾所有子数组异或和
                if(max_ < x) max_ = x;
            }
        }
    }
    return max_;
}
```

如果改进，降低算法的复杂度，可以使用一个数组记录下之前的一些重复计算的值。比如这题的所有以`j`结尾的`0~j`的子数组，都在重复计算，那么就是可以用一个数组来存储，时间复杂度可以降低为`O(n^2)`

```cpp
int maxXor(int* arr, int length) {
    int outside_xor =0;
    int max_=0;
    int xorsum[length]; // 以 i结束的 0~i的所有异或和

    for(int i=0; i < length; ++i) { 
        outside_xor ^= arr[i]; 
        max_ = std::max(max_, outside_xor);
        xorsum[i] = outside_xor;   // 存储起来
        for(int j=0; j < i; ++j) { 
            int x =  xorsum[j] ^ outside_xor; // 这里以 0~j区间的异或和，之前已经计算好，直接使用
            if(max_ < x) max_ = x;
        }
    }
    return max_;
}
```

### 前缀树 

将每个数字变成二进制用一个二叉树来表示，所有的二叉树都是左子节点是0，右子节点是1。整个树根节点不表示，只是串联左右子树。

```
0 ~ 1的异或和
0 ~ 2的异或和
...
0 ~ i-1的异或和
```

在求`0~i`区间最大异或和子数组时，前面得各个位置信息都已经具备了。因此可以直接使用了：将 `0 ~ i` 前面的异或和生成前缀树，在求`i`位置`arr[i]`的时候，如下限制：

+ 第一位是符号位，应该该位置是0，表示正数
+ 除了符号位外，在前缀树中，能选择1就选择1。如果没有1，只能选0。

满足以上两个，这样才能保持最大。 说的可能不太好理解。

```
比如：
 0 ~ 0的异或和是 0001 
 0 ~ 1的异或和是 0101
 0 ~ 2的异或和是 1011
 0 ~ 3的异或和是 1111
 求以位置3结尾的最大异或和子数组 
 
                        root 
                      /     \
                     0       1
                    / \     /
                   0   1   0
                  /    /    \
                 0    0      1
                 \     \      \
                  1     1      1
```

以`0~3`位置的异或和`1111`来确定以位置3结尾的最大异或和子数组。

+ 第一位符号位是1：期望的是0，上面的前缀树中第二层存在 root - 1
+ 第二位是1，如果要让异或和最大，这位异或后的结果也是1，那么就期待0。前缀树中也存在 root - 1 - 0
+ 同理，第三位也期望是1，需要与0异或，但是此时不存在0，只能选择1
+ 同理，第四位也只能与1异或

最终的异或`1011 ^ 1111 =  0100`，即使4，也就是最大异或子数组区间：`[2,3]`。 代码及其解释如下：

```java
public class Solution { 

	public static class Node {
		public Node[] nexts = new Node[2]; // 两个节点，一个指向0，一个指向1，
	}

	public static class NumTrie {
		public Node head = new Node();

		// 用于生成前缀树
		public void add(int num) {
			Node cur = head;
			for (int move = 31; move >= 0; move--) {
				// 从高位到低位 依次取出每一位的二进制数
				int path = ((num >> move) & 1);
				// cur.nexts[path] = cur.nexts[path] == null ? new Node() : cur.nexts[path];
				if(cur.nexts[path] == null)
					cur.nexts[path] = new Node();
					
				cur = cur.nexts[path];
			}
		}

		// 根据前缀树查询异或最大值
		public int maxXor(int num) {
			Node cur = head;
			int res = 0;
			for (int move = 31; move >= 0; move--) {
				// 取出每位二进制数
				int path = (num >> move) & 1;
				// 符号位，需要和符号位保持一致，才能异或为0。非符号位期望是1 
				// 非符号位置，需要异或的结果是1，因此 path ^1，最低为位肯定是1
				int best = move == 31 ? path : (path ^ 1);
				// 这里没有创建结点，就是查询，选择道路
				best = cur.nexts[best] != null ? best : (best ^ 1); // 实际的值
				res |= (path ^ best) << move; 
				cur = cur.nexts[best];
			}
			return res;
		}

	}

	public static int maxXorSubarray(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int eor = 0;
		NumTrie numTrie = new NumTrie();
		numTrie.add(0);
		for (int i = 0; i < arr.length; i++) {
			eor ^= arr[i]; //  0 ~ i 的异或和
			max = Math.max(max, numTrie.maxXor(eor)); // 求取
			numTrie.add(eor);
		}
		return max;
	}
}
```

显而易见，时间复杂度是`O(N)`。





# ==多模匹配问题==

1. 有多个模式串的匹配问题，就是多模匹配问题
2. Step1：多个模式串，建立成一棵字典树
3. Step2：和文本串的每一位对齐匹配，模拟暴力匹配算法的过程



##  AC 自动机的思想

1. 当匹配成功文本串中的 she 时，也就意味着后续一定会匹配成功 he
2. she 对应了字典树中的节点 P，he 对应了字典树中的节点Q
3. P 和 Q 就是等价匹配节点，如果从 P 引出一条边指向 Q，就可以加速匹配过程
4. 在 P 下面查找节点的操作，等价于在 Q 下面查找节点的操作
5. 这条等价关系边，通常在 AC 自动机上叫做 【Fail 指针】等价匹配指针
6. AC 自动机 = Trie + Fail 指针
7. 子节点的 Fail 指针是需要参照父节点的 Fail指针信息的，最简单的建立方式，就是采用【层序遍历】
8. 没做优化的 AC 自动机，本质上是一个 NFA（非确定型有穷状态自动机）
9. 通俗理解：根据当前状态 p，以及输入字符 c，无法通过一步操作确定状态
10. 第二种理解：当前状态，并不代表唯一状态。

**AC 自动机优化：**使用路径压缩思想，使状态转移时可以一步跳转到目标状态。

优化以后的 AC 自动机，更像 DFA（确定性有穷状态自动机）。

![image-20210127193634993](/Image/A10.字典树-photo/image-20210127193634993.png)

![image-20210127193826398](/Image/A10.字典树-photo/image-20210127193826398.png)

![image-20210217201415813](/Image/A10.字典树-photo/image-20210217201415813.png)



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE], *fail;
} Node;

typedef struct Queue {
    Node **data;
    int head, tail, size;
} Queue;

Queue *init_queue(int n) {
    Queue *q = (Queue *)calloc(sizeof(Queue), 1);
    q->data = (Node **)malloc(sizeof(Node *) * n);
    q->tail = q->head = 0;
    return q;
}

Node *front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->head == q->tail;
}

void push(Queue *q, Node *node) {
    q->data[q->tail++] = node;
    return ;
}

void pop(Queue *q) {
    if (empty(q)) return ;
    q->head++;
}

void clear_queue(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *node) {
    if (node == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(node->next[i]);
    }
    free(node);
    return ;
}

void build_ac(Node *root, int n) {
    Queue *q = init_queue(n + 10);
    root->fail = NULL;
    push(q, root);
    while (!empty(q)) {
        Node *now_node = front(q);
        pop(q);
        for (int i = 0; i < BASE; i++) {
            if (now_node->next[i] == NULL) continue;
            Node *p = now_node->fail;
            while (p && p->next[i] == NULL) p = p->fail;
            if (p == NULL) now_node->next[i]->fail = root;
            else now_node->next[i]->fail = p->next[i];
            push(q, now_node->next[i]);
        }
    }
    return ;
}

int match(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        while (p && p->next[ind] == NULL) p = p->fail;
        if (p == NULL) p = root;
        else p = p->next[ind];
        Node *q = p;
        while (q) cnt += q->flag, q = q->fail;
    }
    return cnt;
}

int main() {
    Node *root = getNewNode();
    int n, cnt = 0;
    char str[1000];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    // build ac
    build_ac(root, cnt);
    scanf("%s", str);
    // match ac
    printf("match word cnt : %d\n", match(root, str));
    return 0;
}
```



## 预习资料：【数据结构】> 字符串统计

1. AC 自动机裸题

2. 解题的关键，在于如何维护每一个单词的计数量

3. 使用幼儿园必知必会的指针技巧维护的

4. **船长翻车：**题目数据中给出的单词会有重复

   



### 存储任意类型的栈

```cpp
/*************************************************************************
   > File Name: 15.any_stack.h
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  2/28 10:49:10 2018
 ************************************************************************/

#ifndef _15_ANY_STACK_H
#define _15_ANY_STACK_H

#include <stdlib.h>
#include <string.h>

#define STACK_OK 1
#define STACK_ERROR 0

typedef struct Stack {
    char *data;
    int data_size;
    int size, top;
} Stack;

#define init_stack(n, T) (__init_stack(n, sizeof(T)))
#define push_stack(s, data) (__push_stack(s, (char *)(data)))
#define top_stack(s, T) ((T *)(__top_stack(s)))

Stack *__init_stack(int n, int data_size) {
    Stack *s = (Stack *)malloc(sizeof(Stack) * 1);
    s->data = (char *)malloc(n * data_size);
    s->data_size = data_size;
    s->size = n;
    s->top = -1;
    return s;
}

int __push_stack(Stack *s, char *data) {
    if (s->size - 1 == s->top) {
        return STACK_ERROR;
    }
    s->top += 1;
    memcpy(s->data + s->top * s->data_size, data, s->data_size);
    return STACK_OK;
}

int empty_stack(Stack *s) {
    return s->top == -1;
}

char *__top_stack(Stack *s) {
    if (empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->data_size;
}

int pop_stack(Stack *s) {
    if (empty_stack(s)) {
        return STACK_ERROR;
    }
    s->top -= 1;
    return STACK_OK;
}

void clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}

#endif
```

### 二叉树前序遍历（非递归）

```cpp
/*************************************************************************
   > File Name: 14.binary_non_recursive.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  2/28 10:26:37 2018
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "15.any_stack.h"

typedef struct Node {
    int data;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int data) {
    Node *p = (Node *)malloc(sizeof(Node) * 1);
    p->data = data;
    p->lchild = p->rchild=  NULL;
    return p;
}

Node *init_binary_tree() {
    Node *root = getNewNode(1);
    root->lchild = getNewNode(3);
    root->rchild = getNewNode(6);
    root->lchild->rchild = getNewNode(9);
    root->rchild->rchild = getNewNode(11);
    root->rchild->lchild = getNewNode(14);
    root->lchild->rchild->lchild = getNewNode(17);
    return root;
}

void __pre_order(Node *root) {
    // status = 0
    if (root == NULL) return ; // status = 100
    printf("%d\n", root->data); // status = 1
    __pre_order(root->lchild); // status = 2
    __pre_order(root->rchild); // status = 3
    return ; // status = 100
}

typedef struct PreOrderArgs {
    Node *root;
    int status;
} PreOrderArgs;

PreOrderArgs *getNewArgs(Node *root) {
    PreOrderArgs *p = (PreOrderArgs *)malloc(sizeof(PreOrderArgs) * 1);
    p->root = root;
    p->status = 0;
    return p;
}

void pre_order(Node *root) {
    Stack *s = init_stack(100, PreOrderArgs);
    PreOrderArgs *temp_args = getNewArgs(root), *p_args;
    push_stack(s, temp_args);
    while (!empty_stack(s)) {
        p_args = top_stack(s, PreOrderArgs);
        switch (p_args->status) {
            case 0: {
                if (p_args->root == NULL) {
                    p_args->status = 100;
                } else {
                    p_args->status = 1;
                }
            } break;
            case 1: {
                printf("%d\n", p_args->root->data);
                p_args->status = 2;
            } break;
            case 2: {
                temp_args->root = p_args->root->lchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 3;
            } break;
            case 3: {
                temp_args->root = p_args->root->rchild;
                temp_args->status = 0;
                push_stack(s, temp_args);
                p_args->status = 100;
            } break;
            case 100: {
                pop_stack(s);
            } break;
        }
    }
    free(temp_args);
    clear_stack(s);
    return ;
}



int main() {
    Node *root = init_binary_tree();
    pre_order(root);
    __pre_order(root);
    return 0;
}
```

# 3. 快速排序（非递归）



```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MC(T, n) ((T *)malloc(sizeof(T) * n))

#define init_stack(s, n, T) (__init_stack(s, n, sizeof(T)))
#define push_stack(s, value) ({ \
    __typeof(value) __temp = (value); \
    __push_stack(s, (const char *)(&(__temp))); \
})

#define empty_stack(s) (__empty_stack(s))
#define pop_stack(s) (__pop_stack(s))
#define top_stack(s, T) (*((T *)__top_stack(s)))
#define clear_stack(s) (__clear_stack(s))
#define swap(a, b) { \
    __typeof(a) __temp = (a); \
    (a) = (b); (b) = (__temp); \
}
#define ERROR 0
#define OK 1

typedef struct Stack {
    char *data;
    int top, size;
    int value_size;
} Stack;

void __init_stack(Stack *s, int n, int value_size);
int __push_stack(Stack *s, const char *value);
int __empty_stack(Stack *s);
int __pop_stack(Stack *s);
char *__top_stack(Stack *s);
void __clear_stack(Stack *s);

typedef struct Node {
    int val;
    struct Node *lchild, *rchild;
} Node;

Node *init(int val) {
    Node *p = MC(Node, 1);
    p->val = val;
    p->lchild = p->rchild = NULL;
    return p;
}

typedef struct QuickSortArgs {
    int *arr;
    int l, r;
    int x;
    int status;
} QuickSortArgs;

int __quick_sort(int *arr, int l, int r) {
    // 0 : if (r <= l) return ;
    int x, y, z;
    x = l, y = r, z = arr[l];
    while (x < y) {
        while (x < y && arr[y] >= z) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] <= z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    return x;
    // 2: quick_sort(arr, l, x - 1);
    // 3 : quick_sort(arr, x + 1, r);
    // 4 : return ;
}

void init_quick_sort_args(QuickSortArgs *qsa, int *arr, int l, int r, int status) {
    qsa->arr = arr;
    qsa->l = l;
    qsa->r = r;
    qsa->status = 0;
    return ;
}

void quick_sort(int *arr, int n) {
    Stack *s = MC(Stack, 1);
    init_stack(s, 1000, QuickSortArgs);
    QuickSortArgs qsa;
    init_quick_sort_args(&qsa, arr, 0, n - 1, 0);
    push_stack(s, qsa);
    while (!empty_stack(s)) {
        QuickSortArgs *tqsa = &top_stack(s, QuickSortArgs);
        switch (tqsa->status) {
            case 0:
                if (tqsa->r <= tqsa->l) {
                    tqsa->status = 4;
                } else {
                    tqsa->status = 1;
                }
                break;
            case 1:
                tqsa->x = __quick_sort(tqsa->arr, tqsa->l, tqsa->r);
                tqsa->status = 2;
                break;
            case 2:
                init_quick_sort_args(&qsa, arr, tqsa->l, tqsa->x - 1, 0);
                push_stack(s, qsa);
                tqsa->status = 3;
                break;
            case 3:
                init_quick_sort_args(&qsa, arr, tqsa->x + 1, tqsa->r, 0);
                push_stack(s, qsa);
                tqsa->status = 4;
                break;
            case 4:
                pop_stack(s);
                break;
            default:
                printf("ERROR\n");
                break;
        }
    }
    return ;
}

int main() {
    int arr[10] = {9, 7, 5, 4, 2 ,1 ,3, 10, 6, 8};
    quick_sort(arr, 10);
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
void __init_stack(Stack *s, int n, int value_size) {
    s->data = (char *)malloc(value_size * n);
    s->top = -1;
    s->size = n;
    s->value_size = value_size;
    return ;
}

int __push_stack(Stack *s, const char *value) {
    if (s->top == s->size - 1) {
        return ERROR;
    }
    ++(s->top);
    memcpy(s->data + s->top * s->value_size, value, s->value_size);
    return OK;
}

int __empty_stack(Stack *s) {
    return s->top == -1;
}

int __pop_stack(Stack *s) {
    if (__empty_stack(s)) {
        return ERROR;
    }
    --(s->top);
    return OK;
}

char *__top_stack(Stack *s) {
    if (__empty_stack(s)) {
        return NULL;
    }
    return s->data + s->top * s->value_size;
}

void __clear_stack(Stack *s) {
    free(s->data);
    free(s);
    return ;
}
```



## 基于字典树的 AC 自动机 

```cpp
/*************************************************************************
   > File Name: 19.ac.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日  1/13 20:43:58 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE], *fail;
} Node;

typedef struct Queue {
    Node **data;
    int head, tail, size;
} Queue;

Queue *init_queue(int n) {
    Queue *q = (Queue *)calloc(sizeof(Queue), 1);
    q->data = (Node **)malloc(sizeof(Node *) * n);
    q->tail = q->head = 0;
    return q;
}

Node *front(Queue *q) {
    return q->data[q->head];
}

int empty(Queue *q) {
    return q->head == q->tail;
}

void push(Queue *q, Node *node) {
    q->data[q->tail++] = node;
    return ;
}

void pop(Queue *q) {
    if (empty(q)) return ;
    q->head++;
}

void clear_queue(Queue *q) {
    if (q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *node) {
    if (node == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(node->next[i]);
    }
    free(node);
    return ;
}

void build_ac(Node *root, int n) {
    Queue *q = init_queue(n + 10);
    root->fail = NULL;
    push(q, root);
    while (!empty(q)) {
        Node *now_node = front(q);
        pop(q);
        for (int i = 0; i < BASE; i++) {
            if (now_node->next[i] == NULL) continue;
            Node *p = now_node->fail;
            while (p && p->next[i] == NULL) p = p->fail;
            if (p == NULL) now_node->next[i]->fail = root;
            else now_node->next[i]->fail = p->next[i];
            push(q, now_node->next[i]);
        }
    }
    return ;
}

int match(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        while (p && p->next[ind] == NULL) p = p->fail;
        if (p == NULL) p = root;
        else p = p->next[ind];
        Node *q = p;
        while (q) cnt += q->flag, q = q->fail;
    }
    return cnt;
}

int main() {
    Node *root = getNewNode();
    int n, cnt = 0;
    char str[1000];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        cnt += insert(root, str);
    }
    // build ac
    build_ac(root, cnt);
    scanf("%s", str);
    // match ac
    printf("match word cnt : %d\n", match(root, str));
    return 0;
}
```

## 基于双数组字典树的 AC 自动机

```cpp
/*************************************************************************
   > File Name: 15.Double_Array_Trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 六  8/ 4 15:28:36 2018
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define BASE 26
#define BEGIN_LETTER 'a'
#define max(a, b) ((a) > (b) ? (a) : (b))
#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)

typedef struct DANode {
    int base, check, fail;
    char *str;
} DANode;

typedef struct Node {
    int flag;
    char *str;
    struct Node *next[BASE];
} Node, *Trie;

int node_cnt = 0;

Node *get_new_node() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    node_cnt += 1;
    return p;
}

void clear(Trie root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    if (root->flag) free(root->str);
    free(root);
    return ;
}

Node *insert(Trie root, const char *str) {
    if (root == NULL) root = get_new_node();
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = get_new_node();
        p = p->next[ind];
    }
    p->flag = 1;
    p->str = strdup(str);
    return root;
}

int get_base(Node *node, DANode *data) {
    int base = 2, flag = 0;
    while (!flag) {
        flag = 1;
        for (int i = 0; i < BASE; i++) {
            if (node->next[i] == NULL) continue;
            if (data[base + i].check == 0) continue;
            flag = 0;
            break;
        }
        base += (!flag);
    }
    return base;
}

int build(Node *node, DANode *data, int ind) {
    if (node == NULL) return 0;
    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;
    int max_ind = ind;
    data[ind].base = get_base(node, data);
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        data[data[ind].base + i].check = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (node->next[i] == NULL) continue;
        int temp = build(node->next[i], data, data[ind].base + i);
        max_ind = max(max_ind, temp);
    }
    return max_ind;
}

void build_ac(DANode *data) {
    #define MAX_N 100000
    int *queue = (int *)malloc(sizeof(int) * MAX_N);
    int head = 0, tail = 0;
    data[1].fail = 0;
    queue[tail++] = 1;
    while (head < tail) {
        int ind = queue[head++];
        for (int i = 0; i < BASE; i++) {
            if (!has_child(data, ind, i)) continue;
            int p = data[ind].fail;
            while (p && !has_child(data, p, i)) p = data[p].fail;
            if (p == 0) p = 1;
            else p = data[p].base + i;
            data[data[ind].base + i].fail = p;
            queue[tail++] = data[ind].base + i;
        }
    }
    return ;
    #undef MAX_N
}

void search_ac(DANode *data, const char *str) {
    int p = 1;
    for (int i = 0; str[i]; i++) {
        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;
        if (p == 0) p = 1;
        else p = data[p].base + str[i] - BEGIN_LETTER;
        int q = p;
        while (q) {
            if (data[q].check < 0) printf("find string : %s\n", data[q].str);
            q = data[q].fail;
        }
    }
    return ;  
}

void output_da(DANode *data, int n) {
    for (int i = 1; i <= n; i++) {
        if (i - 1 && i % 5 == 1) printf("\n");
        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);
    }
    printf("\n");
    return ;
}

int main() {
    Trie root = NULL;
    #define INSERT_CNT 5
    root = insert(root, "hai");
    root = insert(root, "zei");
    root = insert(root, "ha");
    root = insert(root, "ab");
    root = insert(root, "ehz");
    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));
    int da_cnt = build(root, data, 1);
    build_ac(data);
    output_da(data, da_cnt);
    search_ac(data, "sasherhs");
    #undef INSERT_CNT 
    return 0;
}
```





## AC 自动机的递归建立

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode* fail, *father;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->fail = NULL;
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
            p->childs[buffer[i] - BASE]->father = p;
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    #define next childs
    #define Node TrieNode
    if (node == NULL) return ;
    if (node->fail == NULL) build_automaton(node->father);
    for (int i = 0; i < SIZE; i++) {
        if (node->next[i] == NULL) continue;
        if (node->next[i]->fail) continue;
        Node *p = node->fail, *pre_p = node;
        while (p && p->next[i] == NULL) {
            if (p->fail == NULL) build_automaton(p->father);
            pre_p = p;
            p = p->fail;
        }
        if (p == NULL) p = pre_p;
        else p = p->next[i];
        node->next[i]->fail = p;
        build_automaton(node->next[i]);
    }
    return ;
    #undef next
    #undef Node
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        while (p && p->childs[str[0] - 'a'] == NULL) p = p->fail;
        if (p == NULL) p = ac_tree;
        else p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        str++;
    }
    return ret;
}

int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```



##  AC 自动机的线索化

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const int SIZE = 26;
const char BASE = 'a';
const int MAX_SIZE = 200000;
const int MAX_LEN = 200000;
char str_buffer[200005];

typedef struct TrieNode {
    int count;
    struct TrieNode** childs;
    struct TrieNode *fail;
} TrieNode, *Trie;

TrieNode* new_node() {
    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);
    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);
    for (int i = 0; i < SIZE; i++) {
        p->childs[i] = NULL;
    }
    p->count = 0;
    return p;
}

void clear(TrieNode *node) {
    if (node == NULL) return ;
    for (int i = 0; i < SIZE; i++) {
        if (node->childs[i] == NULL) continue;
        clear(node->childs[i]);
    }
    free(node->childs);
    free(node);
    return ;
}

void insert(TrieNode *trie, const char *buffer) {
    TrieNode *p = trie;
    for (int i = 0; i < strlen(buffer); i++) {
        if (p->childs[buffer[i] - BASE] == NULL) {
            p->childs[buffer[i] - BASE] = new_node();
        }
        p = p->childs[buffer[i] - BASE];
    }
    p->count++;
    return ;
}

void build_automaton(TrieNode *node) {
    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));
    int head = 0, tail = 0;
    queue[tail++] = node;
    while (head < tail) {
        TrieNode *now = queue[head++];
        for (int i = 0; i < SIZE; i++) {
            if (now->childs[i] == NULL) {
                if (now != node) now->childs[i] = now->fail->childs[i];
                continue;
            }
            TrieNode *p = (now->fail ? now->fail->childs[i] : node);
            if (p == NULL) p = node;
            now->childs[i]->fail = p;
            queue[tail++] = now->childs[i];
        }
    }
    free(queue);
    return ;
}

int match_count(TrieNode *ac_tree, const char *str) {
    int ret = 0;
    TrieNode *p = ac_tree, *q;
    while (str[0]) {
        p = p->childs[str[0] - 'a'];
        q = p;
        while (q) ret += q->count, q = q->fail;
        if (p == NULL) p = ac_tree;
        str++;
    }
    return ret;
}
int main() {
    Trie root = new_node();
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        char pattern[MAX_LEN];
        scanf("%s", pattern);
        insert(root, pattern);
    }
    printf("insert done\n");
    fflush(stdout);
    build_automaton(root);
    scanf("%s", str_buffer);
    printf("%d\n", match_count(root, str_buffer));
    //clear(root);
    return 0;
}
```



## 双数组字典树

```cpp
/*************************************************************************
   > File Name: 12.double_array_trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 三  8/21 14:14:38 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define BASE 26
#define BEGIN_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

typedef struct DATrie {
    int *base, *check;
    int root, size;
} DATrie;

DATrie *getDATrie(int n) {
    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);
    tree->root = 1;
    tree->size = n;
    tree->base = (int *)calloc(sizeof(int), n);
    tree->check = (int *)calloc(sizeof(int), n);
    tree->check[tree->root] = 1;
    return tree;
}

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;
        p = p->next[ind];
    }
    p->flag = 1;
    return cnt;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int getBaseValue(Node *root, DATrie *tree) {
    int base = 0, flag;
    do {
        flag = 1;
        base += 1;
        for (int i = 0; i < BASE; i++) {
            if (root->next[i] == NULL) continue;
            if (tree->check[base + i] == 0) continue;
            flag = 0;
            break;
        }
    } while (!flag);
    return base;
}

int buildDATrie(int ind, Node *root, DATrie *tree) {
    int base = tree->base[ind] = getBaseValue(root, tree);
    int ans = ind;
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        tree->check[base + i] = ind;
    }
    for (int i = 0; i < BASE; i++) {
        if (root->next[i] == NULL) continue;
        int temp = buildDATrie(base + i, root->next[i], tree);
        if (temp > ans) ans = temp;
    }
    if (root->flag) tree->check[ind] = -tree->check[ind];
    return ans;
}

int query(DATrie *tree, const char *str) {
    int p = tree->root;
    for (int i = 0; str[i]; i++) {
        int ind = str[i] - BEGIN_LETTER;
        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;
        p = tree->base[p] + ind;
    }
    return tree->check[p] < 0;
}

void clearDA(DATrie *tree) {
    if (tree == NULL) return ;
    free(tree->base);
    free(tree->check);
    free(tree);
    return ;
}

int main() {
    int n, cnt1 = 1, cnt2;
    char str[100];
    scanf("%d", &n);
    Node *root = getNewNode();
    while (n--) {
        scanf("%s", str);
        cnt1 += insert(root, str);
    }
    DATrie *tree = getDATrie(cnt1 * BASE + 5);
    cnt2 = buildDATrie(tree->root, root, tree) + 1;
    while (~scanf("%s", str)) {
        printf("search %s, result = %s\n", str, query(tree, str) ? "YES" : "NO");
    }
    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;
    printf("Trie memory : %d Bytes\n", mem1);
    printf("Double Array Trie memory : %d Bytes\n", mem2);
    printf("memory rate : %.4lf%%\n", 1.0 * mem2 / mem1 * 100);
    clearDA(tree);
    clear(root);
    return 0;
}
```



## 字典树 

```cpp
 
/*************************************************************************
   > File Name: 11.trie.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 一  8/19 19:11:36 2019
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>

#define BASE 26
#define BASE_LETTER 'a'

typedef struct Node {
    int flag;
    struct Node *next[BASE];
} Node;

Node *getNewNode() {
    Node *p = (Node *)calloc(sizeof(Node), 1);
    return p;
}

inline int code(char ch) {
    return ch - BASE_LETTER;
}

void insert(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();
        p = p->next[code(str[i])];
    }
    p->flag = 1;
    return ;
}

int query(Node *root, char *str) {
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        p = p->next[code(str[i])];
        if (p == NULL) return 0;
    }
    return p->flag;
}

void output(Node *root, int k, char *buff) {
    if (root == NULL) return ;
    if (root->flag) printf("%s\n", buff);
    for (int i = 0; i < BASE; i++) {
        buff[k] = BASE_LETTER + i;
        buff[k + 1] = '\0';
        output(root->next[i], k + 1, buff);
    }
    return ;
}

void clear(Node *root) {
    if (root == NULL) return ;
    for (int i = 0; i < BASE; i++) {
        clear(root->next[i]);
    }
    free(root);
    return ;
}

int main() {
    char str[1000];
    int n;
    Node *root = getNewNode();
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%s", str);
        insert(root, str);
    }
    output(root, 0, str);
    while (~scanf("%s", str)) {
        printf("query %s, result = %s\n", str, query(root, str) ? "Yes" : "No");
    }
    return 0;
}
```



