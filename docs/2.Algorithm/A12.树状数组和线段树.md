---
id : A10.æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘
title : A10.æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘
typora-root-url : ../
---

# æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘

## ä¸€ã€å‰ç¼€å’Œä¸å·®åˆ†

1. åŸæ•°ç»„ï¼š${a_1, a_2,a_3,....,a_n}$
2. å‰ç¼€å’Œï¼š$S_i=\sum_{k=1}^{k=i}{a_i}$ï¼Œ$a_i=S_i-S_{i-1}$
3. å·®åˆ†æ•°ç»„ï¼š$X_i=a_i-a_{i-1}$
4. X æ•°ç»„æ˜¯ a æ•°ç»„çš„å·®åˆ†æ•°ç»„ï¼Œa æ•°ç»„æ˜¯ S æ•°ç»„çš„å·®åˆ†æ•°ç»„
5. S æ•°ç»„æ˜¯ a æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„ï¼Œa æ•°ç»„æ˜¯ X æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„
6. å‰ç¼€å’Œæ•°ç»„ä»¥åŠå·®åˆ†æ•°ç»„ï¼Œå¹¶æ²¡æœ‰å¢åŠ ä¿¡æ¯ï¼Œåªæ˜¯ä¿¡æ¯çš„å¦å¤–ä¸€ç§è¡¨ç¤ºå½¢å¼
7. å‰ç¼€å’Œæ•°ç»„ç”¨æ¥ä¼˜åŒ–åŒºé—´å’Œæ“ä½œ
8. å·®åˆ†æ•°ç»„ç”¨æ¥ä¼˜åŒ–åŒºé—´ä¿®æ”¹æ“ä½œ



### 10.1.1. é—®é¢˜1ï¼šåŸæ•°ç»„åŒºé—´å’Œæ“ä½œ

a æ•°ç»„ä¸Šçš„æ“ä½œï¼š$O(n)$

S æ•°ç»„ä¸Šçš„æ“ä½œï¼š$O(1)ï¼ŒS_i - S_{j-1}=a[j,i]åŒºé—´å’Œ$



### 10.1.2. é—®é¢˜2ï¼šåŸæ•°ç»„åŒºé—´å…ƒç´ ä¿®æ”¹ï¼ˆåŠ æ³•ï¼‰

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



a æ•°ç»„æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

X æ•°ç»„æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

![image-20210131164748767](/Image/A12.æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘-photo/image-20210131164748767.png)

## 10.2. äºŒã€æ ‘çŠ¶æ•°ç»„

1. lowbit å‡½æ•°æ±‚æ•°å­— iï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„æœ€ä½1æ‰€åœ¨çš„ä½æƒ
2. lowbit(x) = x & -x
3. æ ‘çŠ¶æ•°ç»„æœ¬è´¨ä¸Šæ˜¯å¯¹å‰ç¼€å’Œæ•°ç»„çš„ä¸€ç§ä¼˜åŒ–ï¼Œä¸»è¦ä½“ç°åœ¨å•ç‚¹ä¿®æ”¹æ“ä½œä¸Š
4. å‰ç¼€å’ŒæŸ¥è¯¢ $O(logn)$ï¼Œå•ç‚¹ä¿®æ”¹$O(logn)$
5. ç›¸æ¯”äºæœ€æ™®é€šçš„å‰ç¼€å’Œæ•°ç»„ï¼ŒæŸ¥è¯¢æ–¹é¢å˜å·®ï¼Œå•ç‚¹ä¿®æ”¹æ“ä½œå˜å¥½ï¼Œç»¼åˆæ—¶é—´å¤æ‚åº¦å˜å¥½
6. æŸ¥è¯¢çš„æ—¶å€™ï¼Œå‘å‰ç»Ÿè®¡ï¼Œ$i$ çš„å‰ä¸€ä½ $i-lowbit(i)$
7. ä¿®æ”¹çš„æ—¶å€™ï¼Œå‘åä¿®æ”¹ï¼Œ$i$ çš„åä¸€ä½ $i + lowbit(i)$
8. lowbit(i):C[i]ä»£è¡¨å‰lowbit[i]é¡¹çš„å’Œ



## 10.3. ä¸‰ã€æµ·è´¼ OJ-329-å¼±åŒ–çš„æ•´æ•°é—®é¢˜

### 10.3.1. å¼•å…¥å·®åˆ†æ•°ç»„

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$



$\{a_1,a_2+d,a_3+d,a_4+d,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1+d,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4-d,X_6=a_6-a_5\}$



å¼•å…¥å·®åˆ†æ•°ç»„ Xï¼Œå°†åŸæ•°ç»„ a ä¸Šçš„åŒºé—´åŠ æ“ä½œï¼Œè½¬æ¢æˆ X æ•°ç»„ä¸Šçš„ä¸¤æ¬¡ã€å•ç‚¹æ“ä½œã€‘

å¯¹äºæŸ¥è¯¢åŸæ•°ç»„ a[i] çš„å€¼ï¼Œç­‰ä»·äºæŸ¥è¯¢ X æ•°ç»„å‰ i ä½çš„ã€å‰ç¼€å’Œã€‘



### 10.3.2. ç»“è®º

ç”±äºï¼Œæ—¢è¦ç»´æŠ¤ã€å‰ç¼€å’Œã€‘ï¼Œåˆè¦è¿›è¡Œã€å•ç‚¹ä¿®æ”¹ã€‘ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„



![image-20210131164801074](/Image/A12.æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘-photo/image-20210131164801074.png)



## 10.4. å››ã€æµ·è´¼ OJ-330-åŠ å¼ºçš„æ•´æ•°é—®é¢˜

### 10.4.1. å¼•å…¥å·®åˆ†æ•°ç»„

å‚è€ƒ HZOJ-329 çš„è§£æ³•ï¼Œä¸»è¦ä¸ºäº†ç»´æŠ¤åŸæ•°ç»„ä¸Šçš„åŒºé—´ä¿®æ”¹æ“ä½œ

 "C a b c"è¡¨ç¤ºç»™[a, b]åŒºé—´ä¸­çš„å€¼å…¨éƒ¨å¢åŠ c (-10000 â‰¤ c â‰¤ 10000)ã€‚

 "Q a b" è¯¢é—®[a, b]åŒºé—´ä¸­æ‰€æœ‰å€¼çš„å’Œã€‚

### 10.4.2. åŸæ•°ç»„ä¸Šçš„åŒºé—´å’Œé—®é¢˜è½¬åŒ–

$a=\{a_1,a_2,a_3,a_4,a_5,a_6\}$

$X=\{X_1=a_1-a_0,X_2=a_2-a_1,X_3=a_3-a_2,X_4=a_4-a_3,X_5=a_5-a_4,X_6=a_6-a_5\}$

$Query(l, r) = S(r) - S(l - 1)$ï¼Œé‡ç‚¹åˆ†æ S æ€ä¹ˆæ±‚ï¼Œä¼šæ±‚ Sï¼Œä¸‡äº‹å¤§å‰

$S_i= \sum_{k=1}^{i}\sum_{y=1}^{k}{X_y} = \sum_{k=1}{i}{(i + 1)X_k-k*X_k}=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}k*X_k}$

è®¾$Y_i = i \times X_i$

$S_i=(i + 1)\sum_{k=1}^{i}{X_k-\sum_{k=1}^{i}{Y_k}}$



### 10.4.3. ç»“è®º

$S_i$ å¯ä»¥é€šè¿‡ç»´æŠ¤ X ä¸ Y ä¸¤ä¸ªåºåˆ—çš„å‰ç¼€å’Œå¾—åˆ°

æ‰€ä»¥å¯ä»¥é€šè¿‡ç»´æŠ¤ä¸¤ä¸ªä¸å·®åˆ†æ•°ç»„ X ç›¸å…³çš„å‰ç¼€å’Œæ•°ç»„ï¼Œä»è€Œå¾—åˆ°åŸæ•°ç»„ a çš„å‰ç¼€å’Œå€¼

éœ€è¦ç»´æŠ¤ä¸¤ä¸ªï¼šæ ‘çŠ¶æ•°ç»„

![image-20210131164827184](/Image/A12.æ ‘çŠ¶æ•°ç»„å’Œçº¿æ®µæ ‘-photo/image-20210131164827184.png)



```cpp
long long c[2][MAX_N + 5];

void add(long long k, long long i, long long x, long long n) {
    while (i <= n) {
        c[k][i] += x;
        i += lowbit(i);
    }    
    return ;
}

long long query(long long k, long long i) {
    long long sum = 0;
    while (i) {
        sum += c[k][i];
        i -= lowbit(i);
    }
    return sum;
}

long long S(long long i) {
    return (i + 1) * query(0, i) - query(1, i);
}

void modify(long long i, long long x, long long n) {
    add(0, i, x, n);
    add(1, i, i * x, n);
    return ;
}
```





```cpp
#define MAX_N 100000
int c[MAX_N + 5];
inline int lowbit(int x) { return x & (-x); }
void add(int x, int val, int n) {
    while (x <= n) c[x] += val, x += lowbit(x);
}
int query(int x) {
    int sum = 0;
    while (x) sum += c[x], x -= lowbit(x);
    return sum;
}

int main() {
    int n, m, pre = 0, now;
    char str[10];
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> now;
        add(i, now - pre, n);
        pre = now;
    }
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str;
        switch (str[0]) {
            case 'C': {
                int a, b, c;
                cin >> a >> b >> c;
                add(a, c, n);
                add(b + 1, -c, n);
            } break;
            case 'Q': {
                int x;
                cin >> x;
                cout << query(x) << endl;
            }
        }
    }
    return 0;
}
```

####  HZOJ-331-ä¸¢å¤±çš„å¥¶ç‰›

> æœ‰*ğ‘›*nåªå°åŠ¨ç‰©ï¼Œæ¯åªéƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ç¼–å·ï¼Œåˆ†åˆ«ä»11åˆ°*ğ‘›*nã€‚ç°åœ¨ä»–ä»¬ä»å·¦åˆ°å³ä¾æ¬¡æ’åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œé¡ºåºæ˜¯ä¹±çš„ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬åªçŸ¥é“æ¯ä¸ªä½ç½®å‰é¢æœ‰å‡ ä¸ªæ¯”ä»–å°çš„æ•°ã€‚è¯·ä½ æ ¹æ®ç»™å‡ºçš„ä¿¡æ¯è®¡ç®—å‡ºæ¯ä¸ªä½ç½®ä¸Šçš„æ•°æ˜¯å¤šå°‘

1. ç†è§£æ ‡è®°æ•°ç»„ï¼Œæ ‡è®°æ•°ç»„è®°å½•çš„æ˜¯æ¯ä¸€ä¸ªä¸‹æ ‡çŸ¥å¦å¯ç”¨ï¼Œå¯ç”¨ä¸º1ï¼Œä¸å¯ç”¨ä¸º0
2. æ ¹æ®é¢˜æ„ï¼Œæˆ‘ä»¬ä»åå‘å‰ï¼Œä¾æ¬¡ç¡®å®šæ¯ä¸€å¤´å¥¶ç‰›çš„ç¼–å·
3. ä¾‹å¦‚ï¼Œå½“å‰å¥¶ç‰›æ¯”ä»–å‰é¢çš„2ä¸ªå¥¶ç‰›ç¼–å·å¤§çš„è¯ï¼Œå½“å‰å¥¶ç‰›çš„ç¼–å·å°±æ˜¯å½“å‰å‰©ä½™å¯ç”¨ç¼–å·ä¸­çš„ç¬¬ä¸‰å¤§çš„ç¼–å·
4. å¦‚ä½•æ‰¾åˆ°å¯ç”¨çš„ç¬¬ x å¤§çš„ç¼–å·ï¼Œå¯ä»¥åœ¨æ ‡è®°æ•°ç»„çš„å‰ç¼€å’Œæ•°ç»„ä¸ŠåšäºŒåˆ†æŸ¥æ‰¾
5. è®¾è®¡åˆ°æ ‡è®°æ•°ç»„çš„å‰ç¼€å’Œç»´æŠ¤å’Œå•ç‚¹æ›´æ–°ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„
6. æ—¶é—´å¤æ‚åº¦ï¼š$O(nlogn)$

```cpp
int n;
int ind[MAX_N + 5];
int cnt[MAX_N + 5];

void read() {
    cin >> n;
    ind[1] = 0;
    for (int i = 2; i <= n; ++i) cin >> cnt[i];
    for (int i = 1; i <= n; ++i) {
        add(i, 1, n);
    }
    return ;
}

int binary_search(int n, int x) {
    int head = 1, tail = n, mid;
    while (head < tail) {
        mid = (head + tail) >> 1;
        if (query(mid, n) < x) head = mid + 1;
        else tail = mid;
    }
    return head;
}

void solve() {
    for (int i = n; i >= 1; --i) {
        ind[i] = binary_search(n, cnt[i] + 1);
        add(ind[i], -1, n);
    }
    return ;
}

void output() {
    for (int i = 1; i <= n; ++i) {
        cout << ind[i] << endl;
    }
    return ;
}
```





ç›¸ä¼¼é—®é¢˜ï¼šæµ·è´¼ OJ-332-ä¹°ç¥¨



#### HZOJ-328-æ¥¼å…°å›¾è…¾

1. æ±‚åœ¨å½“å‰ä½ç½®ä¹‹å‰ï¼Œå°äºå½“å‰ä½ç½®å€¼çš„å…ƒç´ æ•°é‡ï¼Œå½“å‰å…ƒç´ å€¼è®°ä¸º Xï¼Œå…ƒç´ æ•°é‡è®°ä¸º aï¼Œå…ƒç´ ä½ç½®è®°ä¸º i
2. å‰é¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯ $a$
3. åé¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯$X - a - 1$
4. å‰é¢å¤§äº $X$ çš„å…ƒç´ æ•°é‡ $i - a - 1$
5. åé¢å¤§äºX çš„å…ƒç´ æ•°é‡$n-X-i+a+1$
6. è§£é¢˜å…³é”®ï¼šå‰é¢å°äº $X$ çš„å…ƒç´ æ•°é‡æ˜¯ $a$
7. æ ‡è®°æ•°ç»„ï¼Œè®°å½•å½“å‰ä½ç½®ä¹‹å‰æœ‰å“ªäº›å…ƒç´ å‡ºç°è¿‡ï¼Œå‡ºç°è¿‡æ ‡è®°ä¸º 1ï¼Œå¦åˆ™æ ‡è®°ä¸º 0
8. $a$ ç­‰äºæ ‡è®°æ•°ç»„åœ¨ $X$ ä½ç½®ä¹‹å‰çš„å‰ç¼€å’Œ
9. å¯¹äºæ ‡è®°æ•°ç»„çš„å•ç‚¹ä¿®æ”¹åŠå‰ç¼€å’ŒæŸ¥è¯¢ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ ‘çŠ¶æ•°ç»„



```cpp
void solve(long long &x, long long &y) {
    x = y = 0;
    for (long long i = 1; i <= n; ++i) {
        long long a1 = query(val[i], n);
        long long a2 = val[i] - a1 - 1;
        long long b1 = i - a1 - 1;
        long long b2 = n - val[i] - b1;
        x += b1 * b2;
        y += a1 * a2;
        add(val[i], 1, n);
    }  
}
```





#### HZOJ-333-åŒºé—´æœ€å¤§å­æ®µå’Œ

1. çº¿æ®µæ ‘æœ‰ç‚¹ç‚¹å„¿éš¾åº¦çš„é¢˜ç›®
2. æ¯ä¸ªèŠ‚ç‚¹ï¼šåŒºé—´å’Œå€¼ï¼Œæœ€å¤§å­æ®µå’Œå€¼ï¼Œå·¦ä¾§æœ€å¤§å­æ®µå’Œï¼Œå³ä¾§æœ€å¤§å­æ®µå’Œ
3. ç‰¹æ®Šæ€§è´¨ï¼šé€’å½’éå†æ—¶ï¼Œæ˜¯æŒ‰ç…§ä¸‹æ ‡é¡ºåºå¾—åˆ°çš„æ¯ä¸€ä¸ªæŸ¥è¯¢åŒºé—´å†…çš„çº¿æ®µæ ‘çš„èŠ‚ç‚¹
4. $|â‘ â‘¡â‘¢â‘£â‘¤|$ï¼Œå°±æ˜¯æŒ‰ç…§â‘ â‘¡â‘¢â‘£â‘¤çš„é¡ºåºéå†å¾—åˆ°çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹
5. ä»£ç æœ‰ç‚¹å„¿å¤æ‚ï¼Œå­¦ä¼šäº†ï¼Œä»£ç æ€ç»´ä¼šæ›´ä¸Šä¸€å±‚æ¥¼

## 10.8.  

```cpp
#define MAX_N 500000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define SUM(ind) tree[ind].sum
#define MAX(ind) tree[ind].m
#define LMAX(ind) tree[ind].lm
#define RMAX(ind) tree[ind].rm

struct node {
    int sum, m, lm, rm;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 3, cnt = 4, ans = 0, temp = 1;
int arr[MAX_N + 5];
inline int getNode() { return cnt++; }

void UP(int a, int b, int c) {
    SUM(a) = SUM(b) + SUM(c);
    LMAX(a) = max(LMAX(b), SUM(b) + LMAX(c));
    RMAX(a) = max(RMAX(c), SUM(c) + RMAX(b));
    MAX(a) = max(MAX(b), MAX(c));
    MAX(a) = max(MAX(a), RMAX(b) + LMAX(c));
    return ;
}

void UP(int ind) {
    UP(ind, lc(ind), rc(ind));
}

void build(int ind, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    lc(ind) = getNode();
    rc(ind) = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = y;
        
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, l, mid);
    else modify(rc(ind), x, y, mid + 1, r);
    UP(ind);
    return ;
}

void query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        if (x == l) tree[ans] = tree[ind];
        else {
            UP(temp, ans, ind);
            swap(temp, ans);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) query(lc(ind), x, y, l, mid);
    if (y > mid) query(rc(ind), x, y, mid + 1, r);
    return ;
}

ostream &operator<<(ostream &out, node &a) {
    out << (&a - tree) << " : " << a.sum << " " << a.m << " " << a.lm << " " << a.rm;
    out << "(" << a.lind << "," << a.rind << ")";
    return out;
}

void output(int n) {
    for (int i = root; i < root + 2 * n - 1; i++) {
        cout << tree[i] << endl;
    }
    cout << "---------" << endl;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            if (b > c) swap(b, c);
            query(root, b, c, 1, n);
            cout << MAX(ans) << endl;
        } else {
            modify(root, b, c, 1, n);
        }
        //output(n);
    }
    return 0;
}
```

# 11. ==çº¿æ®µæ ‘==

çº¿æ®µæ ‘â€”å…³é”®è¯
å®Œå…¨äºŒå‰æ ‘:çº¿æ®µæ ‘ç¨‹åºå®ç°æ—¶å€™çš„å®é™…å­˜å‚¨ç»“æ„
åŒºé—´:çº¿æ®µæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æ‰€ç»´æŠ¤çš„èŒƒå›´
å‘ ä¸Š æ›´ æ–°:ç”¨ä¸¤ä¸ªå­èŠ‚ç‚¹çš„ä¿¡æ¯æ›´æ–°æœ¬èŠ‚ç‚¹çš„ä¿¡æ¯
ä¸‹ æ²‰ æ ‡ è®°:å°†æœ¬èŠ‚ç‚¹çš„æ‡’æƒ°æ ‡è®°æ›´æ–°ç»™ä¸¤ä¸ªå­èŠ‚ç‚¹
å£è¯€:ä¸‹æ²‰å‘ç”Ÿåœ¨é€’å½’ä¹‹å‰,å‘ä¸Šå‘ç”Ÿåœ¨é€’å½’ä¹‹å



çº¿æ®µ æ ‘æ˜¯ä¸€ æ£µå®Œç¾ äºŒå‰æ ‘ ï¼ˆPerfect Binaiy Tree)(æ‰€æœ‰ çš„å¶å­ çš„æ·±åº¦ éƒ½ç›¸åŒ ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯å¶å­è¦ä¹ˆæœ‰2 ä¸ªå„¿å­çš„æ ‘ )ï¼Œ æ ‘ä¸Š çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½
ç»´æŠ¤ä¸€ä¸ªåŒºé—´ ã€‚æ ¹ç»´æŠ¤çš„æ˜¯æ•´ ä¸ªåŒºé—´ ï¼Œæ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤çš„æ˜¯çˆ¶äº²çš„åŒºé—´äºŒç­‰åˆ†åçš„å…¶ä¸­ä¸€ä¸ªå­ åŒºé—´ã€‚

## 11.1. ä¸€ã€é—®é¢˜èƒŒæ™¯

1. å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ˆåŸºç¡€ç‰ˆï¼‰
2. åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ï¼ˆè¿›é˜¶ç‰ˆï¼‰
3. å•ç‚¹ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ˆç”¨ä¸ç€çº¿æ®µæ ‘ï¼‰
4. åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢ï¼ˆæ˜¯ç¬¬äºŒç§æƒ…å†µçš„ç‰¹ä¾‹ï¼‰



## 11.2. äºŒã€åŸºç¡€ç‰ˆçº¿æ®µæ ‘

1. çº¿æ®µæ ‘æ˜¯å¯¹äºä¸€ç»´åºåˆ—çš„ä¸€ç§ç»´æŠ¤ç»“æ„

2. é‡‡ç”¨çš„åˆ†æ²»çš„æ€æƒ³ï¼Œå°†æ€»åŒºé—´åˆ†æˆå·¦å³ä¸¤éƒ¨åˆ†ï¼Œä¸€ç›´è¿›è¡Œä¸‹å»ï¼Œç›´åˆ°åŒºé—´ä¸­åªå‰©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ­¢

3. çº¿æ®µæ ‘çš„å¶å­ç»“ç‚¹ï¼Œä»£è¡¨äº†åŸåºåˆ—ä¸­çš„å•ä¸ªä½ç½®çš„å€¼

4. å¦‚æœé‡‡ç”¨å®Œå…¨äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„çš„è¯ï¼Œæœ€èµ·ç éœ€è¦ $4n$ çš„å­˜å‚¨ç©ºé—´

5. å½“é¢å¯¹åŒºé—´ä¿®æ”¹çš„æ—¶å€™ï¼ŒåŸºç¡€ç‰ˆçš„çº¿æ®µæ ‘æ•ˆç‡ä¸Šè¿˜ä¸å¦‚ç›´æ¥åœ¨ä¸€ç»´åºåˆ—ä¸Šä¿®æ”¹

6. åªé€‚ç”¨äºå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢

   ```cpp
   #define MAX_N 10000
   #define lc(ind) (ind << 1)
   #define rc(ind) (ind << 1 | 1)
   
   struct node {
       int sum;
   } tree[(MAX_N << 2) + 5];
   int root = 1;
   int arr[MAX_N + 5];
   
   void UP(int ind) {
       tree[ind].sum = max(tree[lc(ind)].sum, tree[rc(ind)].sum);
       return ;
   }
   
   void build(int ind, int l, int r) {
       if (l == r) {
           tree[ind].sum = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build(lc(ind), l, mid);
       build(rc(ind), mid + 1, r);
       UP(ind);
       return ;
   }
   
   void modify(int ind, int x, int y, int l, int r) {
       if (l == r) {
           tree[ind].sum = y;
           return ;
       }
       int mid = (l + r) >> 1;
       if (x <= mid) modify(lc(ind), x, y, l, mid);
       else modify(rc(ind), x, y, mid + 1, r);
       UP(ind);
       return ;
   }
   
   int query(int ind, int x, int y, int l, int r) {
       if (x <= l && r <= y) {
           return tree[ind].sum;
       }
       int ans = 0x80000000, mid = (l + r) >> 1;
       if (x <= mid) ans = max(ans, query(lc(ind), x, y, l, mid));
       if (y > mid) ans = max(ans, query(rc(ind), x, y, mid + 1, r));
       return ans;
   }
   
   int main() {
       int n, m;
       cin >> n >> m;
       for (int i = 1; i <= n; i++) cin >> arr[i];
       build(root, 1, n);
       for (int i = 0; i < m; i++) {
           int a, b, c;
           cin >> a >> b >> c;
           if (a == 1) modify(root, b, c, 1, n);
           else {
               cout << query(root, b, c, 1, n) << endl;
           }
       }
       return 0;
   }
   ```

   ```cpp
   #define MAX_N 10000
   struct {
       int max_num;
       int l, r;
   } tree[MAX_N << 2];
   int arr[MAX_N + 5];
   
   void update(int ind) {
       tree[ind].max_num = max(tree[ind << 1].max_num, tree[ind << 1 | 1].max_num);
       return ;
   }
   
   void build_tree(int ind, int l, int r) {
       tree[ind].l = l, tree[ind].r = r;
       if (l == r) {
           tree[ind].max_num = arr[l];
           return ;
       }
       int mid = (l + r) >> 1;
       build_tree(ind * 2, l, mid);
       build_tree(ind * 2 + 1, mid + 1, r);
       update(ind);
       return ;
   }
   
   void modify(int ind, int k, int val) {
       if (tree[ind].l == tree[ind].r) {
           tree[ind].max_num = val;
           return ;
       }
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (k <= mid) {
           modify(ind << 1, k, val);
       } else {
           modify(ind << 1 | 1, k, val);
       }
       update(ind);
       return ;
   }
   
   int query(int ind, int x, int y) {
       if (tree[ind].l >= x && tree[ind].r <= y) {
           return tree[ind].max_num;
       }
       int ans = INT_MIN;
       int mid = (tree[ind].l + tree[ind].r) >> 1;
       if (mid >= x) {
           ans = max(ans, query(ind << 1, x, y));
       }
       if (mid < y) {
           ans = max(ans, query(ind << 1 | 1, x, y));
       }
       return ans;
   }
   ```

   

   



## 11.3. ä¸‰ã€è¿›é˜¶ç‰ˆçº¿æ®µæ ‘

1. ä¼˜åŒ–æ‰äº†ä»£ç å®ç°ä¸­çš„ï¼šlï¼Œrã€‚åŒºé—´å˜é‡
2. å¯ä»¥ç”¨äºåŒºé—´æ›´æ–°ï¼ŒåŒºé—´æŸ¥è¯¢
3. å¢åŠ äº†æ‡’æ ‡è®°ï¼Œè¾¾åˆ°èƒ½å¤ŸåŒºé—´æ›´æ–°çš„ç›®çš„
4. æ‡’æ ‡è®°æ˜¯éœ€è¦å‘ä¸‹ä¸‹æ²‰çš„
5. æ ‡è®°ä¸‹æ²‰å‘ç”Ÿåœ¨é€’å½’ä¹‹å‰ï¼Œå‘ä¸Šæ›´æ–°å‘ç”Ÿåœ¨å…·æœ‰ä¿®æ”¹æ“ä½œçš„é€’å½’ä¹‹å

```cpp
#define MAX_N 10000
#define define_mid long long mid = (l + r) >> 1

long long flag = 0;
struct {
    long long sum, tag;
} tree[MAX_N << 2];
long long arr[MAX_N + 5];

void update(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    return ;
}

void down(long long ind, long long l, long long r) {
    if (tree[ind].tag) {
        long long val = tree[ind].tag;
        define_mid;
        tree[ind << 1].sum += val * (mid - l + 1);
        tree[ind << 1].tag += val;
        tree[ind << 1 | 1].sum += val * (r - mid);
        tree[ind << 1 | 1].tag += val;
        tree[ind].tag = 0;
    }
    return ;
}

void build_tree(long long ind, long long l, long long r) {
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    define_mid;
    build_tree(ind << 1, l, mid);
    build_tree(ind << 1 | 1, mid + 1, r);
    update(ind);
    return ;
}

void modify(long long ind, long long l, long long r, long long x, long long y, long long val) {
    flag && printf("modify(%lld, %lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, val, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        tree[ind].sum += val * (r - l + 1);
        tree[ind].tag += val;
        return ;
    }
    down(ind, l, r);
    define_mid;
    if (mid >= x) {
        modify(ind << 1, l, mid, x, y, val);
    }
    if (mid < y) {
        modify(ind << 1 | 1, mid + 1, r, x, y, val);
    }
    update(ind);
    return ;
}

long long query(long long ind, long long l, long long r, long long x, long long y) {
    flag && printf("query(%lld, %lld) : %lld, %lld, %lld, %lld\n",
        x, y, ind, l, r, tree[ind].sum
    );
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    down(ind, l, r);
    define_mid;
    long long ans = 0;
    if (mid >= x) {
        ans += query(ind << 1, l, mid, x, y);
    }
    if (mid < y) {
        ans += query(ind << 1 | 1, mid + 1, r, x, y);
    }
    return ans;
}

int main() {
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (long long i = 1; i <= n; i++) {
        scanf("%lld", arr + i);
    }
    build_tree(1, 1, n);
    long long a, b, c, d;
    for (long long i = 0; i < m; i++) {
        scanf("%lld%lld%lld", &a, &b, &c);
        switch (a) {
            case 1: {
                scanf("%lld", &d);
                modify(1, 1, n, b, c, d);
            } break;
            case 2: {
                if (b > c) {
                    printf("0\n");
                    break;
                }
                printf("%lld\n", query(1, 1, n, b, c));
            } break;
        }
    }
    return 0;
}
```





```cpp
#define MAX_N 10000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define tag(ind) tree[ind].tag
#define sum(ind) tree[ind].sum
#define cnt(ind) tree[ind].cnt

struct node {
    long long sum, tag, cnt;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 0, cnt = 1;
long long arr[MAX_N + 5];
int getNode() { return cnt++; }

void DOWN(int ind) {
    if (tag(ind)) {
        tag(lc(ind)) += tag(ind);
        tag(rc(ind)) += tag(ind);
        sum(lc(ind)) += tag(ind) * cnt(lc(ind));
        sum(rc(ind)) += tag(ind) * cnt(rc(ind));
        tag(ind) = 0;
    }
    return ;
}

void UP(int ind) {
    tree[ind].sum = tree[lc(ind)].sum + tree[rc(ind)].sum;
}

void build(int ind, int l, int r) {
    tree[ind].cnt = (r - l + 1);
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    tree[ind].lind = getNode();
    tree[ind].rind = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, long long d, int l, int r) {
    if (x <= l && r <= y) {
        tree[ind].tag += d;
        tree[ind].sum += d * tree[ind].cnt;
        return ;
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, d, l, mid);
    if (y > mid) modify(rc(ind), x, y, d, mid + 1, r);
    UP(ind);
    return ;
}

long long query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        return sum(ind);
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    long long ans = 0;
    if (x <= mid) ans += query(lc(ind), x, y, l, mid);
    if (y > mid) ans += query(rc(ind), x, y, mid + 1, r);
    return ans;
}
```





#### HZOJ224 å¤åˆçº¿æ®µæ ‘

```cpp
#define MAX_N 100000
struct Node {
    long long sum, t1, t2;
} tree[(MAX_N << 2) + 5];
long long a[MAX_N + 5];
long long n, m, p;

void mul_tag(long long ind, long long x) {
    tree[ind].sum *= x;
    tree[ind].sum %= p;
    tree[ind].t1 *= x;
    tree[ind].t1 %= p;
    tree[ind].t2 *= x;
    tree[ind].t2 %= p;
    return ;
}

void add_tag(long long ind, long long x, long long n) {
    tree[ind].sum += x * n;
    tree[ind].sum %= p;
    tree[ind].t2 += x;
    tree[ind].t2 %= p;
    return ;
}

void UP(long long ind) {
    tree[ind].sum = tree[ind << 1].sum + tree[ind << 1 | 1].sum;
    tree[ind].sum %= p; 
    return ;
}

void DOWN(long long ind, long long l, long long r) {
    if (tree[ind].t1 - 1 || tree[ind].t2) {
        long long a = tree[ind].t1, b = tree[ind].t2;
        long long mid = (l + r) >> 1;
        mul_tag(ind << 1, a);
        mul_tag(ind << 1 | 1, a);
        add_tag(ind << 1, b, mid - l + 1);
        add_tag(ind << 1 | 1, b, r - mid);
        tree[ind].t1 = 1;
        tree[ind].t2 = 0;
    }
    return ;
}

void build(long long ind, long long l, long long r) {
    tree[ind].t1 = 1; tree[ind].t2 = 0;
    if (l == r) {
        tree[ind].sum = a[l];
        return ;
    }
    long long mid = (l + r) >> 1;
    build(ind << 1, l, mid);
    build(ind << 1 | 1, mid + 1, r);
    UP(ind);
    return ;
}

void modify(long long ind, long long flag, long long x, long long y, long long val, long long l, long long r) {
    if (x <= l && r <= y) {
        if (flag == 0) {
            mul_tag(ind, val);
        } else {
            add_tag(ind, val, r - l + 1);
        }
        return ;
    }
    long long mid = (l + r) >> 1;
    DOWN(ind, l, r);
    if (x <= mid) modify(ind << 1, flag, x, y, val, l, mid);
    if (y > mid) modify(ind << 1 | 1, flag, x, y, val, mid + 1, r);
    UP(ind);
    return ;
}

long long query(long long ind, long long x, long long y, long long l, long long r) {
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    long long mid = (l + r) >> 1;
    long long ans = 0;
    DOWN(ind, l, r);
    if (x <= mid) ans += query(ind << 1, x, y, l, mid);
    ans %= p;
    if (y > mid) ans += query(ind << 1 | 1, x, y, mid + 1, r);
    ans %= p;
    UP(ind);
    return ans;
}

int main() {
    cin >> n >> m >> p;
    for (long long i = 1; i <= n; i++) cin >> a[i];
    build(1, 1, n);
    long long op, x, y, k;
    for (long long i = 0; i < m; i++) {
        cin >> op >> x >> y;
        switch (op) {
            case 1: 
            case 2: {
                cin >> k;
                modify(1, op - 1, x, y, k, 1, n);
            } break;
            case 3: {
                cout << query(1, x, y, 1, n) << endl;
            } break;
        }
    }
    return 0;
}
```





ä¹  é¢˜ ä½œ ä¸š
Luogu P3372 Luogu P3373
Luogu P3924 Luogu P1047
Luogu P1168 Luogu P1204
Luogu P1276 Luogu P1438
Luogu P1442 Luogu P1471
Luogu P1531 Luogu P1533
Luogu P1558 Luogu P1637
Luogu P1816 Luogu P25





### åˆ†æ¡¶æ³•å’Œå¹³æ–¹åˆ†å‰²

åˆ†æ¡¶æ³• ï¼ˆ bucket method ) æ˜¯ æŠŠä¸€æ’ç‰©å“æˆ–è€…å¹³é¢åˆ†æˆæ¡¶ ï¼Œæ¯ä¸ªæ¡¶åˆ†åˆ«ç»´æŠ¤è‡ªå·±å†…éƒ¨çš„ä¿¡æ¯ ï¼Œä»¥è¾¾åˆ°é«˜æ•ˆ è®¡ç®—çš„ ç›®çš„çš„ æ–¹æ³•ã€‚



##  

```cpp
/*************************************************************************
   > File Name: 222.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å…­  8/24 19:29:40 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 10000
#define lc(ind) (ind << 1)
#define rc(ind) (ind << 1 | 1)

struct node {
    int sum;
} tree[(MAX_N << 2) + 5];
int root = 1;
int arr[MAX_N + 5];

void UP(int ind) {
    tree[ind].sum = max(tree[lc(ind)].sum, tree[rc(ind)].sum);
    return ;
}

void build(int ind, int l, int r) {
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, int l, int r) {
    if (l == r) {
        tree[ind].sum = y;
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, l, mid);
    else modify(rc(ind), x, y, mid + 1, r);
    UP(ind);
    return ;
}

int query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        return tree[ind].sum;
    }
    int ans = 0x80000000, mid = (l + r) >> 1;
    if (x <= mid) ans = max(ans, query(lc(ind), x, y, l, mid));
    if (y > mid) ans = max(ans, query(rc(ind), x, y, mid + 1, r));
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) modify(root, b, c, 1, n);
        else {
            cout << query(root, b, c, 1, n) << endl;
        }
    }
    return 0;
}
```



## lowbit

##  

```cpp
/*************************************************************************
   > File Name: 329.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å››  8/22 20:39:12 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 100000
int c[MAX_N + 5];
inline int lowbit(int x) { return x & (-x); }
void add(int x, int val, int n) {
    while (x <= n) c[x] += val, x += lowbit(x);
}
int query(int x) {
    int sum = 0;
    while (x) sum += c[x], x -= lowbit(x);
    return sum;
}

int main() {
    int n, m, pre = 0, now;
    char str[10];
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> now;
        add(i, now - pre, n);
        pre = now;
    }
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> str;
        switch (str[0]) {
            case 'C': {
                int a, b, c;
                cin >> a >> b >> c;
                add(a, c, n);
                add(b + 1, -c, n);
            } break;
            case 'Q': {
                int x;
                cin >> x;
                cout << query(x) << endl;
            }
        }
    }
    return 0;
}
```



## åŠ¨æ€åˆ›å»ºçº¿æ®µæ ‘èŠ‚ç‚¹



```cpp
/*************************************************************************
   > File Name: 223.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å…­  8/24 20:14:12 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 10000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define tag(ind) tree[ind].tag
#define sum(ind) tree[ind].sum
#define cnt(ind) tree[ind].cnt

struct node {
    long long sum, tag, cnt;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 0, cnt = 1;
long long arr[MAX_N + 5];
int getNode() { return cnt++; }

void DOWN(int ind) {
    if (tag(ind)) {
        tag(lc(ind)) += tag(ind);
        tag(rc(ind)) += tag(ind);
        sum(lc(ind)) += tag(ind) * cnt(lc(ind));
        sum(rc(ind)) += tag(ind) * cnt(rc(ind));
        tag(ind) = 0;
    }
    return ;
}

void UP(int ind) {
    tree[ind].sum = tree[lc(ind)].sum + tree[rc(ind)].sum;
}

void build(int ind, int l, int r) {
    tree[ind].cnt = (r - l + 1);
    if (l == r) {
        tree[ind].sum = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    tree[ind].lind = getNode();
    tree[ind].rind = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, long long d, int l, int r) {
    if (x <= l && r <= y) {
        tree[ind].tag += d;
        tree[ind].sum += d * tree[ind].cnt;
        return ;
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, d, l, mid);
    if (y > mid) modify(rc(ind), x, y, d, mid + 1, r);
    UP(ind);
    return ;
}

long long query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        return sum(ind);
    }
    DOWN(ind);
    int mid = (l + r) >> 1;
    long long ans = 0;
    if (x <= mid) ans += query(lc(ind), x, y, l, mid);
    if (y > mid) ans += query(rc(ind), x, y, mid + 1, r);
    return ans;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        long long a, b, c, d;
        cin >> a >> b >> c;
        if (a == 1) {
            cin >> d;
            modify(root, b, c, d, 1, n);
        } else {
            cout << query(root, b, c, 1, n) << endl;
        }
    }
    return 0;
}
```





## åŒºé—´ä¿®æ”¹



```cpp
/*************************************************************************
   > File Name: 333.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: å…­  8/24 20:52:55 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;
#define MAX_N 500000
#define lc(ind) (tree[ind].lind)
#define rc(ind) (tree[ind].rind)
#define SUM(ind) tree[ind].sum
#define MAX(ind) tree[ind].m
#define LMAX(ind) tree[ind].lm
#define RMAX(ind) tree[ind].rm

struct node {
    int sum, m, lm, rm;
    int lind, rind;
} tree[(MAX_N << 1) + 5];
int root = 3, cnt = 4, ans = 0, temp = 1;
int arr[MAX_N + 5];
inline int getNode() { return cnt++; }

void UP(int a, int b, int c) {
    SUM(a) = SUM(b) + SUM(c);
    LMAX(a) = max(LMAX(b), SUM(b) + LMAX(c));
    RMAX(a) = max(RMAX(c), SUM(c) + RMAX(b));
    MAX(a) = max(MAX(b), MAX(c));
    MAX(a) = max(MAX(a), RMAX(b) + LMAX(c));
    return ;
}

void UP(int ind) {
    UP(ind, lc(ind), rc(ind));
}

void build(int ind, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = arr[l];
        return ;
    }
    int mid = (l + r) >> 1;
    lc(ind) = getNode();
    rc(ind) = getNode();
    build(lc(ind), l, mid);
    build(rc(ind), mid + 1, r);
    UP(ind);
    return ;
}

void modify(int ind, int x, int y, int l, int r) {
    if (l == r) {
        SUM(ind) = MAX(ind) = LMAX(ind) = RMAX(ind) = y;
        
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) modify(lc(ind), x, y, l, mid);
    else modify(rc(ind), x, y, mid + 1, r);
    UP(ind);
    return ;
}

void query(int ind, int x, int y, int l, int r) {
    if (x <= l && r <= y) {
        if (x == l) tree[ans] = tree[ind];
        else {
            UP(temp, ans, ind);
            swap(temp, ans);
        }
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) query(lc(ind), x, y, l, mid);
    if (y > mid) query(rc(ind), x, y, mid + 1, r);
    return ;
}

ostream &operator<<(ostream &out, node &a) {
    out << (&a - tree) << " : " << a.sum << " " << a.m << " " << a.lm << " " << a.rm;
    out << "(" << a.lind << "," << a.rind << ")";
    return out;
}

void output(int n) {
    for (int i = root; i < root + 2 * n - 1; i++) {
        cout << tree[i] << endl;
    }
    cout << "---------" << endl;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    build(root, 1, n);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        if (a == 1) {
            if (b > c) swap(b, c);
            query(root, b, c, 1, n);
            cout << MAX(ans) << endl;
        } else {
            modify(root, b, c, 1, n);
        }
        //output(n);
    }
    return 0;
}
```

