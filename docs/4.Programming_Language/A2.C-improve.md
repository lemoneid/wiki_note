---
id : A2.Cimprove
title : A2.Cimprove
typora-root-url : ../
---
# C语言进阶
[TOC]



## C-improve

## 基础知识

### `for`的执行过程

```cpp
{
	初始化语句
	while ( 条件 ) {
		语句
		迭代表达式 ;
	}
}
```

#### 无条件跳转

无条件跳转: break, continue, gotoprintf、scanf拓展

goto 仅在函数内跳转，常⽤用于跳出嵌套循环。如果在函数外跳转，可使⽤用 longjmp。

setjmp 将当前位置的相关信息 (堆栈帧、寄存器等) 保存到 jmp_buf 结构中，并返回 0。当后续代
码执⾏行 longjmp 跳转时，需要提供⼀一个状态码。代码执⾏行绪将返回 setjmp 处，并返回 longjmp所提供的状态码。

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <setjmp.h>
void test(jmp_buf *env)
{
    printf("1....\n");
    longjmp(*env, 10);
}
int main(int argc, char *argv[])
{
    jmp_buf env;
    int ret = setjmp(env);
        // 执⾏行 longjmp 将返回该位置，ret 等于 longjmp 所提供的状态码。
    if (ret == 0) {
        test(&env);
    } else {
        printf("2....(%d)\n", ret);
    }
    return EXIT_SUCCESS;
}
//输出 : 1.... 2....(10)
```





### 输入输出函数

`printf` 函数 ；


```c
int printf(const char *format, ...);   //原型：
```

​	` format`：格式控制**字符串**；
​    	`...` :可变参数列表；返回值：输出字符的个数；

​    `printf("%2.2d\n", n);  `  %\*.*d;%g 更人性化

**printf()函数里要输出的各变量表达式是从右往左顺序执行的!**

- `sprintf`  : string printf

```c 
int sprintf(char *string, char *format [,argument,...]); 	//原型
  sprintf(information,"%s. He is %d-year-old",gender,age); 	//实例
```

- `fprintf` : file printf



`scanf`函数；

```c
int scanf(const char *format, ...);   //原型：
```

返回值：成功读入的参数个数; 循环读入:`while(scanf("")! = EOF)`，EOF = -1，`EOF = end of file`   ；



**字符匹配集(正则表达式)**

 	`%[^\n]s`  匹配[]内的内容;  

​	 [\^\n] 异或\n:匹配除了\n,任意字符都当做字符串的内容去读入包括空格. 

```c
#include <stdio.h>
int main() {
    char str[100] = {0};
    int ret;                                 
    //数据以流的方式读入, 找bug 可通过重定向  > output
    while ((ret = scanf("%[^\n]s", str)) != EOF) {  //例如输入 hello world\n    检查字符的指针会一直停在 \n, 第一次 scanf返回值为1,以后均为0,所以会持续输出 hello world
        getchar();  //强制读入一个字符,此处为了读入\n,结束
        printf(" has %d digits\n", printf("%s", str));
    }
    return 0;
}
```

### 宏定义

```c
#define swap(a, b) {\                 //  \ 为连接符,连成一行 , 宏在预处理阶段进行
 	--typeof(a)__temp = a;\
	a = b; b = --temp; \
}
```

`sprintf`和`fprintf` 演示

```c
#include <stdio.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}
int main() {
    int n;
    scanf("%d", &n); //stdin
    printf("%d\n", n); //stdout  stderr
    char str[100] = {0}, buffer[100] = {0}, *p = str, *q = buffer;
    sprintf(str, "%d.%d.%d.%d", 192, 168, 1, 10); // 192 168 1 10
    printf("str = %s\n", str);
    if (n & 1) {
        sprintf(q, "(%s)", p);
        swap(q, p);
    }
    if (n & 2) {
        sprintf(q, "[%s]", p);
        swap(q, p);
    }
    if (n & 4) {
        sprintf(q, "{%s}", p);
        swap(q, p);
    }
    printf("%s\n", p);
    FILE *fout = fopen("output", "w");  // r    a+   读写追加
    fprintf(stdout, "stdout = %s\n", p);
    fprintf(stderr, "stderr = %s\n", p);   //在输出重定向时,stdout会重定向,stderr不会重定向,而会打印在终端.
    return 0;
}
```





### 运算符优先级、结合顺序

`(*p)--`;`--*p`;



>1. 初等单目一二级， // 初等运算符`[]().->`和单目运算符分别是第1、2优先级
>
>2. 乘除求余加减移， // 这句里面的运算符全归为算术运算符，移表示移位
>
>3. 关系等于不等于， // 关系运算符（<  <=  >  >=）
>
>4. 按位与来异或或， // 位运算符优先级顺序: & -> ^ -> |
>
>5. 逻辑与或条件弱， // 逻辑运算符优先级顺序: && -> ||，后面跟着优先级比较低(弱)的条件运算符
>
>6. 赋值逗号一点破。 // 赋值，逗号最低：逗号运算的结合性是从左至右，完毕之后整个表达式的值是最后一个表达式的值
>
>   单目，条件，赋值，右到左

| 类型 | 符号 | 结合律|
| ---- | ---- | ---- |
| 后置运算符 | []、func()、.、->、(type){init} |  从左到右|
| ⼀元运算符 | ++、--、!、~、+、-、*、&、sizeof |  从右到左|
| 转换运算符 |  (type name) |  从右到左|
| 乘除运算符 |  *、/、%     |  从左到右|
| 加减运算符 |  +、-        |  从左到右|
| 位移运算符 |  <<、>>      |  从左到右|
| 关系运算符 |  <、<=、>、>=|   从左到右|
| 相等运算符 |  ==、!=      |    从左到右|
| 位运算符 |  & |   从左到右|
| 位运算符 |  ^ | 从左到右 |
| 位运算符 |  \| | 从左到右 |
| 逻辑运算符 |  && |  从左到右|
| 逻辑运算符 |  \|\| | 从左到右|
| 条件运算符 |  ?: |  从右到左|
| 赋值运算符 |  =、+=、-=、*=、/=、%=、&=、^=、\|=、<<=、>>= | 从右到左|
| 逗号运算符 |  , |  从左到右|

引起误解的运算符优先级：

```cpp
(1) "." 优先级⾼高于 "*"。
原型: *p.f
误判: (*p).f
实际: *(p.f)。
(2) "[]" ⾼高于 "*"。
原型: int *ap[]
误判: int (*ap)[]
实际: int *(ap[])
(3) "==" 和 "!=" ⾼高于位操作符。
原型: val & mask != 0
误判: (val & mask) != 0
实际: val & (mask != 0)
(4) "==" 和 "!=" ⾼高于赋值符。
原型: c = getchar() != EOF
误判: (c = getchar()) != EOF
实际: c = (getchar() != EOF)
(5) 算术运算符⾼高于位移运算符。
原型: msb << 4 + lsb
误判: (msb << 4) + lsb
实际: msb << (4 + lsb)
```






### 位运算交换

```cpp
a ^= b;
b ^= a;
a ^= b;
```



### 估算一个题的上界

![image-20200505172052330](/Image/A2.C-improve-photo/image-20200505172052330-1624113625840.png)



### 分支预测

`!!x`：归一化

```cpp
#define likely(x) 	 __builtin_expect( !!(x), 1) //代表x经常成立，加载条件分支内部的代码
#define unlikely(x)  __builtin_expect( !!(x), 0) //代表x不经常成立，加载条件分支内部的代码
```

cpu --> 缓存 cache --> 内存-->外存

- 串行执行
- 并行执行

尽量少用`if else; switch case`(顺序执行);

对于分支机构，分支预测可以引导CPU，提高效率

![image-20200503154422346](/Image/A2.C-improve-photo/image-20200503154422346-1624113642057.png)

![image-20200503155006257](/Image/A2.C-improve-photo/image-20200503155006257-1624113651226.png)

## 函数

函数只能被定义⼀一次，但可以被多次 "声明" 和 "调用"。

gcc ⽀支持嵌套函数扩展。

内层函数可以 "读写" 外层函数的参数和变量，外层变量必须在内嵌函数之前定义。

### 递归认识

​    递归程序：调用自身的方法，是编程技巧，而非算法

​	传入参数，传出参数

1. 定义一个明确的语义信息
2. 边界条件处理
3. 处理和递归过程
4. 返回结果法

+ 数学归纳法

### 函数指针

帮助我们定义分段函数

区分定义 "函数类型" 和 "函数指针 类型"的区别。函数名是⼀一个指向当前函数的指针。

```cpp
typedef void(func_t)(); // 函数类型
typedef void(*func_ptr_t)(); // 函数指针类型
void test()
{
    printf("%s\n", __func__);
}
int main(int argc, char* argv[])
{
    func_t* func = test; // 声明⼀一个指针
    func_ptr_t func2 = test; // 已经是指针类型
    void (*func3)(); // 声明⼀一个包含函数原型的函数指针变量
    func3 = test;
    func();
    func2();
    func3();
	return 0
}
```



### 变参函数

`int func(int num,...);`  省略号

va_list arg;  //定义一个代表参数列表的变量，获取参数列表

在标准的C中，va_start接受一个额外参数，也就是最后一个【固定参数】的名称

 va_end(arg);   //销毁参数列表，结束整个获取可变参数列表的动作

```cpp
#include  <cstdio>
#include  <inttypes.h>
#include  <stdarg.h>   //va_list等的函数库

int max_int(int n, ...) {
    int ans = INT32_MIN, temp;
    va_list arg;  //定义一个代表参数列表的变量，获取参数列表
   va_start(arg, n);   //初始化参数列表，读取  n    个参数
  /*   void va_start( va_list ap, parmN );
va_start 宏使函数能访问后随具名参数 parmN 的可变参数。
应该在任何对 va_arg 的调用前，以合法的 va_list 对象 ap 调用 va_start 。
ap	-	va_list 类型实例
parmN	-	首个可变参数前的参数名
 */
  while (n--) {
        temp = va_arg(arg, int);   //va_arg是宏， 获取下一个参数
        if (temp > ans) ans = temp;
    }
    va_end(arg);   //销毁参数列表，结束整个获取可变参数列表的动作
    return ans;
}

int main() {
    printf("%d\n", max_int(3, 1, 8, 4));
    printf("%d\n", max_int(2, 1, 8));
    printf("%d\n", max_int(4, 1, 5, 4, 8, 111));
    return 0;
}

```

```cpp

#define log(frm, args...) {\
    printf("[%s : %d] %s ", __func__, __LINE__, #args);\
    printf(frm, ##args);\
    printf("\n");\
}

```

va_arg则通过改变指针的方式（每次增加sizeof(double)字节）来返回下一个指针所指向的对象。



### name_20-9

学习`int main(argc, *argv[])`  `sprintf`  `rand()    srand`

```cpp
#include <iostream>
#include <time.h>
#include <cstdlib>
#include <string.h>
using namespace std;
#define max_n 16

char name[max_n][20] = {};
int mark[max_n] = {0};
void output_name(int n) {
    if(n > 16) {
        printf("ERROR\n");
        return ;
    }
    srand(time(0));
    int index;
    for (int i = 0; i < n; ) {
        index = rand() % max_n;
        if (mark[index]) continue;
        printf("%s ", name[index]);
        ++i;
        mark[index] = 1;
    }
    printf("\n");
    return ;
}

int str_to_int(char str[]) {
    int n = strlen(str);    //可不用strlen
    int sum =  0, i = 0;
    while(n--) {
        sum *= 10;
        sum += str[i++] - '0';
    }
    return sum;
}

int main(int argc, char *argv[]) {
    char str[3] = {0};
    if (argc < 2) {
        output_name(1);
    } else {
        sprintf(str, "%s", argv[1]);
        output_name((str_to_int(str)));
    }
    return 0;
}

```



### my_printf

关键点：

- 变参，以及使用va

- 数字:0的处理(digit),正负,`INT32_MIN`翻转的缺位,
- `int`整型，字符串的接收
- 宏定义

```cpp
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>

int reverse_num(int num, int *temp) {
    int digit = 0;
    do {
        *temp = *temp * 10 + num % 10;
        num /= 10;
        ++digit;
    } while(num);
    return digit;
}

int output_num(int num, int digit) {
    int cnt = 0;
    while (digit--) {
        putchar(num % 10 + '0');
        cnt++;
        num /= 10;
    }
    return cnt;
}

int my_printf(const char *frm, ...) {
    int cnt = 0;
    #define PUTC(a) putchar(a), ++cnt;
    va_list arg;
    va_start(arg, frm);
    for (int i = 0; frm[i]; i++) {
        switch (frm[i]) {
            case '%': {
                switch (frm[++i]) {
                    case '%': PUTC(frm[i]); break;
                    case 'd': {
                        int xx = va_arg(arg, int);          //传数据类型，va_arg(arg, int)是宏定义
                        uint32_t x;
                        if (xx < 0){
                            x = -xx;
                            PUTC('-');
                        } else {
                            x = xx;
                        };
                        int num1 = x / 100000, num2 = x % 100000;
                        int temp1 = 0, temp2 = 0;
                        int digit1 = reverse_num(num1, &temp1);
                        int digit2 = reverse_num(num2, &temp2);
                        if (num1) digit2 = 5;
                        else digit1 = 0;
                        cnt += output_num(temp1, digit1);
                        cnt += output_num(temp2, digit2);
                    }
                    break;
                    case 's':
                        const char *str;
                         str = va_arg(arg, const char *);
                    for (int i = 0; str[i]; ++i) {
                        PUTC(str[i]);
                    }
                }
            } break;
        
            default : PUTC(frm[i]); break;
        }
    }
    va_end(arg);
    #undef PUTC
    return cnt;
}

int main() {
    char str[100] = "I don't want to be opbitimistic beforehand";
    my_printf("int (-123) =  %d\n", -123);
    printf("INT32_MAX  =  %d\n", INT32_MAX);
    my_printf("INT32_MAX  =  %d\n", INT32_MAX);
    printf("INT32_MIN  =  %d\n", INT32_MIN);
    my_printf("INT32_MIN  =  %d\n", INT32_MIN);
    my_printf("%s\n", str);
    return 0;
}

```

## 数组

#### 初始化规则:

- 如果数组为静态⽣生存周期，那么初始化器必须是常量表达式。
- 如果提供初始化器，那么可以不提供数组⻓长度，由初始化器的最后⼀一个元素决定。
- 如果同时提供⻓长度和初始化器，那么没有提供初始值的元素都被初始化为 0 或 NULL。

#### 数组参数

当数组作为函数参数时，总是被隐式转换为指向数组第⼀元素的指针，也就是说再也无法⽤sizeof 获得数组的实际⻓度

```cpp
void test2(int x[]) { \\ int *x
	printf("%d\n", sizeof(x));
}
int main(int argc, char* argv[]) {
	int x[] = { 1, 2, 3 };
	printf("%d\n", sizeof(x));
	test(x);
	test2(x);
	return EXIT_SUCCESS;
}
输出:
12
4
```



### 	素数筛

```cpp
//拓展求每个数的最大最小素因子
void init_prime() {
    int pos = 0;
    for (int i = 2; i < SIZE; ++i) {
        if (prime[i]) continue;
        prime[++prime[0]] = i;   //prime[0]记录个数，从prime[1]开始记录素数
        for (int j = i * i; j < SIZE; j += i) {  //从i+i开始标记，解决一个数字被重复标记的问题
            prime[j] = 1;
        }
    }
}
```

指针占用8个字节

高维数组传参，只可省一个维度，`(*b)[][]` ，联想数组的物理存储；  

函数与数组存在一定关系：函数是压缩的数组，数组是展开的函数

### 二分查找

体会数组与函数的关系，函数相比数组无需提前占用空间。

尾递归：eg: 求n!， fac;   易爆栈；

程序加载到内存中，CPU执行，函数中定义的变量，空间在栈区(8MB ~ 800万字节)；函数外定义在堆区；

内存：栈区，堆区 

```cpp
int num(int n) {
    return n;
}

int binary_2(int (*f)(int), int l, int r, int x) {	 //递归写法
    if (l > r) return -1;
    int mid = (l + r) >> 1;
    if (f(mid) == x) return mid;
    if (f(mid) > x) r = mid - 1;
    else l = mid + 1;
    return binary_2( f, l, r, x);
}
```



### 牛顿迭代

求解高元方程的根；优于二分法；

![image-20210313223213465](/Image/A2.C-improve-photo/image-20210313223213465-1624113671141.png)

```cpp
#include<iostream>
#include<math.h>
using namespace std;
#define EPSL 1e-6

inline double F(double x, double n) {
    return x * x - n;
}

inline double f(double x) {
    return 2 * x;
}

double NewTon(double (*F)(double, double), double (*f)(double), double n) {
    double x1 = n / 2.0;
    while (fabs(F(x1, n)) > EPSL) {
        x1 -= F(x1, n) / f(x1);
    }
    return x1;
}

double my_sqrt(double n) {
    return NewTon(F, f, n);
}


int main() {
    double n;
    while (~scanf("%lf", &n)) {
        cout << my_sqrt(n) << endl;
    }

    return 0;
}
```

```cpp
float Q_sqrt( float number ) {   	//雷神三求平方根
	long i;
	float x2, y;
	const float threeHalfs = 1.5F;

	x2 = number * 0.5F;
	y = number;
	i = * ( long * ) &y;
	i = 0x5f3759df - (i >> 1);	// 这是什么鬼？
	y = * ( float * ) &i;
	y = y * ( threeHalfs - ( x2 * y * y ) );
	return y;
}

```



## 宏定义 

### ==**代码替换**==

### 宏的应用

`#`代表预处理命令，包括以`#`开头的头文件，`define`

- 定义符号常量
- 定义代码段   `\`：连接符，

> 宏是用来代码替换(比函数更强大)，而非定义表达式，做运算
>
> > ```cpp
> > #define S(a, b) a * b
> > S( 3 + 4, 5 + 6);    // 3 + 4 * 5 + 6
> > ```



### 预定义的宏

![image-20200514182559568](/Image/A2.C-improve-photo/image-20200514182559568-1624113690480.png)

### 条件式编译

![image-20200514183134694](/Image/A2.C-improve-photo/image-20200514183134694-1624113683308.png)

使用`#ifdef`，记得结束`#endif`

### 预处理命令



```mermaid
graph LR
    A(c源码)--预编译   <展开所有的宏>-->B(编译源码)
    B --编译--- C(对象文件 .o)
    C--链接--> F(可执行文件)
```



`g++ -E file.cpp`

调用函数-->压栈；执行函数-->弹栈;

编译:从上到下

执行:从main函数开始

### MAX

宏是代码替换，注意优先级结合，重复计算；

`#a`的作用；`g++ -E`

```cpp
#include <stdio.h>
#define MAX(a, b) ({\
    __typeof(a) __a = (a);\
    __typeof(b) __b = (b);\
    __a > __b ? __a : __b;\
})

#define P(a) {\
    printf("%s = %d\n", #a, a);\　　　　//#a，将ａ以字符串形式输出
}

int main() {
    int a = 7;
    P(MAX(2, 3));
    P(5 + MAX(2, 3));
    P(MAX(2, MAX(3, 4)));
    P(MAX(2, 3 > 4 ? 3 : 4));
    P(MAX(a++, 6));
    P(a);
    return 0;
}
```

### LOG

注意　`#args`　将参数转为字符串形式, 和　`##args` 连接符,连接在一起,的用法

`g++ -DDEBUG file.cpp`的用法；条件编译的用法

可用来找BUG

```cpp
#include <stdio.h>
//#define DEBUG
#ifdef DEBUG
#define log(frm, args...) {\
    printf("[%s : %d] %s ", __func__, __LINE__, #args);\
    printf(frm, ##args);\
    printf("\n");\
}
#else
#define log(frm, args...)
#endif

#define contact(a, b) a##b

int main() {
    int a = 3, abc, def;
    int abcdef = 0;
    log("%d", abcdef);
    log("%d", a);
    log("hello world");
    contact(abc, def) = 123;
    log("%d", abcdef); 	//为什么abcdef为３，##a连接的作用，代码替换
    return 0;
}
[main : 25] abcdef 0
[main : 26] a 3
[main : 27]  hello world
[main : 29] abcdef 123
```



## 字符串



==函数中：字符串指针变量， 1. static静态变量； 2.strdup==

`strstr`：查找子串

`stdup`: 单独分配空间

`atoi`:字符串转整型



![image-20200516141626848](/Image/A2.C-improve-photo/image-20200516141626848-1624158252361.png)

![](/Image/A2.C-improve-photo/image-20200516150818793-1624113700030.png)

`memset(str1,c,n);` c只可设置为0或-1；按字节设置,每一位为0或1才有意义

### string

```cpp
#include <iostream>
#include <string.h>
#include <inttypes.h>
using namespace std;

int main() {
    char str[10] = {0};
    int n;
    while (~scanf("%d", &n)) {
        sprintf(str, "%x", n);
        printf("%s has %lu digits\n", str, strlen(str));
    }
    return 0;
}
```



## 复杂结构

### 结构体

结构体的内存分配：内存对齐；取最大类型所占空间；

`#pragma pack(n)` 宏，n就是你要指定的“对齐系数”

```cpp
struct node1 {
	char a; int b; int c;
};			//8字节
struct node2 {
	char a; int c; char b;
};			//16字节
```

定义结构：将同一类型放一起



```cpp
#pragma是一条预处理的指令（preprocessor directive）
简单地说，#pragma是用来向编译器传达语言标准以外的一些信息。
	#pargma once
效果等同于
#ifndef THIS_HEADER
#define THIS_HEADER

#endif
```







### 共用体

内存公用：选取一个最大的字段;共用一块内存

地址按字节排序，

eg：实现IP地址化整数

```cpp
#include <iostream>
using namespace std;

union IP {
    struct {
     unsigned char a1;   
     unsigned char a2;   
     unsigned char a3;   
     unsigned char a4;   
    } ip;
    unsigned int num;
};

int is_little() {
    static int num = 1;
    return ((char *)&num)[0];
}

int main() {
    cout << is_little() << endl;
    union IP p;
    char str[100];
    int arr[4];
    while (~scanf("%s", str)) {
        sscanf(str,"%d.%d.%d.%d", arr, arr + 1, arr + 2, arr + 3);
        p.ip.a1 = arr[3];
        p.ip.a2 = arr[2];
        p.ip.a3 = arr[1];
        p.ip.a4 = arr[0];
        printf("%p\n", &p.ip.a1);
        printf("%p\n", &p.ip.a2);
        printf("%p\n", &p.ip.a3);
        printf("%p\n", &p.ip.a4);
        printf("%p\n", &p.num);
        cout << p.num << endl;
    }
    return 0;
}

```



大端小端机：

- **大端（存储）模式**：是指一个数据的低位字节序的内容放在高地址处，高位字节序存的内容放在低地址处。
- **小端（存储）模式**：是指一个数据的低位字节序内容存放在低地址处，高位字节序的内容存放在高地址处。（可以总结为“小小小”即低位、低地址、小端）

```cpp
#include<cstdio>
int main() {
    int a = 321;
    printf("%d\n", ((char *)&a)[0]);
    printf("%d\n", ((char *)&a)[1]);
    printf("%d\n", ((char *)&a)[2]);
	return 0;
}
//
输出
65
1
0
低位低存，前8bite存低地址
```

主机字节序：

## 指针

> 指针变量也是变量，变量就有地址
>
> 按字节编址

> 64位OS(x64)：指针占空间8B;
>
> 32位OS(x86)：指针占空间4B;

常量指针:`const char *str` 指针所指向的内容不可更改；

指针常量:` char * const str` 指针所代表的地址不可更改；

`.` 成员选择(对象):直接引用

`->`成员选择(指针):间接引用

`int *a, c;`中`*`和变量走

```cpp
//char *，与int *区别(偏移1个数据类型)，结构体，指针;
using namespace std;
typedef struct Data {
    int x, y;
} Data;

int main() {
    int  *p1;
    char *p2;
    printf("%p %p\n", p1, p1 + 1);
    printf("%p %p\n", p2, p2 + 1);
    Data a[2] = { {0,1}, {2,3} };
    Data *p = a;
    printf("%d\n", (*(a + 1)).x);
    printf("%d\n", (*(p + 1)).x);
    printf("%d\n", (p + 1)->x);
    printf("%d\n", (a + 1)->x);
    printf("%d\n", p[1].x);
}
0x55b20ca2d9cd 0x55b20ca2d9d1
0x7f7c4e9119a0 0x7f7c4e9119a1
2
2
2
2
2Ss
```

### 栈存储，大小端

| num1 小端机，16进制下 | 63   | 62   | 61   | 0    |
| --------------------- | ---- | ---- | ---- | ---- |
| 十进制                | 99   | 98   | 97   | 0    |
| ACSII                 | c    | b    | a    | \0   |

栈存储从高地址到低地址，先进后出

| 栈低地址 |      | 栈高地址 |
| -------- | ---- | -------- |
| 存储     | num2 | num1     |
|          | dcba | cba\0    |

### 地址偏移量

利⽤`stddef.h` 中的 offsetof 宏可以获取结构成员的偏移量。输出结果有字节对⻬齐。



`#define offset(T, a) ((long)(&(((T *)(NULL))->a)))`，定义T*类型NULL指针，间接引用a，取其地址，强转long

```cpp 
#include<iostream>
using namespace std;
#define pchar char *
typedef char * ppchar;

//#define offset(T, a) ((long)(&(((T *)(NULL))->a)))
#define offset(T, a) ({\
    T temp;\
    (char *)(&temp.a) - (char *) (char *)(&temp);\
})

struct Data {
    int a;
    double b;
    char c;
};

int main() {
    int num1 = 0x616263;
    int num2 = 0x61626364;
    printf("%s\n", (char *)(&num2));
    cout << endl;
    //printf("%s\n", (char *)(&num1));
    printf("%ld\n",offset(struct Data, a));
    printf("%ld\n",offset(struct Data, b));
    printf("%ld\n",offset(struct Data, c));
    pchar p, q;		//宏，代码替换
    ppchar a, b;
    printf("p = %lu, q = %lu\n",sizeof(p), sizeof(q));
    printf("p = %lu, q = %lu\n",sizeof(a), sizeof(b));
    return 0;
}

dcbacba

0
8
16
p = 8, q = 1   //宏只是代码替换
p = 8, q = 8

```





### typedef

```cpp
//内建类型
typedef long long lint;
typedef char * pchar;
//结构体类型
typedef struct _node {
    int x, y;
} Node, *PNode;
//函数指针
int (*func)(int , int );   //func是一个函数指针变量
typedef int (*func)(int , int );	//func是一个函数指针类型
```

### main函数参数

```cpp
int main();
int main(int argc, char *argv[]);	//argc 参数个数，第一个参数为本身；argv参数，具体参数的内容
int main(int argc, char *argv[], char **env);	//env参数，环境变量的内容
```

```cpp
void output(int argc, char *argv[], char **env) {
    cout << argc << endl;
    for (int i = 0; i < argc; ++i) {
        printf("%s\n",argv[i]);
    }
    for (int i = 0; env[i]; ++i) {
        //printf("env[%d] = %s\n", i, env[i]);
        if (strncmp(env[i], "USERNAME=", 9) == 0) {
            if (strncmp(env[i] + 9, "worst", 5) == 0) {
                cout << "Welcome to beat the code" << endl;
                continue;
            }
            cout << "Please go away" << endl;
        }
    }
    return ;
}

int main(int argc, char *argv[], char **env) {
    output(argc, argv, env);
    return 0;
}


1
./a.out
Welcome to beat the code
```



## 工程开发

### 函数声明和定义

编译:检测语法

函数未声明报错在: 编译阶段

函数未定义报错在:生成对象文件链接的时候

```shell
/tmp/ccgj9a4z.o：在函数‘main’中：
test.cpp:(.text+0xa)：对‘funcA(int)’未定义的引用
collect2: error: ld returned 1 exit status
```

链接:将对象文件进行链接,捏合

条件式编译能保证一次源文件编译过程中不出现重复包含的功能,不出现重复定义的错误

不解决在对对象文件链接过程中的重复定义问题

```cpp
#ifndef _HEADER_H
#define _HEADER_H
#endif
```

### 函数头文件和源文件

函数定义放在头文件(.h),一般调用函数的声明放在源文件(.cc),主函数源文件(.cpp);

```cpp
worst@worst 1.define % cat header1.h                                                               [0] //头文件,函数定义
#ifndef _HEADER1_H
#define _HEADER1_H
void funcA(int);
void funcB(int);
#endif

worst@worst 1.define % cat header1.cc                                                              [0]   //源文件,函数声明
#include <stdio.h>
#include "header1.h"
void funcB(int n) {
    if (n == 0) return ;
    printf("funcB : %d\n", n);
    funcA(n - 1);
    return ;
}
void funcA(int n) {
    if (n == 0) return ;
    printf("funcA : %d\n", n);
    funcB(n - 1);
    return ;
}


```



```cpp
C++实现             					  源代码的扩展名
UNIX                             		   C、cc、cxx、c
GNU C++                        		  C、cc、cxx、cpp、c++
Borland C++                    	   Cpp
Microsoft Visual C++       	cpp、cxx、cc
```

#是宏,宏就是代码替换

```cpp
#include <stdio.h>   // <>从系统库的目录下查找文件,头文件.h
#include "header1.h"   //""从当前目录下查找文件,头文件.h
#include "header2.h"
```

将`""`换成`<>`

```cpp
#include <stdio.h>   // <>从系统库的目录下查找文件
#include <header1.h>
```

` g++ -c -I目录 file.c `将某一目录添加到系统查找目录中

```shell
worst@worst 1.define % g++ -c -I./ test.cpp                                                        [0]
worst@worst 1.define % g++ -c -I./ header1.cc                                                      [0]
worst@worst 1.define % g++ -c -I./ header2.cc                                                      [0]
worst@worst 1.define % g++ test.o header1.o header2.o                    
```

### 静态链接库

模块tree的模型

```shell
module		## 模块
	   ├── include  	##存放头文件,函数声明
	   │   ├── header1.h
	   │   └── header2.h
	   ├── lib				##存放静态链接库
	   │   └── libweier.a
	   └── src				##存放源文件,函数定义
	       ├── header1.cc
 	       └── header2.cc

```

创建静态库及使用

由.o文件生成.a的静态库文件，静态库的名字问`libweier.a`

```shell
ar rc libweier.a header1.o header2.o
```

使用静态库进行静态链接，将对象文件生成可执行文件`test`

```shell
g++ test.o -o test -L./module/lib -lweier 
```

-L 是指定加载库文件的路径

-l 指定加载的库文件

```shell
 5217  mkdir module
 5218  mv header* module
 5221  mkdir include
 5223  mv header*.h include
 5226  mkdir src
 5227  mv *.cc src
 5232  mkdir lib
 5233  g++ -c -I./include ./src/header1.cc
 5234  g++ -c -I./include ./src/header2.cc
 5236  ar rc libweier.a header1.o header2.o
 5238  mv libweier.a lib
 5246  g++ -c -I./module/include test.cpp
 5248  g++ -L./module/lib test.o -lweier
 5251  ./a.out

```

演示

```shell
worst@worst 1.define % mkdir module                                                                [0]
worst@worst 1.define % mv header* module                                                           [0]
worst@worst 1.define % cd module                                                                   [0]
worst@worst module % ll                                                                            [0]
总用量 24K
-rw-rw-r-- 1 worst worst  259 6月   9 10:24 header1.cc
-rw-rw-r-- 1 worst worst  360 6月   9 10:24 header1.h
-rw-rw-r-- 1 worst worst 1.8K 6月   9 10:25 header1.o
-rw-rw-r-- 1 worst worst  147 6月   9 10:25 header2.cc
-rw-rw-r-- 1 worst worst  368 6月   9 10:24 header2.h
-rw-rw-r-- 1 worst worst 1.7K 6月   9 10:25 header2.o
worst@worst module % mkdir include                                                                 [0]
worst@worst module % ll                                                                            [0]
总用量 28K
-rw-rw-r-- 1 worst worst  259 6月   9 10:24 header1.cc
-rw-rw-r-- 1 worst worst  360 6月   9 10:24 header1.h
-rw-rw-r-- 1 worst worst 1.8K 6月   9 10:25 header1.o
-rw-rw-r-- 1 worst worst  147 6月   9 10:25 header2.cc
-rw-rw-r-- 1 worst worst  368 6月   9 10:24 header2.h
-rw-rw-r-- 1 worst worst 1.7K 6月   9 10:25 header2.o
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:37 include
worst@worst module % mv header*.h include                                                          [0]
worst@worst module % rm *.o                                                                        [0]
worst@worst module % ll                                                                            [0]
总用量 12K
-rw-rw-r-- 1 worst worst  259 6月   9 10:24 header1.cc
-rw-rw-r-- 1 worst worst  147 6月   9 10:25 header2.cc
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:37 include
worst@worst module % mkdir src                                                                     [0]
worst@worst module % mv *.cc src                                                                   [0]
worst@worst module % ll                                                                            [0]
总用量 8.0K
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:37 include
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:38 src
worst@worst module % cd src                                                                        [0]
worst@worst src % ls                                                                               [0]
header1.cc  header2.cc
worst@worst src % cd ..                                                                            [0]
worst@worst module % mkdir lib                                                                     [0]
worst@worst module % g++ -c -I./include ./src/header1.cc                                           [0]
worst@worst module % g++ -c -I./include ./src/header2.cc                                           [0]
worst@worst module % ll                                                                            [0]
总用量 20K
-rw-rw-r-- 1 worst worst 1.8K 6月   9 10:44 header1.o
-rw-rw-r-- 1 worst worst 1.7K 6月   9 10:44 header2.o
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:37 include
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:39 lib
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:38 src
worst@worst module % ar rc libweier.a header1.o header2.o                                          [0]
worst@worst module % ll                                                                            [0]
总用量 24K
-rw-rw-r-- 1 worst worst 1.8K 6月   9 10:44 header1.o
-rw-rw-r-- 1 worst worst 1.7K 6月   9 10:44 header2.o
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:37 include
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:39 lib
-rw-rw-r-- 1 worst worst 3.7K 6月   9 10:47 libweier.a
drwxrwxr-x 2 worst worst 4.0K 6月   9 10:38 src
worst@worst module % mv libweier.a lib                                                             [0]
worst@worst module % cd lib                                                                        [0]
worst@worst lib % ls                                                                               [0]
libweier.a
worst@worst lib % cd ..                                                                            [0]
worst@worst module % cd ..                                                                         [0]
worst@worst 1.define % ls                                                                          [0]
a.out  func.cc  module  test.cpp  test.o
worst@worst 1.define % rm test.o                                                                   [0]
worst@worst 1.define % rm a.out                                                                    [0]
worst@worst 1.define % ll                                                                          [0]
总用量 12K
-rw-rw-r-- 1 worst worst  318 6月   8 19:32 func.cc
drwxrwxr-x 5 worst worst 4.0K 6月   9 10:48 module
-rw-rw-r-- 1 worst worst  446 6月   9 10:24 test.cpp
worst@worst 1.define % g++ -c -I./module/include test.cpp                                          [0]
worst@worst 1.define % g++ -c test.cpp                                                             [0]
test.cpp:10:10: fatal error: header1.h: 没有那个文件或目录
 #include <header1.h>
          ^~~~~~~~~~~
compilation terminated.
worst@worst 1.define % g++ -L./module/lib test.o -lweier                                           [1]
worst@worst 1.define % ls                                                                          [0]
a.out  func.cc  module  test.cpp  test.o
worst@worst 1.define % ./                                                                          [0]
worst@worst 1.define % ./a.out                                                                     [0]
funcA : 5
funcB : 4
funcA : 3
funcB : 2
funcA : 1
funcC; 6 + 7 = 13 
funcA : 6
funcB : 5
funcA : 4
funcB : 3
funcA : 2
funcB : 1
worst@worst 1.define % cd module                                                                   [0]
worst@worst module % ls                                                                            [0]
header1.o  header2.o  include  lib  src
worst@worst module % rm *.o                                                                        [0]
worst@worst module % cd lib                                                                        [0]
worst@worst lib % ls                                                                               [0]
libweier.a
worst@worst lib % vim libweier.a                                                                   [0]
worst@worst lib % cd ..                                                                            [0]
worst@worst module %                                                                               [0]

```



## haizei_test自制单元测试

### GNU的属性（attribute）

属性的真正强大之处在于它们能够让编译器供应商创建他们自己的语言扩展，同时不会干扰语言或等待特性的标准化。
所有的编译器都在尝试支持它，以用于修饰类型、变量和函数等
`__attribute__((attribute-name))`这样的写法，每一个编译器可能还都有变种



### 1.初版测试框架

cmake根据本机环境生成相应的makefile文件

需求优先，先设计怎么用

```c
add(3, 5) == 8 ? True
add(22, 1) != 71 ? True
add(12, 1) < 71 ? True
add(4, 1) > 5 ? False
add(56, 1) <= 57.4 ? True
```

`__attribute__((constructor))`可以修饰函数,使修饰的函数先于主函数执行

设置相关属性   对于程序的某些量先于主函数执行

`RUN _ ALLTESTS `:获得程序中所有册试用例的函数信息,通过注册函数`add_function()`:将测试用例函数记录下来

宏可以将原本看似不合理的代码,变得合理。`EXPECT_EQ`,`TEST`均为宏

`TEST`宏要实现函数的定义,(函数名称通过两个参数拼接,防止重定义)

```c
#define TEST(a, b)\
void a##_test_##b();\
__attribute__((constructor))\
void add_##a##_test_##b() {\
    add_function(a##_test_##b, #a "_test_" #b);\
}\
void a##_test_##b()\
```

注册函数(用来存储测试用例函数的地址)

```c
int function_cnt = 0;
struct Function function_arr[100];
/* 头文件声明Function
typedef void (*TestFuncT)();
struct Function {
    TestFuncT func;
    const char *str;
};
*/
void add_function(TestFuncT func, const char *str) {
    function_arr[function_cnt].func = func;
    function_arr[function_cnt].str = strdup(str);
    function_cnt++;
    return ;
}
```





### 2.输出颜色与格式信息

通过宏以及`printf`打印的颜色的语法(见零碎知识点)

```c
#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define COLOR_HL(a, b) "\033[" #b ";1m" a "\033[0m"

#define GREEN(a) COLOR(a, 32)
#define GREEN_HL(a) COLOR_HL(a, 32)
```

### 3.输出统计信息

函数的声明与定义分放头文件,源文件

变量的声明与定义:`.c`文件中定义`int a = 5;`，在`a.h`里写`extern int a;`，

`extern int a;`说明了a的存储空间是在程序的其他地方分配的，在文件中其他位置或者其他文件中寻找a这个变量。

==.h头文件中不应该定义变量(重复定义)==

```c
//test.c 源文件中
struct FunctionInfo test_info;
//test.h 头文件
struct FunctionInfo {
    int total, success;
};
extern struct FunctionInfo test_info;
```

### 4.输出错误信息

在==C11== 标准中，_Generic 关键字使其支持轻量级的泛型编程设计。

Linux中严格区分C语言和cpp语言,所以后缀要为.c

```c
#define TYPE_STR(a) _Generic((a), \
    int : "%d", \
    double : "%lf", \
    float : "%f", \
    long long : "%lld",\
    char : "%c", \
    const char * : "%s",\
    default : "others"\
)

#define P(a, color) {\
    char frm[1000];\
    sprintf(frm, color("%s"), TYPE_STR(a));\
    printf(frm, a);\
}
printf(YELLOW_HL("\n\t%s:%d: Failure\n"), __FILE__, __LINE__);\
            printf(YELLOW_HL("\t\texpect : " #a " " #comp " " #b "\n\t\t" "actual : "));\
            P(_a, YELLOW_HL);\
            printf(YELLOW_HL(" vs "));\
            P(_b, YELLOW_HL);\
            printf("\n\n");\
```

### 5.链表外骨骼

通过LinkNode将每个Funtion结构(存有func,str,p下一节点的地址)连接起来

通过结构体中的地址偏移量求得节点首地址

```cpp
//func_head是个虚拟头节点    
//p指向为首个带有存有信息的节点
for (struct LinkNode *p = func_head.pointer.next; p != NULL; p = p->next) {
        struct Function *func = Head(p, struct Function, pointer);
    }
```

解释:

| 为求当前func的地址 | func    | offset(T,pointer)就可求出func与str总共占用空间,即地址偏移量 |
| :-----: | ---------------------------------------------- | ---- |
| ^ | func    |                                                |
| \| | str     |                                                |
| 已知当前pointer地址 | pointer | p就是当前结构体成员pointer的地址               |
| |         | 所以p减去sizeof(str+func)就是当前结构体的地址  |



```cpp
//linklist.h

#define offset(T, name) (long long)(&((T *)(0))->name)
//offset() T结构体name字段的地址偏移量
#define Head(p, T, name) ((T *)(((char *)p) - offset(T, name)))
//p:节点的pointer地址,T:当前结构体类型,name:结构体的成员名name;
//求得节点的首地址
struct LinkNode {
    struct LinkNode *next;  
};

```





### makefile文件

```makefile
CC = gcc
CFLAGS = -g -Wall
MAINOBJS = main.o haizei/test.o

.PHONY: clean

all: $(MAINOBJS)
	$(CC) $(CFLAGS) $(MAINOBJS) -o ./bin/main

haizei/test.o: haizei/test.c haizei/test.h
	$(CC) $(CFLAGS) -I./ -c -o haizei/test.o haizei/test.c
main.o: main.c  
	$(CC) $(CFLAGS) -I./ -c -o main.o main.c
clean:
	rm -f $(MAINOBJS) bin/main
```

### test.h

```c
#ifndef _TEST_H
#define _TEST_H

#include <haizei/linklist.h>
#define Name(a, b) a##_test_##b
#define Str(a, b)  #a "_test_" #b

#define TEST(a, b)\
void a##_test_##b();\
__attribute__((constructor))\
void add_##a##__test__##b() {\
    add_function(Name(a,b), Str(a, b));\
}\
void a##_test_##b()\

#define COLOR(a, b) "\033[" #b "m" a "\033[0m"
#define COLOR_HL(a, b) "\033[" #b ";1m" a "\033[0m"

#define GREEN(a) COLOR(a, 32)
#define RED(a) COLOR(a, 31)
#define BLUE(a) COLOR(a, 34)
#define YELLOW(a) COLOR(a, 33)

#define GREEN_HL(a) COLOR_HL(a, 32)
#define RED_HL(a) COLOR_HL(a, 31)
#define BLUE_HL(a) COLOR_HL(a, 34)
#define YELLOW_HL(a) COLOR_HL(a, 33)
#define TYPE_STR(a) _Generic((a), \
    int : "%d", \
    double : "%lf", \
    float : "%f", \
    long long : "%lld",\
    char : "%c", \#ifndef _LINKLIST_H
#define _LINKLIST_H

#define offset(T, name) (long long)(&((T *)(0))->name)

#define Head(p, T, name) ((T *)(((char *)p) - offset(T, name)))

//offset() T结构体name字段的地址偏移量
//
//
//Head() 节点的next地址,当前结构体类型,下一节点的name字段;

struct LinkNode {
    struct LinkNode *next;
};

#endif

    const char * : "%s",\
    default : "others"\
)

#define P(a, color) {\
    char frm[1000];\
    sprintf(frm, color("%s"), TYPE_STR(a));\
    printf(frm, a);\
}

#define EXPECT(a, b, comp) {\
        __typeof(a) _a = (a);\  
        __typeof(b) _b = (b);\
        test_info.total += 1;\
        if (_a comp _b) test_info.success += 1;\
        else {\
            printf(YELLOW_HL("\n\t%s:%d: Failure\n"), __FILE__, __LINE__);\
            printf(YELLOW_HL("\t\texpect : " #a " " #comp " " #b "\n\t\t" "actual : "));\
            P(_a, YELLOW_HL);\
            printf(YELLOW_HL(" vs "));\
            P(_b, YELLOW_HL);\
            printf("\n\n");\
        }\
        printf(GREEN("[-----------] ") #a " " #comp " " #b);\
        printf(" %s\n", (_a comp _b ? GREEN_HL("True") : RED_HL("False")));\
}

#define EXPECT_EQ(a, b) EXPECT(a, b, ==)
#define EXPECT_NE(a, b) EXPECT(a, b, !=)
#define EXPECT_LT(a, b) EXPECT(a, b, <)
#define EXPECT_GT(a, b) EXPECT(a, b, >)
#define EXPECT_LE(a, b) EXPECT(a, b, <=)
#define EXPECT_GE(a, b) EXPECT(a, b, >=)

typedef void (*TestFuncT)();
struct Function {
    TestFuncT func;
    const char *str;
    struct LinkNode pointer;
};
struct FunctionInfo {
    int total, success;
};
extern struct FunctionInfo test_info;

int RUN_ALL_TESTS();
void add_function(TestFuncT, const char *);
#endif
```



### test.c

```c
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <haizei/test.h>
#include <haizei/linklist.h>
struct Function func_head, *func_tail = &func_head;

int function_cnt = 0;
struct FunctionInfo test_info;

int RUN_ALL_TESTS() {
    for (struct LinkNode *p = func_head.pointer.next; p != NULL; p = p->next) {
        struct Function *func = Head(p, struct Function, pointer);
        test_info.total = test_info.success = 0;
        printf(GREEN_HL("[====RUN====]") YELLOW_HL(" %s\n"), func->str);
        func->func();
        double rate = 100.0 * test_info.success / test_info.total;
        printf(GREEN("[  "));
        if (fabs(rate - 100) < 1e-6) {
            printf(BLUE_HL("%6.2lf%%"), rate);
        } else {
            printf(RED_HL("%6.2lf%%"), rate);
        }
        printf(GREEN("  ]") 
            " total : %d success : %d\n", 
            test_info.total, 
            test_info.success 
            );
    }
    return 0;
}

void add_function(TestFuncT func, const char *str) {
    struct Function *temp = (struct Function *)calloc(1, sizeof(struct Function)); 
    temp->func = func;
    temp->str = strdup(str);
    func_tail->pointer.next = &(temp->pointer);
    func_tail = temp;
    return ;
}

```

### linklist.h

```cpp
#ifndef _LINKLIST_H
#define _LINKLIST_H

#define offset(T, name) (long long)(&((T *)(0))->name)

#define Head(p, T, name) ((T *)(((char *)p) - offset(T, name)))

//offset() T结构体name字段的地址偏移量
//
//
//Head() 节点的next地址,当前结构体类型,下一节点的name字段;

struct LinkNode {
    struct LinkNode *next;
};

#endif

```





## 文件操作

我们可以通过下面的方式声明一个文件指针。 

```c
//关联fp和文件
FILE *fp;
fp = fopen(文件路径, 访问模式); 
 // 第一个参数是一个字符串，对应了我们希望访问的文件路径。
// 第二个参数是访问模式，只读模式的"r"，只写模式的"w"，文件末尾追加的"a"

//断开fp和文件
flose(fp);
```

通过`fgetc(fp)`获得当前指针之后位置的一个字符，每获得一个字符，指针会向后移动一个字符（如果到达文件尾部则会返回`EOF`）。 

我们这时通过`fputc('c', fp)`;的方式将字符`'c'`写入到`fp`关联的文件内了。

```c
 void filecopy(FILE *in_fp, FILE *out_fp) {
     char ch; 
     while ((ch = fgetc(in_fp)) != EOF) {
         fputc(ch, out_fp); 
     } 
 } 

```

这个函数会通过一个可读模式的文件指针逐字符地读取，并且通过一个可写模式的文件指针逐字符地将所有字符写出，从而起到复制文件内容的作用。

`stdin`、`stdout `和 `stderr `分别用于标准输入、标准输出、标准错误的文件指针。



```c
// fgets():从文件中读取一个字符串
char *fgets(char *str, int n, FILE *fp)
// fputs():写入字符串到文件中去
    
    while(fgets(buffer,SIZE,fp1)!=NULL)
        printf("%s\n",buffer);
    while(fgets(buffer,SIZE,fp2)!=NULL)
        fputs(buffer,fp1);
    
   int fprintf(FILE *fp,char *format,arg_list)
```







## 计蒜课工程

### 简单命令的实现

```cpp
#include <stdio.h>
#include <string.h>
#include "roman.h"

typedef struct {
    int roman_flag;
    FILE *fin;
    FILE *fout;
} System_args;

int init(int, char *[], System_args *);
void read_and_output(System_args *);
void close_all(System_args *);

int main(int argc, char *argv[])
{
    System_args main_args;
    if (init(argc, argv, &main_args) == 0) {
        return 0;
    }
    read_and_output(&main_args);
    close_all(&main_args);
    return 0;
}
 
int init(int argc, char *argv[], System_args *args) {
    if (argc < 2) {
        return 0;
    }
    args->roman_flag = (strcmp(argv[1], "-r") == 0 ? 1 : 0);
    args->fin = stdin;
    args->fout = stdout;
    if (argc >= 3) {
        args->fin = fopen(argv[2], "r");
        if (argc >= 4) {
            args->fout = fopen(argv[3], "w");
        }
    }
    return 1;
}
 
void close_all(System_args *args) {
    if (args->fin != stdin) {
        fclose(args->fin);
        args->fin = NULL;
    }
    if (args->fout != stdout) {
        fclose(args->fout);
        args->fout = NULL;
    }
    return ;
}

void read_and_output(System_args *args) {
    if (args->fin == NULL || args->fout == NULL) return ;
    int line_index = 1;
    int output_line_index = 1;
    char dst[25];
    char c;
    while (fscanf(args->fin, "%c", &c) != EOF) {
        if (output_line_index == 1) {
            if (args->roman_flag) {
                fprintf(args->fout, "%s\t", to_roman_numeral(dst, line_index));
            } else {
                fprintf(args->fout, "%d\t", line_index);
            }
            output_line_index = 0;
        }
        fprintf(args->fout, "%c", c);
        if (c == '\n') {
            output_line_index = 1;
            ++line_index;
        }
    }
    return ;
}
```



### 自制简易OJ

```cpp
#include <stdio.h>
#include "run.h"

int main()
{
    const char *name_program = "./program";
    const char *name_in = "./in.txt";
    const char *name_out = "./out.txt";
    const char *name_right = "./right.txt";
    run(name_program, name_in, name_out);
    FILE *fpright = fopen(name_right, "r");
    FILE *fpout = fopen(name_out, "r");
    // Input your code here.
    char c1, c2;
    int ret1, ret2;
    int right_flag = 1;
    while (right_flag) {
        ret1 = fscanf(fpright, "%c", &c1);
        ret2 = fscanf(fpout, "%c", &c2);
        if (ret1 == EOF || ret2 == EOF) break;
        if (c1 != c2) {
            right_flag = 0;
        }
    }

    if (right_flag == 1) {
        if (ret1 != EOF || ret2 != EOF) {
            if ((ret1 != EOF && c1 == '\n') ||
                (ret2 != EOF && c2 == '\n')) {
                ret1 = fscanf((ret1 != EOF ? fpright : fpout), "%c", &c1);
                right_flag = (ret1 == EOF ? 1 : 0);
            } else {
                right_flag = 0;
            }
        }
    }
    printf("%s", right_flag ? "Accept" : "Wrong Answer");
    fclose(fpout);
    fclose(fpright);
    return 0;
}
```



## ==makefile文件==

在Makefile可以使用它的变量和注释。 

```makefile
# 井号开头的行是一个注释 
# 设置 C 语言的编译器 
CC = gcc  
# -g 增加调试信息
# -Wall 打开大部分警告信息 
CFLAGS = -g -Wall  
# 整理一下 main 依赖哪些目标文件    OBJS:对象集
MAINOBJS = main.o array.o

.PHONY: clean  

main: $(MAINOBJS)
	$(CC) $(CFLAGS) -o main $(MAINOBJS) 
array.o: array.c array.h
	$(CC) $(CFLAGS) -c -o array.o array.c  
main.o: main.c array.h 
	$(CC) $(CFLAGS) -c -o main.o main.c  
clean: rm -f $(MAINOBJS) main 


```

`CC`变量定义了编译器，`CFLAGS`变量标记了编译参数，`MAINOBJS`变量记录了main依赖的目标文件。定义的变量可以直接通过`$(变量名)`进行使用。

## ==gcc/g++==

`gcc file.c -lm`			链接函数库

`gcc file.c -std=c99`   		C语言版本

`gcc file.c -o program` 	生成program程序

`cp file.exe /usr/bin`  任何地方可执行

`g++ -E file.cpp` 显示预处理阶段代码

`g++ -c file.cpp` 生成对象文件

g++ -S生成一个 .s文件

` g++ -c -I目录 file.c `将某一目录添加到系统查找目录中



Linux下gcc编译c文件为可执行文件分为四个步骤： 分别是 预编译、编译、汇编、链接
1、预编译( 生成 hello.i 文件)

预编译器cpp 把源代码文件和相关的头文件（如stdio.h）预编译成一个 .i 文件

预编译的过程相当于


``` shell
gcc -E hello.c -o hello.i 或者 gcc  hello.c > hello.i
```

预编译的处理规则：

    将所有的 “#define” 删除，并展开所有的宏定义
    处理所有的条件预编译指令，比如：" #if #ifdef #elif #else #endif "
    处理所有的 “#include” 预编译指令
    删除所有的注释 “//” 、 “/* */”
    添加行号和文件名标识，以便编译时产生的行号信息以及用于编译错误或警告时能够显示行号
    保留所有的 “#pragma” 编译器指令



2、编译(生成汇编代码 hello.s)

编译过程是编译器gcc把预处理完的文件进行词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。

```sehll
 gcc -S hello.i -o hello.s 或者  gcc -S hello.c -o hello.s
```

都可以得到汇编输出文件 hello.s
3、汇编(生成hello.o文件)

汇编是 汇编器as 把汇编代码转变成中间目标文件。

    $ gcc -c hello.s -o hello.o 或者 $ gcc -S hello.c -o hello.o


4、链接（生成可执行程序）

链接器 ld：负责将程序的目标文件与所需的所有附加的目标文件连接起来，附加的目标文件包括静态连接库和动态连接库

链接是链接器ld把中间目标文件和相应的库一起链接成为可执行文件。

    $ gcc hello.o -o hello

`$ gcc hello.c`命令，默认会产生一个a.out 的可执行文件，
`$gcc−o test hello.c`命令，会产生一个test的可执行文件

注：上述步骤可以放在一起执行

$ gcc hello.c -o hello 生成hello可执行文件



#  零碎知识点



&& ||  a++ ++a 要点




## 随机数

```cpp
#include <time.h>
#include <stdlib.h>
srand(time(0));		//随机种子，time(0):程序当前时间，按秒。
int val = rand() % 100;   //伪随机数,只解决每次不一样
```

## 左值，右值

>  后面能否访问到，能即为左值，否即为右值

`b = (++c)++;`   

`b = ++c++`  等同 `b  = ++(c++)`  --》error



## 二分法

单调函数

解决`1,1,1,1,1,1,0,0,0,0`找最后一个`1`

要点：上取整

```cpp
int binary_search(int *arr, int n) {
    int head = -1, tail = n - 1, mid; 	//head = -1;虚拟头;影响第一次mid,但不影响整体
    while (head < tail) {
        cout << "head: " << head << " tail" << tail << endl;
        mid = (head + tail + 1) >> 1;　　//上取整，解决出现的死循环
        if (arr[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    cout << head << endl;;
    return head;
}
```

解决`0,0,0,0,1,1,1,1,1,1`找第一个`１`



```cpp
int binary_search(int *arr, int n) {
    int head = 0, tail = n, mid;   // tail = n；虚拟尾
    while (head < tail) {
        cout << "head: " << head << " tail: " << tail << endl;
        mid = (head + tail) >> 1;
        if (arr[mid] == 1) tail = mid;
        else head = mid + 1;
    }
    return head != n ? tail : -1;
}

```

## 打印颜色

用法:

```c
printf("\033[47;31mThis is a color test.\033[0m");
```

47是字背景颜色, 31是字体的颜色, This is a color test.是字符串. `\033[0m`是控制码;

部分颜色代码:
字背景颜色: 40--49                字颜色: 30--39
40: 黑                           30: 黑
41: 红                           31: 红
42: 绿                           32: 绿
43: 黄                           33: 黄
44: 蓝                           34: 蓝
45: 紫                           35: 紫
46:深绿                       36: 深绿
47:白色                       37:白色

  \033[0m   关闭所有属性   这个关闭的属性是指的之前通过ANSI控制码获得的属性
  \033[1m   设置高亮度  （光标过出均变为背景色）
  \03[4m   下划线  
  \033[5m   闪烁  
  \033[7m   反显  
  \033[8m   消隐  
  \033[30m   --   \033[37m   设置前景色  
  \033[40m   --   \033[47m   设置背景色  
  \033[nA   光标上移n行  
  \03[nB   光标下移n行  
  \033[nC   光标右移n行  
  \033[nD   光标左移n行  
  \033[y;xH设置光标位置  
  \033[2J   清屏  
  \033[K   清除从光标到行尾的内容  
  \033[s   保存光标位置  
  \033[u   恢复光标位置  
  \033[?25l   隐藏光标  
  \33[?25h   显示光标

## 修饰符

C99 修饰符:
- extern: 默认修饰符，用于函数表示 "具有外部链接的标识符"，这类函数可⽤于任何程序⽂件。⽤用于变量声明表⽰示该变量在其他单元中定义。
- static: 使用该修饰符的函数仅在其所在编译单元 (源码⽂文件) 中可用。还可以表示函数类的静态变量。
- inline: 修饰符 inline 建议编译器将函数代码内联到调⽤用处，但编译器可⾃主决定是否完成。通常包含循环或递归函数不能被定义为 inline 函数。

GNU inline 相关说明:
- static inline: 内链接函数，在当前编译单元内内联。不过 -O0 时依然是 call。
- inline: 外连接函数，当前单元内联，外部单元为普通外连接函数 (头⽂文件中不能添加 inline 关键字)。
附：inline 关键字只能⽤用在函数定义处。







extern int a;

显式的说明了a的存储空间是在程序的其他地方分配的，在文件中其他位置或者其他文件中寻找a这个变量。

用法

- 一个c文件需要调用另一个c文件里的变量或者函数，而不能从.h文件中调用变量。

  a.c文件中定义`int a = 5`和一个函数，在`a.h`里写`extern int a`;，如果要在其他文件里调用a这个变量和函数，直接`#include<a.h>`即可

- `extern int a = 5`与`int a = 5`意义是一样的，都是定义。而`extern int a;`是声明。但会产生一条警告。

- 对于函数而言，和引用变量是一样的，如果需要调用其他.c文件中的函数，在文件中的函数声明前加extern即可，不加extern而直接声明函数也可以，因为声明全局函数默认前面带有extern。

- 如果不想让其他.c文件引用本文件中的变量，加上static即可

- extern和include的区别
  include相当于把include .h文件直接带入到本源文件里，比如在b.c文件里include "a.h"，就相当于把a.h文件里所有定义的变量和函数全部拷贝了一份放入了b.c里，一个项目里，一个.h文件可能会被多个.c源文件包含，这样编译的时候就会报重复定义的错误。而且尽量不要在.h里定义变量，这是一个不好的习惯。
