---
id : B4.C++-others
title : B4.C++-others
typora-root-url : ../
---

# C++ othres

remove_reference

remove_pointer

原地构造的使用

实现一个push_back

move，forward本质是为了重载调用正确版本

const Type &帮一切：ostream中



auto

1. c11不可做函数参数：无法确定函数版本

2. c11不可做模板参数

3. 不能定义数组
4. 不能用于非静态成员变量





```c++
class CMP {
public :
    CMP(int z = 0) : z(z) {} // z = 0 less,  z = 1 greater
    bool operator()(int a, int b) {
        return (a < b) ^ !!(z);
    }
    int z;
};

void sort(int *arr, int l, int r, function<bool(int, int)> cmp = CMP()) {
    if (l >= r) return ;
    int x = l, y = r, z = arr[(l + r) >> 1];
    do {
        while (cmp(arr[x], z)) ++x;
        while (cmp(z, arr[y])) --y;
        if (x <= y) {
            swap(arr[x], arr[y]);
            ++x, --y;
       }
    } while (x <= y);
    sort(arr, l, y, cmp);
    sort(arr, x, r, cmp);
    return ;
}

} // end of haizei

int main() {
    vector<int> arr;
    int n;
    cin >> n;
    while (n--) { int a; cin >> a, arr.push_back(a); }
    sort(arr.begin(), arr.end(), haizei::CMP(1));
    cout << arr << endl;
    int arr2[5] = {6, 8, 4, 5, 1};
    
    haizei::sort(arr2, 0, 4);
    for (int i = 0; i < 5; i++) {
        cout << arr2[i] << " ";
    }
    cout << endl;

    haizei::sort(arr2, 0, 4, cmp1);
}
```



仿函数对象：A()类的匿名对象（构造）

类内重载优先级高于类外重载优先级

friend友元函数声明在内部：主要是为了保证开发者允许该函数访问

原地构造：实现深拷贝

![image-20210329132620508](/Image/B4.C++-others-photo/image-20210329132620508-1623668427117.png)

![image-20210329130326086](/Image/B4.C++-others-photo/image-20210329130326086-1623668427118.png)

编译器：提供默认构造，默认拷贝，一旦提供有参构造，默认的就不会生成

默认构造函数：由系统生成，无参构造

转换构造：一个参数的构造函数

拷贝构造：与赋值运算符完全不一样，const ：兼容const对象，&避免值无限递归

列表初始化：按着类声明顺序构造而非列表顺序，构造和赋值（先构造在赋值）不一样

移动构造：大量的深拷贝

析构函数：创建对象前，c++会检测是否可以析构

```c++
C++ 所推崇的RAII的思想。虽然通常讲起来都很⾼深，实际上的意思就只有⼀个：如果⼀个对象的构造函数成功执⾏了，那么以后不管发⽣什么事情，只要这不是⼀个 undefined behavior，那么析构函数⼀定会被执⾏。
```



```c++
assert 是⽤来判断程序员⾃⼰的错误，譬如说传进了⼀个空指针啦，或者经过层层的检测还是把错误的数据漏进来等等。⽽异常通常是⽤来判断⽤⼾输⼊的错误的。出了异常证明程序不能完全的处理⽤⼾的所有错误的情况（不完整），⽽ assert 命中则证明程序本⾝有错误（不正确），不能甩锅。
```





```c++
#include <iostream>
#include <string>
#include <stack>
#include <sstream>

using namespace std;

struct Item
{
    char op = '\0';
    int number = 0;

    Item() {}
    Item(char theOp) :op{ theOp } {}
};

void Run(stack<Item>& items)
{
    auto second = items.top();
    items.pop();
    auto& first = items.top().number;
    switch (second.op)
    {
    case '+':
        first += second.number;
        break;
    case '-':
        first -= second.number;
        break;
    case '*':
        first *= second.number;
        break;
    case '/':
        first /= second.number;
        break;
    }
}

int Pop(stack<Item>& items)
{
    while (/*3*/items.top().op != '\0')
    {
        Run(items);
    }
    /*4*/
    auto number = items.top().number;
    items.pop();
    return number;
}

void Push(stack<Item>& items, int number)
{
    /*5*/
    items.top().number = number;
    switch (/*6*/items.top().op)
    {
    case '*':case '/':
        Run(items);
    }
}

int Calculate(string text)
{
    stringstream ss(text);
    stack<Item> items;
    items.push({});

    while (true)
    {
        char op = ss.peek();
        switch (op)
        {
        case '(':
            /*1*/
                items.push({});
            break;
        case ')':
            Push(items, Pop(items));
            break;
        case '+':case '-':case '*':case '/':
            /*2*/
                items.push({op});
            break;
        }

        if (isdigit(op))
        {
            int number;
            ss >> number;
            Push(items, number);
        }
        else if (ss.eof())
        {
            return Pop(items);
        }
        else
        {
            ss.ignore();
        }
    }
}

int main()
{
    cout << Calculate("1") << endl;
    cout << Calculate("1+2") << endl;
    cout << Calculate("1+2*3+4") << endl;
    cout << Calculate("(11+22)*(33+44)") << endl;
    return 0;
}
```



![image-20210328182411421](/Image/B4.C++-others-photo/image-20210328182411421-1623668427118.png)

![image-20210328181913511](/Image/B4.C++-others-photo/image-20210328181913511-1623668427118.png)

.*优先级比()更高

![image-20210328181506470](/Image/B4.C++-others-photo/image-20210328181506470-1623668427118.png)



```c++
这当然是唯⼀的做法。如果 operator* 定义在类⾥⾯的话，那么第⼀个参数就是类⾃⼰，显
然 operator+ 是不能有三个参数的。还有⼀点需要注意的是，类的运算符不能定义为⼀个静态函
数。这⼀点恰好跟C#是相反的。
```



![image-20210328174813841](/Image/B4.C++-others-photo/image-20210328174813841-1623668427118.png)

![image-20210328174417771](/Image/B4.C++-others-photo/image-20210328174417771-1623668427118.png)

![image-20210328173359309](/Image/B4.C++-others-photo/image-20210328173359309-1623668427118.png)

![image-20210328170447235](/Image/B4.C++-others-photo/image-20210328170447235-1623668427118.png)

![image-20210328164441763](/Image/B4.C++-others-photo/image-20210328164441763-1623668427118.png)

B:3 C:3 D:3

![image-20210328163244337](/Image/B4.C++-others-photo/image-20210328163244337-1623668427118.png)

![image-20210328162402833](/Image/B4.C++-others-photo/image-20210328162402833-1623668427118.png)

reinterpret_cast 的意思是，不管类型之间的关系，强⾏将⼀个指针重新解释成另 ⼀个类型

![image-20210328143953987](/Image/B4.C++-others-photo/image-20210328143953987-1623668427118.png)

![image-20210328140321327](/Image/B4.C++-others-photo/image-20210328140321327-1623668427118.png)

![image-20210328140234757](/Image/B4.C++-others-photo/image-20210328140234757-1623668427118.png)

![image-20210328134426730](/Image/B4.C++-others-photo/image-20210328134426730-1623668427118.png)

```c++
析构函数写成 private ，或者写成 =delete ，那么这个类就不能被继承了，因为⼦类的析构函数⽆法调⽤⽗类的析构函数。
如果⽗类有虚析构函数，那么⼦类的析构函数⼀定是虚的，不需要写 virtual 关键字
```





```c++
编译器⽣成默认的复制构造函数和赋值操作符重载的规则吗？如果⽗类不存在这些函数的话，那么
⼦类默认也不会⽣成。那么最简单的做法就是让 Student 去private继承⾃ NotCopyable 。
class NotCopyable {
 public : 
    NotCopyable() = default;
   NotCopyable(const NotCopyable &) = delete; 
   NotCopyable(NotCopyable &&) = delete; 
    NotCopyable & operator=(const NotCopyable &) = delete;
    NotCopyable & operator=(NotCopyable &&) = delete;
};

struct Student : private NotCopyable
{
    string name;
    time_t birtyday;
};

```





![image-20210328104738963](/Image/B4.C++-others-photo/image-20210328104738963-1623668427118.png)

如果 X 是 Y 的内部类，那么 Y 能看到什么， X 就能看到什么。在这种情况下，不 受上⾯的规则的约束

![image-20210328112212375](/Image/B4.C++-others-photo/image-20210328112212375-1623668427118.png)

![image-20210328112141838](/Image/B4.C++-others-photo/image-20210328112141838-1623668427118.png)



![image-20210328111426831](/Image/B4.C++-others-photo/image-20210328111426831-1623668427118.png)

```c++
dynamic_cast 和 visitor 模式其实各有利弊。
dynamic_cast 的好处：
A：代码写起来直接。
B：每次添加新的⼦类，这个类和关于它的⼀组不同的逻辑，可以通过抽取函数来组织到同⼀个
⽂件⾥。
dynamic_cast 的坏处：
C：当你需要因为多个类型的不同⽽做不同的事情的时候，多个 if 和 dynamic_cast 会导致
性能低下（虽然其实不是很严重），代码结构也会相当混乱。
D：当你添加⼀个新的⼦类的时候，你要找到所有需要添加新分⽀的 if ，哪怕你测试⾜够，也
很容易出错。
E：添加关于所有类的⼀个新逻辑的时候，你⼜要写⼀⼤堆 if ，不仅混乱，⽽且编译器还⽆法
查漏补缺，很容易犯错误。
visitor 模式的好处：
C：因为这毕竟是⼀个O(1)跳转，不同的类只需要跳转⼀次就可以运⾏相应的函数（⽽不是
⽤ if ⼀个⼀个尝试），性能⾼。
D：当你添加⼀个新的⼦类的时候，只要你 visitor 接⼝的成员都是纯虚类，你很容易通过阅读
所有编译错误来找出所有需要修改。
E：添加关于所有的类的⼀个新的逻辑很容易，就是继承⾃接⼝，井井有条。
visitor 模式的坏处：
A：代码写起来⽐较曲折。
B：每次添加新的⼦类，都会修改很多相关的⽂件。但是在编译器的编译错误的帮助下，其实这
并不是⼀个令⼈恐怖的问题，只是看起来恐怖。
⼤家可以看出，这两种⽅法互有利弊，⽽且利弊是完全相反的。 dynamic_cast 的做法扩展新
的类容易，扩展新的逻辑困难。⽽ visitor 模式的做法，扩展新的类困难，扩展新的逻辑容易。
当然，哪怕 visitor 模式不好⽤，⼤家也不要⽴刻就使⽤ dynamic_cast 来搞乱⾃⼰的代码，⼆
⼗四个设计模式⾥⾯还有很多其他的内容可供选择。
```





```c++
static_cast 。它跟 dynamic_cast 的区别就是，他不回去检查 pAnimal 到底是不
是 Cat ，就直接转换给你。如果不是的话，你就会拿到⼀个野指针，使⽤它就会
发⽣ undefined behavior。
另外要提到的是， dynamic_cast 也可以在⽗类的⼏个⼦类下转换，如果不返
回 nullptr 就代表你的转换成功了，这个指针指向的的确是你需要的类型的对象。
⽽ static_cast 这样做会有语法错误
```




```
谁构造谁释放

我们在讨论继承的时候，脑⼦⾥要想的是：a cat ∈ {animal}。

⾥⽒代换原则的内容只有⼀句话：⼦类的对象能够替换其基类的对象被使⽤。举 个例⼦，任何使⽤ Animal 的地⽅，我们都可以放 Cat 进去，⽽完全不扰乱程序的逻 辑。⽽且程序⾥⾯关于 Animal 的假设， Cat 都不能打破。

```

``` cpp
struct cmp {
    bool operator()(int &a, int &b) {
        return a > b;
    }
};

priority_queue<int, vector<int>, cmp> que;

```

https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/

当程序运行funcA之前，j的值就确定了，而k的值是不确定的。k的值只有在funcA函数里面真正调用lambda表达式的时候才确定。这个程序还可以换一种更加明确的写法。

```cpp
void fun()
{
      int i=1;
      int j=2;
      function<bool(int)> f=[j](int k)(return k>j;);
      funcA(i, f);
}
```

当程序运行到创建f对象时，j的值是确定的（它其实被作为f的一个成员变量初始化了），而k的值是不确定的。注意lambda表达式是一种特殊的数据类型（即使它和某函数具有相同参数类型和返回值类型，它们也属于不同数据类型），编译器在编译的过程中会根据我们所写的lambda表达式自动产生一个数据类型。所以声明f对象的时候我们一般只能用auto f=[j](int k)(return k>j)，因为我们不知道它是什么类型。但是我们之前说过回调函数的类型在声明调用者的时候（也就是声明funcA的时候）就已经确定了。所以这里有点矛盾。这个矛盾需要另一个库模版函数类型funcion来解决。有了它，只要参数和返回值类型都相同就可以定义为同一种function类型。



![image-20210327220916334](/Image/B4.C++-others-photo/image-20210327220916334-1623668427118.png)

![image-20210327220903109](/Image/B4.C++-others-photo/image-20210327220903109-1623668427118.png)



![image-20201223214822348](/Image/B4.C++-others-photo/image-20201223214822348-1623668427118.png)

![image-20201223214345364](/Image/B4.C++-others-photo/image-20201223214345364-1623668427118.png)

![image-20210327215830460](/Image/B4.C++-others-photo/image-20210327215830460-1623668427118.png)

![image-20201223214051240](/Image/B4.C++-others-photo/image-20201223214051240-1623668427118.png)

![image-20210327215710837](/Image/B4.C++-others-photo/image-20210327215710837-1623668427118.png)

![image-20201223214008563](/Image/B4.C++-others-photo/image-20201223214008563-1623668427119.png)

![image-20201223213406320](/Image/B4.C++-others-photo/image-20201223213406320-1623668427119.png)

TDD测试驱动编程

gdb assert断言

单元测试技术

https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054



## C++多线程

### 条件变量和互斥锁

1. 释放m_mutex

2. wait :**已经释放互斥锁**

3. 拿到m_mutex

   

4. 拿到m_mutex

5. notify_one,**并不释放互斥锁**

6. 释放互斥锁

   

m_cond -相应串行

- notify_one :通知一个
- notify_all :通知所有
- wait 等待信号

通过互斥锁保证线程安全,抢到互斥锁,然后收到信号后执行 

### 线程安全

拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况

### 线程池

1. 多线程的数量

2. 能执行出入的任意函数

3. 执行过程,按优先级顺序

   Logger日志输出类

## thread+strong  

```cpp
 #ifndef _THREAD_POOL_H
#define _THREAD_POOL_H

#include <iostream>
#include <algorithm>
#include <thread>
#include <queue>
#include <condition_variable>
#include <mutex>

namespace haizei {

class Task {
public :
    template<typename Func_T, typename ...ARGS>
    Task(Func_T f, ARGS ...args) {
        func = std::bind(f, std::forward<ARGS>(args)...);
    }
    void run() {
        func();
    }
private:
    std::function<void()> func;
};

class thread_pool {
public:        
    thread_pool(int thread_size = 5) 
    : thread_size(thread_size),
      is_started(false),
      m_mutex(),
      m_cond(),
      m_queue_cond(),
      m_queue_mutex(),
      m_mutex2()
    {}
    void start();
    void stop();
    template<typename Func_T, typename ...ARGS>
    void add_one_task(Func_T f, ARGS...args) {
        std::unique_lock<std::mutex> lock(m_queue_mutex);
        __add_one_task(new Task(f, std::forward<ARGS>(args)...));
    }
    void stop_until_empty();
    ~thread_pool() { stop(); }

private:
    void thread_loop();
    Task *get_one_task();
    void __add_one_task(Task *);
    void __stop_set_false();

    int thread_size;
    volatile bool is_started;
    std::vector<std::thread *> Threads;
    std::queue<Task *> Tasks;

    std::mutex m_mutex, m_mutex2;
    std::mutex m_queue_mutex;
    std::condition_variable m_cond;
    std::condition_variable m_queue_cond;
};

void thread_pool::start() {
    std::unique_lock<std::mutex> lock(m_mutex);
    is_started = true;
    for (int i = 0; i < thread_size; i++) {
        Threads.push_back(new std::thread(&thread_pool::thread_loop, this));
    }
}

void thread_pool::stop_until_empty() {
    std::unique_lock<std::mutex> lock1(m_mutex2);
    std::unique_lock<std::mutex> lock2(m_queue_mutex);
    while (!Tasks.empty()) {
        m_queue_cond.wait(lock1);
    }
    stop();
    return ;
}

void thread_pool::stop() {
    {
        std::unique_lock<std::mutex> lock(m_mutex);
        is_started = false;
        m_cond.notify_all();
    }
    for (int i = 0; i < Threads.size(); i++) {
        Threads[i]->join();
        delete Threads[i];
    }
    Threads.clear();
    return ;
}

void thread_pool::thread_loop() {
    while (is_started) {
        Task *t = get_one_task();
        if (t != nullptr) {
            //std::cout << "thread_loop tid : " << std::this_thread::get_id() << std::endl;
            t->run();
        } 
    }
    return ;
}

Task* thread_pool::get_one_task() {
    std::unique_lock<std::mutex> lock(m_mutex);
    while (Tasks.empty() && is_started) {
        m_cond.wait(lock);
    }
    Task *t = nullptr;
    if (!Tasks.empty() && is_started) {
        t = Tasks.front();
        Tasks.pop();
        if (Tasks.empty()) {
            std::unique_lock<std::mutex> lock2(m_mutex2);
            m_queue_cond.notify_all();
        }
    }
    return t;
}

void thread_pool::__add_one_task(Task *t) {
    std::unique_lock<std::mutex> lock(m_mutex);
    Tasks.push(t);
    m_cond.notify_one();
    return ;
}

}

#endif

```

### Logger日志输出类

```cpp
#ifndef _LOGGER_HAIZEI_H
#define _LOGGER_HAIZEI_H
#include <iostream>
#include <sstream>
#include <mutex>

namespace worst {
class LoggerStream : public std::ostringstream {
public :
    LoggerStream() {}
    LoggerStream(const LoggerStream &ls) {}
    ~LoggerStream() {
        output();
    }
private:
    void output() {
        std::unique_lock<std::mutex> lock(m_mutex);
        std::cout << this->str() << std::endl;
        std::cout.flush();
        return ;
    }
    std::mutex m_mutex;
};

class Logger {
    class LoggerStream : public std::ostringstream {
    public :
        LoggerStream(Logger &raw_obj) : raw_obj(raw_obj) {}
        LoggerStream(const LoggerStream &ls) : raw_obj(ls.raw_obj) {}
        ~LoggerStream() {
            output();
        }
    private:
        void output() {
            std::unique_lock<std::mutex> lock(raw_obj.m_mutex);
            std::cout << this->str() << std::endl;
            std::cout.flush();
            return ;
        }
        Logger &raw_obj;
    };
public :
    LoggerStream operator()() {
        return LoggerStream(*this);
    }
private:
    std::mutex m_mutex;
};

}

```

### thread_pool

```cpp
#ifndef _THREAD_POOL_H
#define _THREAD_POOL_H

#include <iostream>
#include <algorithm>
#include <thread>
#include <queue>
#include <condition_variable>
#include <mutex>
namespace haizei {

class Task {
public :
    template<typename Func_T, typename ...ARGS>
    Task(Func_T f, ARGS ...args) {
        func = std::bind(f, std::forward<ARGS>(args)...);
    }
    void run() {
        func();
    }
private:
    std::function<void()> func;
};

class thread_pool {
public:        
    thread_pool(int thread_size = 5) 
    : thread_size(thread_size),
      is_started(false),
      m_mutex(),
      m_cond()
    {}
    void start();
    void stop();
    template<typename Func_T, typename ...ARGS>
    void add_one_task(Func_T f, ARGS...args) {
        __add_one_task(new Task(f, std::forward<ARGS>(args)...));
    }
    ~thread_pool() { stop(); }

private:
    void thread_loop();
    Task *get_one_task();
    void __add_one_task(Task *);
    void __stop_set_false();

    int thread_size;
    volatile bool is_started;
    std::vector<std::thread *> Threads;
    std::queue<Task *> Tasks;

    std::mutex m_mutex;
    std::condition_variable m_cond;
};

void thread_pool::start() {
    std::unique_lock<std::mutex> lock(m_mutex);
    is_started = true;
    for (int i = 0; i < thread_size; i++) {
        Threads.push_back(new std::thread(&thread_pool::thread_loop, this));
    }
}

void thread_pool::__stop_set_false() {
    std::unique_lock<std::mutex> lock(m_mutex);
    is_started = false;
    m_cond.notify_all();
    return ;
}

void thread_pool::stop() {
    __stop_set_false();
    for (int i = 0; i < Threads.size(); i++) {
        Threads[i]->join();
        delete Threads[i];
    }
    Threads.clear();
    return ;
}

void thread_pool::thread_loop() {
    while (is_started) {
        Task *t = get_one_task();
        if (t != nullptr) {
            std::cout << "thread_loop tid : " << std::this_thread::get_id() << std::endl;
            t->run();
        } 
    }
    return ;
}

Task* thread_pool::get_one_task() {
    std::unique_lock<std::mutex> lock(m_mutex);
    while (Tasks.empty() && is_started) {
        m_cond.wait(lock);
    }
    Task *t = nullptr;
    if (!Tasks.empty() && is_started) {
        t = Tasks.front();
        Tasks.pop();
    }
    return t;
}

void thread_pool::__add_one_task(Task *t) {
    std::unique_lock<std::mutex> lock(m_mutex);
    Tasks.push(t);
    m_cond.notify_one();
    return ;
}

}

#endif
```





## handle责任链模式

```cpp
//交给工厂,能且只能有工厂创建对象
class ICar {
public :
    class IFactory {
    public :
        virtual ICar *create() = 0;    
    };
    class IHandler {
    public :
        IHandler() : next(nullptr) {}
        virtual bool is_valid(int) = 0;
        virtual ICar *do_it() = 0;
        IHandler *next;
    };
    virtual void runc() = 0;
protected :
    ICar() {}
    ~ICar() {}
};


class BenzCar : public ICar {
    BenzCar() {}
public :
    class Factory : public ICar::IFactory, public ICar::IHandler {
    public :
        virtual ICar *create() override {
            return new BenzCar();
        }
        virtual bool is_valid(int x) override {
            return x == 0;
        }
        virtual ICar *do_it() override {
            return this->create();
        }
    };
    virtual void runc() override {
        cout << "BenzCar run" << endl;
    }
};
class BmwCar : public ICar {
    BmwCar() {}
public:
    class Factory : public ICar::IFactory, public ICar::IHandler {
    public :
        virtual ICar *create() override {
            return new BmwCar();
        }
        virtual bool is_valid(int x) override{
            return x == 1;
        }
        virtual ICar *do_it() override {
            return this->create();
        }
    };
    virtual void runc() override {
        cout << "BmwCar run" << endl;
    }
};
class AudiCar : public ICar {
    AudiCar() {}
public :
    class Factory : public ICar::IFactory, public ICar::IHandler {
    public :
        virtual ICar *create() override {
            return new AudiCar();
        }
        virtual bool is_valid(int x) override {
            return x == 2;
        }
        virtual ICar *do_it() override {
            return this->create();
        }
    };
    virtual void runc() override {
        cout << "AudiCar run" << endl;
    }
};

class ChainMaster {
public :
    static ICar::IHandler *getInstance() {
        if (head == nullptr) {
            buildChain();
        }
        return head;
    }
private :
    static ICar::IHandler *head;
    static void buildChain() {
        head = new BmwCar::Factory(); 
        head->next = new AudiCar::Factory();
        head->next->next = new BenzCar::Factory();
        return ;
    }
};
ICar::IHandler* ChainMaster::head = nullptr;

int main() {
    srand(time(0));
    ICar *cars[10];
    for (int i = 0; i < 10; ++i) {
        int request = rand() % 3;
        for (auto p  = ChainMaster::getInstance(); p; p = p->next) {
            if (p->is_valid(request)) {
                cars[i] = p->do_it();
                break;
            }
        }
    }
    for (int i = 0; i < 10; ++i) {
        cars[i]->runc();
    }
    return 0;
}
```



## factory抽象工厂模式

```cpp
//交给工厂,能且只能有工厂创建对象
class ICar {
public :
    class IFactory {
    public :
        virtual ICar *create() = 0;    
    };
    virtual void runc() = 0;
protected :
    ICar() {}
    ~ICar() {}
};


class BenzCar : public ICar {
    BenzCar() {}
public :
    class Factory : public ICar::IFactory {
    public :
        virtual ICar *create() {
            return new BenzCar();
        }
    };
    virtual void runc() {
        cout << "BenzCar run" << endl;
    }
};
class BmwCar : public ICar {
    BmwCar() {}
public:
    class Factory : public ICar::IFactory {
    public :
        virtual ICar *create() {
            return new BmwCar();
        }
    };
    virtual void runc() {
        cout << "BmwCar run" << endl;
    }
};
class AudiCar : public ICar {
    AudiCar() {}
public :
    class Factory : public ICar::IFactory {
    public :
        virtual ICar *create() {
            return new AudiCar();
        }
    };
    virtual void runc() {
        cout << "AudiCar run" << endl;
    }
};

ICar::IFactory *fac[3] = {new BenzCar::Factory(), new BmwCar::Factory(), new BmwCar::Factory()};

int main() {
    srand(time(0));
    ICar *cars[10];
    for (int i = 0; i < 10; ++i) {
        cars[i] = fac[rand() % 3]->create();
    }
    for (int i = 0; i < 10; ++i) {
        cars[i]->runc();
    }
    return 0;
}
```



## singleton单例模式

```cpp
class HttpServer {
public :
    static HttpServer *getInstance() {
        //多线程有内存泄漏,加锁
        //双重验证,可以允许读,解决效率问题
        if (instance == nullptr) { //防止无意义的重复加锁
            std::unique_lock<std::mutex> lock(m_mutex);
            if (instance == nullptr) { //防止内存泄露
                instance = new HttpServer();
            } 
        }
        return instance;
    }

private :
    static HttpServer *instance;
    static std::mutex m_mutex;
    HttpServer() {}
    HttpServer(const HttpServer &) = delete;
    ~HttpServer() {}
};

//HttpServer *HttpServer::instance = new HttpServer(); //恶汉模式,直接初始化
HttpServer *HttpServer::instance = nullptr; //懒汉模式,加锁,判断,需要时在初始化
std::mutex HttpServer::m_mutex;

int main() {
    /*
    HttpServer h1;
    HttpServer h2(h1);
    HttpServer h3 = h1;
    */
    HttpServer *t1 = HttpServer::getInstance();
    HttpServer *t2 = HttpServer::getInstance();
    cout << t1 << " " << t2 << endl;
    return 0;
}

```



## visitor访问者模式

```cpp
class B;
class C;
class D;
class E;
class F;

class A {
public :
    class IVisitor {
    public : 
        virtual void visit(A *) = 0;
        virtual void visit(B *) = 0;
        virtual void visit(C *) = 0;
    };
    //virtual void Accept(IVisitor *) = 0;
    virtual void Accept(IVisitor *vis) {
           vis->visit(this); 
    }
    virtual ~A() {}
};

class B : public A {
public :
    void Accept(IVisitor *vis) {
        vis->visit(this);
    }
};
class C : public A {
public :
    void Accept(IVisitor *vis) {
        vis->visit(this);
    }
};

class OutputVisitor : public A::IVisitor {
    virtual void visit(A *obj) {
        cout << "this is a class A father" << endl;
    }
    virtual void visit(B *obj) {
        cout << "this is a class B object" << endl;
    }
    virtual void visit(C *obj)  {
        cout << "this is a class C object" << endl;
    }
};

class CalcVisitor : public A::IVisitor {
    virtual void visit(A *obj) {
        cout << ans << endl;
    }
    virtual void visit(B *obj) {
        ans += 5;
        cout << "+5 : " << " " << ans << endl;
    }
    virtual void visit(C *obj)  {
        ans *= 2;
        cout << "*2 : " << " " << ans << endl;
    }
public :
    //static int ans;
    CalcVisitor(int ans = 1) : ans(ans) {}
    int ans;
};

//int CalcVisitor::ans = 0;


int main() {
    A *arr[10];
    for (int i  = 0; i < 10; ++i) {
        switch (rand() % 4) {
            case 0 : arr[i] = new B(); break;        
            case 1 : arr[i] = new C(); break;        
            case 2 : arr[i] = new D(); break;        
            case 3 : arr[i] = new E(); break;        
        }
    }

    //dynamic_cast : 还原原对象的地址,通过虚函数表地址判断,所以原有基类一定是抽象类(virtual)
    //有父类指针到子类指针根据不同类型做不同功能映射
    //如果少加一个派生类的条件分支if-else就会出错
    //visitor访问者模式,解决功能映射
    OutputVisitor vis1;
    CalcVisitor vis2;
    for (int i = 0; i < 10; ++i) {
        arr[i]->Accept(&vis1);
        arr[i]->Accept(&vis2);
    }
//    cout << CalcVisitor::ans << endl;
    cout << vis2.ans << endl;
    return 0;
}
```

### 访问者模式

```cpp
class A {
public :
    virtual ~A() {}
};

class B : public A {};
class C : public A {};
class D : public A {};
class E : public A {};

int main() {
    A *arr[10];
    for (int i  = 0; i < 10; ++i) {
        switch (rand() % 4) {
            case 0 : arr[i] = new B(); break;        
            case 1 : arr[i] = new C(); break;        
            case 2 : arr[i] = new D(); break;        
            case 3 : arr[i] = new E(); break;        
            default : arr[i] = new A(); break;
        }
    }

    //dynamic_cast : 还原原对象的地址,通过虚函数表地址判断,所以原有基类一定是抽象类(virtual) 父类指针->子类指针
    
    //析构函数设为virtual 为了析构和dynamic_cast
    
    //有父类指针到子类指针根据不同类型做不同功能映射
    //添加一个派生类，如果少加一个派生类的条件分支if-else就会出错
    //visitor访问者模式,解决功能映射
    
    //实现添加一个派生类，而忘了添加某个功能时，编译器报错
    
    for (int i = 0; i < 10; ++i) {
        if(dynamic_cast<B *>(arr[i])) {
            cout << "this is a class B object" << endl;
        } else if (dynamic_cast<C *> (arr[i])) {
            cout << "this is a class C object" << endl;
        } else if (dynamic_cast<D *> (arr[i])) {
            cout << "this is a class D object" << endl;
        } else {
            cout << "this is a error class pointer" << endl;
        }
    }
    return 0;
}

```



## 设计模式

面向对象的编程范式，指导程序设计的方式方法



## 值的类型和移动构造

````cpp
void judge2(int &x) {
    cout << " int function 2 " << x << " is left value" << endl;
    return ;
}

void judge2(int &&x) {
    cout << " int function 2 " << x << " is right value" << endl;
    return ;
}

void judge(int &x) {
    cout << x << " is left value" << endl;
    //judge2(x); // x是左值
    judge2(move(x));
    return ;
}

void judge(int &&x) {
    cout << x << " is right value" << endl;
   // judge2(x); // x虽然是右值引用但是左值
    judge2(forward<int &&>(x));
    return ;
}

class A {
public :
    A(int n  = 10) : n(n) {
        arr = new int[n];
        for (int i = 0; i < n; ++i) arr[i] = i;
        cout << "constructor" << endl;
    }
    A(const A &obj) : n(obj.n) { //拷贝构造:左值引用
        this->arr = new int[n];
        for (int i = 0; i < n; ++i) this->arr[i] = obj.arr[i];
        cout << "copy constructor" << endl;
    }
    A(A &&obj) : n(obj.n), arr(obj.arr) { //移动构造:右值引用
        cout << "move constructor" << endl;
        obj.arr = nullptr;
    }
    A operator+(const A &obj) {
        A temp(this->n + obj.n);
        for (int i = 0; i < this->n; ++i) temp.arr[i] = this->arr[i];
        for (int i = 0; i < obj.n; ++i) temp.arr[i + this->n] = obj.arr[i];
        return temp;
    }
    void output() {
        for (int i = 0; i < n; ++i) {
            cout << arr[i] << " ";
        }
        cout << endl;
        return ;
    }
    ~A() {
        cout << "destructor" << endl;
        delete[] arr;
    }

private:
    int *arr, n;
};

int main() {
    int n = 123;
    //越过该行代码,还能否相关的值,能左值,不能右值
    cout << (n++) << endl; //右值,简单理解:临时的变量,不可以修改的
    cout << (++n) << endl; //左值,简单理解:可以操作的变量,可引用
    //结合重载++运算符理解
    cout << (++n)++ << endl;
    //cout << (n++)++ << endl;
    cout << "++n ";
    judge(++n);
    cout << "n++ ";
    judge(n++);
    /*
     * ++n 128 is left value
     * int function 2 128 is left value
     * n++ 128 is right value
     * int function 2 128 is left value 
    */
    //move强制变右值
    //forward变成任意类型的值，向前传递
    //为了解决完美传值过程
    
    A *p = new A();
    A a = move(*p); //节约开辟对象空间,深拷贝,直接移动相关存储区的指向 O(n)->O(1)
    delete p;
    a.output();
    return 0;
}

````



## lambda

```cpp
/*************************************************************************
   > File Name: 16.lambda.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 六 11/ 9 20:12:26 2019
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;

auto add = [](int a, int b) -> long long {
    return a + b;
};

auto Data = [](int a, int b) {
    return [=](auto func) {
        return func(a, b);
    };
};

auto First = [](int a, int b) {
    return a;
};

auto Second = [](int a, int b) {
    return b;
};

auto Add = [](int a, int b) {
    return a + b;
};

auto Max = [](int a, int b) {
    return max(a, b);
};

auto is_in = [](int a, int b) {
    return [=](int x) {
        return a <= x && x <= b;
    };
};

auto OR = [](auto u, auto v) {
    return [=](int x) {
        return u(x) || v(x);
    };
};

auto NOT = [](auto u) {
    return [=](int x) {
        return !u(x);
    };
};

auto is_little = is_in('a', 'z');
auto is_upper = is_in('A', 'Z');
auto is_digit = is_in('0', '9');
auto is_alpha = OR(is_little, is_upper);
auto other = NOT(is_alpha);

function<int()> Temp_Func() {
    int a = 23;
    return [=]() -> int {
        return a;
    };
}

int main() {
    cout << is_little('A') << endl;
    cout << is_little('a') << endl;
    cout << is_alpha('a') << endl;
    cout << is_alpha('A') << endl;
    cout << other('A') << endl;
    cout << other('9') << endl;
    cout << add(2, 4) << endl;
    auto func = Temp_Func();
    cout << func() << endl;
    auto a = Data(rand() % 1000, rand() % 1000);
    cout << a(First) << endl;
    cout << a(Second) << endl;
    cout << a(Add) << endl;
    cout << a(Max) << endl;
    return 0;
}
```



## 1 const 常量的判别准则

- 只有用字面量初始化的 const 常量才会进入符号表
- 使用其他变量初始化的 const 常量仍然是只读变量
- 被 volatile 修饰的 const 常量不会进入符号表



**《c++primer》里面说在类外定义和初始化是保证static成员变量只被定义一次的好方法。 但为什么static const int就可以在类里面初始化呢？** 
**想起C中一个函数里定义一个static变量是为了保证只初始化一次。**

“类的静态成员必须在类外初始化”这一语法是受继承自 C 的编译模型所限。在 C 的经典惯例中，头文件中只放声明（包括函数声明、extern 引导的外部变量声明等），不放实现（包括实现函数的函数体，以及变量的初始化等），而源文件中给出实现。每个源文件构成一个基本的编译单元，各个编译单元之间在编译时没有任何的信息共享。

举个栗子，b.c 想用到 a.c 中的函数 void fun() / 全局变量，它可以在自己的文件开头写下声明语句 void fun(); / extern int x; 但是，更佳的实现方式是 a 模块提供一个头文件 a.h，在里面给出本模块所有对外暴露的函数/全局变量的声明，给 b.c 去 include。但是，如果 b.c 既不是自己写声明语句，也不 include 别的头文件里写的声明语句，而是在自己内部写出 void fun 的函数体，或者是 int x; 或者 int x = 0; 这种定义语句，那么，尽管 b.c 在被编译为 b.o 的过程中不会出编译错误，但是在 b.o 与 a.o 链接时，就会出现符号冲突。





## constexpr

```cpp
constexpr int f(int i) {
    return 2 * i;
}

struct A {
    constexpr A(int x, int y) : x(x), y(y) {}
    int x, y;
};

int main() {
    int n;
    cin >> n;
    const int a = n + 3;
    constexpr int b = f(123) + 567;
    cout << f(n) << endl;
    constexpr A c(2, 3);
    A d(n, 4);
    return 0;
}
```

## nullptr

```cpp
void f(int x) {
    cout << x << endl;
    return ;
}

void f(int *p) {
    cout << p << endl;
    return ;
}

int main() {
    int n = 123;
    f(n);
    f(&n);
    f(nullptr);
    return 0;
}
```

## auto和随机种子原理

计算机时间是变量，每次程序运行都一定不同，作为随机种子，确定随机序列初始值

随机函数更加复杂，但也是一系列公式

```cpp
string randstring(int n) {
    string ret = "";
    for (int i =0; i < n; i++) {
        char ch = rand() % 26 + 'A';
        ret += ch;
    }
    return ret;
}

int my_seed = 1;
void my_srand(int seed) {
    my_seed = seed;
}

int my_rand() {
    my_seed = my_seed * 3 % 101;
    return my_seed;
}

int main() {
    my_srand(time(0));
    for (int i = 0; i < 100; i++) {
        cout << my_rand() << endl;
    }
    srand(time(0));
    map<string, int> ind;
    for (int i = 0; i < 10; i++) {
        ind[randstring(rand() % 10 + 3)] = rand();
    }
    auto iter = ind.begin();
    for (; iter != ind.end(); iter++) {
        cout << iter->first << " " << iter->second << endl;
    }
    for (auto x : ind) {
        cout << x.first << " " << x.second << endl;
    }
    return 0;
} 
```

## hash_table

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <unordered_map>
#include <cmath>
#include "9.hash_table.h"
using namespace std;

namespace haizei {
    template<typename T, typename U>
    struct pair {
        pair() : first(), second() {}
        pair(const T &a) : first(a), second() {}
        pair(const T &a, const U &b) : first(a), second(b) {}
        T first;
        U second;
    };
    template<typename K> struct hash;
    template<>
    struct hash<int> {
        size_t operator()(int x) {
            return x;
        }
    };
    
    template<>
    struct hash<double> {
        size_t operator()(double x) {
            return *((size_t *)(&x));
        }
    };

    template<typename K, typename T, typename HashT = haizei::hash<K>>
    class unordered_map {
    public:
        unordered_map(size_t size = 100) : size(size) {
            this->data = new pair<K, T> *[size];
            this->map = new bool[size];
            for (int i = 0; i < size; i++) {
                this->data[i] = nullptr;
                this->map[i] = false;
            }
        }
        T &operator[](const K &a) {
            size_t ind;
            T *value = this->find(a, ind);
            if (ind == -1) return *this->end();
            if (value == this->end()) {
                this->data[ind] = new pair<K, T>(a);
                this->map[ind] = true;
            }
            return this->data[ind]->second;
        }
        T *end() { return (T *)(0); }
        T *find(const K &a, size_t &ind) {
            ind = hash_func(a);
            ind %= this->size;
            size_t times = 1;
            while (this->map[ind] && !(this->data[ind]->first == a)) {
                ind += times * times;
                ind %= this->size;
                times += 1;
                if (times == this->size) {
                    ind = -1;
                    return this->end();
                }
            }
            if (this->map[ind]) return &(this->data[ind]->second);
            return this->end();
        }
    private:
        size_t size;
        pair<K, T> **data;
        bool *map;
        HashT hash_func;
    };
}
struct A {
    A(int x, int y) : x(x), y(y) {}
    int x, y;
    bool operator==(A const &a) const {
        return this->x == a.x && this->y == a.y;
    }
};

struct myhash {
    int operator()(A const &a) const {
        return a.x + a.y;
    }
};

int main() {
    A a(0, 9), b(10, 12);
    unordered_map<A, int, myhash> arr;
    arr[a] = 1;
    arr[b] = 2;
    cout << arr[a] << endl;
    cout << arr[b] << endl;
    haizei::unordered_map<int, int> arr2;
    arr2[129883] = 65;
    arr2[623] = 23;
    cout << arr2[129883] << endl;
    cout << arr2[623] << endl;

    haizei::unordered_map<A, int, myhash> arr3;
    arr3[a] = 1;
    arr3[b] = 2;
    cout << arr3[a] << endl;
    cout << arr3[b] << endl;
    return 0;
}

```

## 二叉排序树

```cpp
#ifndef _BSTREE_H
#define _BSTREE_H

#include <memory>
#include <iostream>

namespace haizei {

template<typename T>
class BSNode {
public :
    BSNode(const T &data) 
    : data(data), lchild(nullptr), rchild(nullptr), father() {
        std::cout << "Node constuctor" << std::endl;
    }
    bool operator<(const BSNode<T> &obj) {
        return this->data < obj.data;
    }
    bool operator>(const BSNode<T> &obj) {
        return obj.data < this->data;
    }
    bool operator!=(const BSNode<T> &obj) {
        return (this->data < obj.data) || (obj.data < this->data);
    }
    bool operator==(const BSNode<T> &obj) {
        return !(*this != obj);
    }
    std::weak_ptr<BSNode<T> > father;
    std::shared_ptr<BSNode<T>> lchild, rchild;
    ~BSNode() {
        std::cout << "destructor" << std::endl;
    }
    T data;
};

template<typename T>
class BSTree_helper {
public :
    static std::shared_ptr<BSNode<T> > get_next(std::shared_ptr<BSNode<T> > p) {
        if (p->rchild != nullptr) {
            p = p->rchild;
            while (p->lchild != nullptr) p = p->lchild;
            return p;
        }
        while (p->father.lock() != nullptr && p->father.lock()->rchild == p) p = p->father.lock();
        if (p->father.lock() == nullptr) return p;
        return p->father.lock();
    }
};

template<typename T>
class BSTree_iterator {
    using helper = BSTree_helper<T>;
public :
    BSTree_iterator() : node(nullptr) {}
    BSTree_iterator(std::shared_ptr<BSNode<T> > node) : node(node) {}
    BSTree_iterator<T> &operator++() {
        node = helper::get_next(node);
        return *this;
    }
    BSTree_iterator<T> operator++(int) {
        BSTree_iterator iter(*this);
        node = helper::get_next(node);
        return iter;
    }
    bool operator==(const BSTree_iterator<T> &iter) {
        return this->node == iter.node;
    }
    bool operator!=(const BSTree_iterator<T> &iter) {
        return this->node != iter.node;
    }
    T &operator*() {
        return node->data;
    }

private:
    std::shared_ptr<BSNode<T> > node;
};

template<typename T>
struct BSTree {
public :
    typedef BSTree_iterator<T> iterator;
    BSTree() : root(std::make_shared<BSNode<T> >(T())) {}
    void insert(const T &data) {
        std::shared_ptr<BSNode<T> > p = this->root;
        std::shared_ptr<BSNode<T> > new_node = std::make_shared<BSNode<T> >(data);
        if (p->lchild == nullptr) {
            p->lchild = new_node;
            new_node->father = p;
            return ;
        }
        p = p->lchild;
        while (*p != *new_node) {
            if (*p > *new_node) {
                if (p->lchild == nullptr) {
                    p->lchild = new_node;
                    new_node->father = p;
                    break;
                }
                p = p->lchild;
            } else {
                if (p->rchild == nullptr) {
                    p->rchild = new_node;
                    new_node->father = p;
                    break;
                }
                p = p->rchild;
            }
        }
        return ;
    }
    iterator begin() {
        if (root->lchild == nullptr) return iterator(root);
        return iterator(root->lchild);
    }
    iterator end() {
        return iterator(root);
    }

private:
    std::shared_ptr<BSNode<T> > root;
};

}

#endif
```



## bind

高端库,多线程,网络模块库;

```cpp
void func(int x, int y, int z) {
    cout << x + y << " is a number" << endl;
    cout << z << " is a number" << endl;
}

struct A {
    void say() {
        cout << this << " : saying" << endl;
    }
    void run() {
        cout << "hello world" << endl;
    }
};

void count_function_times(function<void()> &p, int &cnt) {
    p();
    cnt += 1;
    return ;
}

int main() {
    function<void(int, int)> f1 = bind(func, 123, std::placeholders::_2, std::placeholders::_1);
    f1(100, 456);
    f1(200, 789);
    A a;
    cout << &a << endl;
    function<void()> f2 = bind(&A::say, ref(a));
    f2();
    int cnt = 0;
    function<void()> f3 = bind(&A::run, ref(a));
    function<void()> f4 = bind(count_function_times, ref(f3), ref(cnt));
    for (int i = 0; i < rand() % 10; i++) f4();
    cout << cnt << endl;
    return 0;
}
```

## 模板的图灵完备性

模板是编译期之前，可理解为编译期函数

```cpp
template<int x>
struct IsOdd {
    constexpr static int r = x % 2;
};

template<int i, int x>
struct getNextK {
    constexpr static int r = (i * i > x ? 0 : (x % i == 0 ? 1 : 2));
};

template<int i, int x, int k>
struct Test {
    constexpr static int r = Test<i + 1, x, getNextK<i, x>::r >::r;
};

template<int i, int x>
struct Test<i, x, 0> {
    constexpr static int r = 1;
};

template<int i, int x>
struct Test<i, x, 1> {
    constexpr static int r = 0;
};

template<int x>
struct is_prime {
    constexpr static int r = Test<2, x, 2>::r;
};

template<int i, int x>
struct getNextK2 {
    constexpr static int r = (i > x ? 0 : 1);
};

template<int i, int x, int k>
struct __calc_count_prime {
    constexpr static int r = i * is_prime<i>::r + __calc_count_prime<i + 1, x, getNextK2<i + 1, x>::r >::r;
};

template<int i, int x>
struct __calc_count_prime<i, x, 0> {
    constexpr static int r = 0;
};

template<int x>
struct count_prime {
    constexpr static int r = __calc_count_prime<2, x, 1>::r;
};

template<int i, int x, int k>
struct __calc_count_odd {
    constexpr static int r = i * IsOdd<i>::r + __calc_count_odd<i + 1, x, getNextK2<i + 1, x>::r >::r;
};

template<int i, int x>
struct __calc_count_odd<i, x, 0> {
    constexpr static int r = 0;
};

template<int x>
struct count_odd {
    constexpr static int r = __calc_count_odd<1, x, 1>::r;
};

template<int x>
struct print_prime {
    template<int i, int k>
    struct __output {
        static void run() {
            if (is_prime<i>::r) {
                cout << i << endl;
            }
            print_prime<x>::__output<i + 1, getNextK2<i + 1, x>::r >::run();
        }
    };
    template<int i>
    struct __output<i, 0> {
        static void run() {
            return ;
        }
    };
    static void output() {
        print_prime<x>::__output<2, 1>::run();
        return ;
    }
};

template<int x, int k>
struct __get_next_prime {
    constexpr static int r = __get_next_prime<x + 1, is_prime<x + 1>::r >::r;
};

template<int x>
struct __get_next_prime<x, 1> {
    constexpr static int r = x;
};

template<int x>
struct get_next_prime {
    constexpr static int r = __get_next_prime<x + 1, is_prime<x + 1>::r >::r;
};

template<int n>
struct print_trangle {
    template<int i, int m, int k>
    struct __output_line {
        static void run() {
            cout << "-";
            __output_line<i + 1, m, getNextK2<i + 1, m>::r >::run();
        }
    };
    template<int i, int m>
    struct __output_line<i, m, 0> {
        static void run() {
            cout << endl;
        }
    };
    template<int i, int k>
    struct __output {
        static void run() {
            __output_line<1, i, 1>::run();
            __output<i + 1, getNextK2<i + 1, n>::r >::run();
        }
    };
    template<int i>
    struct __output<i, 0> {
        static void run() {
            return ;
        }
    };
    
    static void output() {
        __output<1, 1>::run();
    }
};

int main() {
    cout << IsOdd<5>::r << endl;
    cout << IsOdd<6>::r << endl;
    cout << is_prime<9973>::r << endl;
    cout << is_prime<10000>::r << endl;
    cout << count_prime<100>::r << endl;
    cout << count_prime<10>::r << endl;
    cout << count_odd<10>::r << endl;
    print_prime<100>::output();
    cout << get_next_prime<5>::r << endl; 
    cout << get_next_prime<12>::r << endl;
    print_trangle<4>::output(); 
    print_trangle<6>::output(); 
    return 0;
}
```

## 引用折叠

![image-20210321223517051](/Image/B4.C++-others-photo/image-20210321223517051-1623668427119.png)

```cpp
template<typename T>
void my_swap(T &&a, T &&b) {
    typename remove_reference<T>::type c;
    c = a;
    a = b;
    b = c;
    return ;
}

template<typename T>
void add(T &&a, T &&b) {
    a += 3;
    b += 4;
    return ;
}

void func(void (*p)(int &, int &), int &a, int &b) {
    p(a, b);
    return ;
}

template<typename T>
typename remove_reference<T>::type &&my_move(T &&a) {
    return static_cast<typename remove_reference<T>::type &&>(a);
}

template<typename T> 
struct my_remove_reference {
    typedef T type;  
};

template<typename T> 
struct my_remove_reference<T &> {
    typedef T type;  
};

template<typename T> 
struct my_remove_reference<T &&> {
    typedef T type; 
};

void func(int &a) {
    cout << "left value" << endl;
}

void func(int &&a) {
    cout << "right value" << endl;
}

int main() {
    int a = 123, b = 456;
    cout << a << " " << b << endl;
    my_swap(a, b);
    cout << a << " " << b << endl;
    my_swap(move(a), move(b));
    cout << a << " " << b << endl;
    func(add, a, b);
    cout << a << " " << b << endl;
    my_swap(my_move(a), my_move(b));
    func(a);
    func(my_move(a));
    typename my_remove_reference<int>::type c;
    typename my_remove_reference<int &>::type d;
    typename my_remove_reference<int &&>::type e;
    return 0;
}
```



## 右值



## 可变参数模板

```cpp
template<typename T>
void print(const T &a) {
    cout << a << endl;
}

template<typename T, typename ...ARGS>
void print(const T &a, ARGS ...args) {
    cout << a << " ";
    print(args...);
    return ;
}

template<int n, typename T, typename ...ARGS>
struct ARG {
    typedef typename ARG<n - 1, ARGS...>::getT getT;
    typedef ARG<n - 1, ARGS...> N;
};

template<typename T, typename ...ARGS>
struct ARG<0, T, ARGS...> {
    typedef T getT;
};

template<typename T>
struct ARG<0, T> {
    typedef T getT;
    typedef T finalT;
};

template<typename T, typename ...ARGS> class Test;
template<typename T, typename ...ARGS>
class Test<T(ARGS...)> {
public :
    T operator()(typename ARG<0, ARGS...>::getT a, typename ARG<1, ARGS...>::N::finalT b) {
        return a + b;
    }
};

int main() {
    print(123, 23.5, "hello world", 'o');
    Test<int(double, float)> d;
    cout << d(2.3, 4.5) << endl;
    return 0;
}
```

## 可变参1



![image-20210321202920432](/Image/B4.C++-others-photo/image-20210321202920432.png)

```cpp
template<typename T, typename ...ARGS>
struct ARG {
    typedef T getT;  
    typedef ARG<ARGS...> rest;
};

template<typename T>
struct ARG<T> {
    typedef T getT;
    typedef T finalT;
};

template<typename T, typename ...ARGS> class Test; //偏特化版本
template<typename T, typename ...ARGS> 
class Test<T(ARGS...)> {
//template<typename T, typename ...ARGS>
//class Test {
//    Test<int, double, float> d;
public :
    T operator()(typename ARG<ARGS...>::getT a, typename ARG<ARGS...>::rest::finalT b) {
        return a + b;
    }
};

int main(){
    print(123, "hello world", 78.9, '0');
    cout << sizeof(ARG<int,double, char>::getT) << endl;
    cout << sizeof(ARG<int,double, char>::rest::getT) << endl;
    cout << sizeof(ARG<int,double, char>::rest::rest::getT) << endl;
    ARG<int, double, char>::getT a = 1;
    ARG<int, double, char>::rest::getT b = 1.112;
    ARG<int, double, char>::rest::rest::getT c = 'a';
    cout << a << " " << b << " " << c << endl;
//    Test<int, double, float> d;
    Test<int(double, float)> d;
    //Test<int(double, float, char)> e;
    //Test<int(double)> f;
    //ARG<int, double, double, float, int>::rest::rest::rest::rest::getT g;
    //ARG<4, int, double, int, int, int>
    cout << d(2.3, 4.5) << endl;
    return 0;
}

```





对象文件：存函数代码，模板不出现在对象文件中

模板会自动推导参数类型，进行实例化，在编译之前。



## 模板Array

```cpp
template<typename T, typename ...ARGS>
struct ARG {
    typedef T getT;  
    typedef ARG<ARGS...> rest;
};

template<typename T>
struct ARG<T> {
    typedef T getT;
    typedef T finalT;
};

template<typename T, typename ...ARGS> class Test; //偏特化版本
template<typename T, typename ...ARGS> 
class Test<T(ARGS...)> {
//template<typename T, typename ...ARGS>
//class Test {
//    Test<int, double, float> d;
public :
    T operator()(typename ARG<ARGS...>::getT a, typename ARG<ARGS...>::rest::finalT b) {
        return a + b;
    }
};

int main(){
    print(123, "hello world", 78.9, '0');
    cout << sizeof(ARG<int,double, char>::getT) << endl;
    cout << sizeof(ARG<int,double, char>::rest::getT) << endl;
    cout << sizeof(ARG<int,double, char>::rest::rest::getT) << endl;
    ARG<int, double, char>::getT a = 1;
    ARG<int, double, char>::rest::getT b = 1.112;
    ARG<int, double, char>::rest::rest::getT c = 'a';
    cout << a << " " << b << " " << c << endl;
//    Test<int, double, float> d;
    Test<int(double, float)> d;
    //Test<int(double, float, char)> e;
    //Test<int(double)> f;
    //ARG<int, double, double, float, int>::rest::rest::rest::rest::getT g;
    //ARG<4, int, double, int, int, int>
    cout << d(2.3, 4.5) << endl;
    return 0;
}

```

## 哈希函数

```cpp
class Node {
public :
    Node() : flag(false), str(nullptr) {}
    void clear() {
        this->flag = false;
        if (this->str) free(this->str);
        this->str = nullptr;
        return ;
    }
    void insert(const char *str) {
        this->clear();
        this->flag = true;
        this->str = strdup(str);
        return ;
    }
    bool empty() { return this->flag == false; }
    bool operator!=(const char *str) {
        if (this->str == nullptr) return true;
        return strcmp(this->str, str) != 0;
    }
    bool operator==(const char *str) {
        return !((*this) != str);
    }
    ~Node() {
        if (this->str) free(this->str);
        this->str = nullptr;
    }
private :
    bool flag;
    char *str;
};

class HashFunc {
public :
    virtual int operator()(const char *str) const = 0;
};

class HashTable {
public :
    typedef function<int(const char *)> HashFunc_T;
    HashTable(HashFunc_T func);
    bool insert(const char *str);
    bool find(const char *str);
    ~HashTable();
private:
    Node &find_position(const char *str);
    int _size;
    Node *data;
    HashFunc_T p_func;
};

class BKDRHash : public HashFunc {
public :
    int operator()(const char *str) const {
        int seed = 31;
        int hash_value = 0;
        for (int i = 0; str[i]; i++) {
            hash_value = hash_value * seed + str[i];
        }
        return hash_value & 0x7fffffff;
    }
};

int APHash(const char *str) {
    int hash = 0;
    for (int i = 0; str[i]; i++) {
        if (i % 2) {
            hash = (hash << 3) ^ str[i] ^ (hash >> 5);
        } else {
            hash = ~((hash << 7) ^ str[i] ^ (hash >> 11));
        }
    }
    return hash & 0x7fffffff;
}

int main() {
    BKDRHash bkdr_func;
    HashTable h1(bkdr_func), h2(APHash);
    int op;
    char str[100];
    while (cin >> op >> str) {
        switch (op) {
            case 0: {
                cout << "insert " << str << " to hash table 1= ";
                cout << h1.insert(str) << endl;
                cout << "insert " << str << " to hash table 2= ";
                cout << h2.insert(str) << endl;
            } break;
            case 1: {
                cout << "search " << str << " from hash table 1= ";
                cout << h1.find(str) << endl;
                cout << "search " << str << " from hash table 2= ";
                cout << h2.find(str) << endl;
            } break;
        }
    }
    return 0;
}

HashTable::HashTable(HashFunc_T func) : p_func(func) {
    this->_size = 100;
    this->data = new Node[this->_size];
}

bool HashTable::insert(const char *str) {
    Node &d = find_position(str);
    if (!d.empty()) return false;
    d.insert(str);
    return true;
}

bool HashTable::find(const char *str) {
    Node &d = find_position(str);
    return !d.empty();
}

Node &HashTable::find_position(const char *str) {
    int ind = p_func(str) % this->_size;
    int times = 1;
    while (!data[ind].empty() && data[ind] != str) {
        ind += times * times;
        ind %= this->_size;
    }
    return data[ind];
}

HashTable::~HashTable() {
    delete[] this->data;
}
```

接口的理解:定义了接口的形状,但连接接口的工具不确定

## Array练习

```cpp
class IntArray {
public :
    IntArray(int n) : n(n) {
        this->arr = new int[n];
    }
    IntArray(const IntArray &obj) : n(obj.n) {
        this->arr = new int[n];
        for (int i = 0; i < n; i++) {
            this->arr[i] = obj.arr[i];
        }
    }
    int &operator[](int ind) {
        if (ind >= 0) {
            return this->arr[ind];
        }
        return this->arr[n + ind];
    }
    void operator+=(int x) {
        for (int i = 0; i < n; i++) {
            this->arr[i] += x;
        }
        return ;
    }
    IntArray &operator++() {
        for (int i = 0; i < n; i++) {
            this->arr[i] += 1;
        }
        return *this;
    }
    IntArray operator++(int x) {
        IntArray ret = (*this);
        for (int i = 0; i < n; i++) {
            this->arr[i] += 1;
        }
        return ret;
    }
    ~IntArray() {
        delete[] this->arr;
    }
    friend ostream &operator<<(ostream &, const IntArray &);
private :
    int *arr, n;
};

ostream &operator<<(ostream &out, const IntArray &a) {
    out << "<Class IntArray> : ";
    for (int i = 0; i < a.n; i++) {
        out << a.arr[i] << " ";
    }
    return out;
}

int main() {
    srand(time(0));
    IntArray a(10);
    for (int i = 0; i < 10; i++) {
        a[i] = rand() % 100;
    }
    cout << a[4] << endl;
    cout << a[-2] << endl; // 输出倒数第 2 位的值
    cout << a << endl; // 输出整个数组中的元素
    a += 5; // 给数组中所有元素都加5
    cout << a << endl; // 输出整个数组中的元素
    cout << (a++) << endl; // 给数组中的所有元素都加 1
    cout << (++a) << endl; // 给数组中的所有元素都加 1
    return 0;
}
```

## 虚函数表

```cpp
class Animal {
public :
    Animal() {
        x = 8827, y = 65123;
    }
    virtual void say(int x) {
        cout << "I don't know how to say" << endl;
    }
    virtual void run() {
        cout << "I don't know how to run" << endl;
    }
protected :
    int x, y;
};

class Cat : public Animal {
public :
    void say(int x) override {
        cout << this << endl;
        cout << this->x  << " " << this->y << endl;
        cout << x << endl;
        cout << "miao~ miao~ miao~" << endl;
    }
    void run() override {
        cout << "I can run with four legs" << endl;
    }
};

void output_raw_data(void *q, int n) {
    printf("%p : ", q);
    unsigned char *p = (unsigned char *)q;
    for (int i = 0; i < n; i++) {
        printf("%02X ", p[i]);
    }
    printf("\n");
    return ;
}

typedef void (*func)(void *, int x);

int main() {
    Cat a, b;
    output_raw_data(&a, sizeof(a));
    output_raw_data(&b, sizeof(b));
    ((func **)(&a))[0][0](&a, 123);
    return 0;
}
```

## 虚函数

```cpp
string rand_name(int n) {
    string name = "";
    for (int i = 0; i < n; i++) {
        name = name + (char)(rand() % 26 + 'A');
    }
    return name;
}

class Animal {
public :
    Animal(string name) : name(name) {}
    string tell_me_your_name() { return this->name; }
    virtual void run() {
        cout << "I don't know how to run" << endl;
    }
    virtual void say() = 0;
    virtual void func0() {}
    virtual ~Animal() {
        cout << "Animal destructor" << endl;
    }
private :
    string name;
};

class Cat : public Animal {
public :
    Cat() : Animal(rand_name(5) + " Cat") {}
    void run() override {
        cout << "I can run with four legs" << endl;
    }
    void func0() override {
        cout << "this is funco" << endl;
    }
    void say() override {
        cout << "miao~ miao~ miao~" << endl;
    }
    ~Cat() {
        cout << "Cat destructor" << endl;
    }
};

class Bat : public Animal {
public :
    Bat() : Animal(rand_name(5) + " Bat") {}
    void run() override {
        cout << "I can fly" << endl;
    }
    void say() override {
        cout << "zzz~ zzz~ zzz~" << endl;
    }
    ~Bat() {
        cout << "Bat destructor" << endl;
    }
};

int main() {
    Cat a;
    Bat b;
    cout << a.tell_me_your_name() << endl;
    a.run();
    cout << b.tell_me_your_name() << endl;
    b.run();
    Animal ** arr = new Animal*[10];
    for (int i = 0; i < 10; i++) {
        if (rand() % 2) {
            arr[i] = new Cat();
        } else {
            arr[i] = new Bat();
        }
    }
    for (int i = 0; i < 10; i++) {
        cout << arr[i]->tell_me_your_name() << endl;
        arr[i]->run();
        arr[i]->say();
    }
    for (int i = 0; i < 10; i++) {
        delete arr[i];
    }
    delete[] arr;
    return 0;
}
```

## cout简版实现

```cpp
namespace haizei {
    class ostream {
    public :
        ostream &operator<<(int x) {
            printf("%d", x);
            return *this;
        }
        ostream &operator<<(const std::string &str) {
            printf("%s", str.c_str());
            return *this;
        }
        ostream &operator<<(const char &ch) {
            printf("%c", ch);
            return *this;
        }
        ostream &operator<<(const double &a) {
            printf("%g", a);
            return *this;
        }
        //消除后0
          ostream &operator<<(const double &a) {
            char e_str[20];
            int e_num, temp;
            sprintf(e_str, "%.5e", a);
            scanf(e_str, "%d.%de%d", &temp, &temp, &e_num);
            if (e_num >= 6 || e_num <= -5) {
                printf("%s", e_str);
            } else {
                temp = 5 - e_num;
                sprintf(e_str, "%%.%dlf", temp);
                printf(e_str, a);
            }
            return *this;
        }

    };
    char endl = '\n';
    ostream cout;
}

int main() {
    haizei::cout << "hello world" << haizei::endl;
    haizei::cout << 123 << haizei::endl;
    haizei::cout << 123.567 << haizei::endl;
    haizei::cout << 123.56 << haizei::endl;
    haizei::cout << 123. << 123. <<  haizei::endl;
    std::cout << 123. << 123. <<  std::endl;
    haizei::cout << 123.78787878 << haizei::endl;
    haizei::cout << 3.78787878 << haizei::endl;
    double a = 3787878787878780.;
    for (int i = 0; i < 20; i++) {
        a /= 10;
        haizei::cout << i << " " << a << haizei::endl;
    }
    printf("%lf\n", 123.567);
    printf("%lf\n", 123.56);
    printf("%lf\n", 123.);
    return 0;
}
```

## 继承

```cpp
define P_ADD(obj, a) cout << #obj "." #a " = " << &(obj.a)

class Animal {
public:
    Animal(string name) : __name(name) {
        cout << "Animal constructor " << this << endl;
    }
    string name() { return this->__name; }

    int x, y;
    string __name;
    ~Animal() {
        cout << "Animal destructor " << this << endl;
    }
};

class Cat : public Animal {
public :
    Cat() : Animal("hello kitty") {
        arr = new int[100];
        cout << "Cat constructor " << this << endl;
    }
    void say() {
        cout << "my name is " << this->name() << endl;
    }
    int z;
    int *arr;
    ~Cat() {
        delete[] arr;
        cout << "Cat destructor " << this << endl;
    }
};

ostream &operator<<(ostream &out, const Animal &a) {
    out << "<class Animal> " << &a << endl;
    P_ADD(a, x) << endl;
    P_ADD(a, y) << endl;
    P_ADD(a, __name) << endl;
    return out;
}
```

## 析构

```cpp
struct A {
    A() : next(nullptr) {
        cout << this << " default constructor" << endl;
    }
    A(A *obj) {
        this->next = obj;
        this->next->arr = new int[1000];
    }
    A(int n) : next(nullptr) {
        cout << this << " an int constructor" << endl;
        x = n, y = n;
    }
    A(const A &obj) : next(nullptr) {
        cout << this << " copy constructor" << endl;
        this->x = obj.x, this->y = obj.y;
    }
    void output() {
        cout << this->x << " " << this->y << endl;
    }
    int x, y;
    int *arr;
    A *next;
    ~A() {
        if (this->next) {
            delete this->next->arr;
        }
        cout << this << " destructor" << endl;
    }
};

void func(int &x) {
    x += 5;
}

A aa;
A bb(&aa);
A cc(&bb);

int main() {
    int n = 7;
    func(n);
    cout << n << endl;
    cout << "pre position" << endl;
    A a;
    A b = 8;
    A c(a);
    cout << "a = " << &a << endl;
    cout << "b = " << &b << endl;
    cout << "c = " << &c << endl;
    cout << "aa = " << &aa << endl;
    cout << "bb = " << &bb << endl;
    cout << "cc = " << &cc << endl;
    b.output();
    b = 6;
    b.output();
    cout << "next position" << endl;
    return 0;
}
```

## 进制转换

```cpp
auto in_range = [](int b, int e) {
    return [=](int x) {
        return (x <= e && x >= b);
    };
};

auto is_digit = in_range('0', '9');
auto is_upper = in_range('A', 'Z');
auto is_lower = in_range('a', 'z');

class BigInt {
public :
    BigInt(int base, int x) {
        this->base = base;
        this->data.push_back(x);
        this->proccess_digit();
    }
    BigInt() : BigInt(10, 0) {}
    BigInt(int base, const string &num_str) {
        this->base = base;
        for (int i = num_str.size() - 1; i >= 0; --i) {
            this->data.push_back(BigInt::decode(num_str[i]));
        }
    }

    BigInt &operator*=(int x) {
        vector<int> &vec = this->data;
        for (int i = 0; i < vec.size(); i++) {
            vec[i] *= x;
        }
        this->proccess_digit();
        return *this;
    }
    BigInt &operator+=(int x) {
        vector<int> &vec = this->data;
        vec[0] += x;
        this->proccess_digit();
        return *this;
    }
    BigInt &operator+=(const BigInt &x) {
        vector<int> &vec = this->data;
        for (int i = 0; i < x.data.size(); i++) {
            if (i + 1 >= vec.size()) vec.push_back(x.data[i]);
            vec[i] += x.data[i];
        }
        this->proccess_digit();
        return *this;
    }
    BigInt &operator/=(int x) {
        vector<int> &vec = this->data;
        int i = vec.size() - 1, temp = 0;
        while (i >= 0 && temp * base + vec[i] < x) {
            temp = temp * base + vec[i];
            vec.erase(vec.begin() + (i--));
        }
        if (i == -1) { 
            vec.push_back(0); 
            return *this;
        }
        while (i >= 0) {
            temp = temp * base + vec[i];
            vec[i--] = temp / x;
            temp %= x;
        }
        return *this;
    }
    int operator%(int x) {
        vector<int> &vec = this->data;
        int temp = 0;
        for (int i = vec.size() - 1; i >= 0; i--) {
            temp = temp * base + vec[i];
            temp %= x;
        }
        return temp;
    }
    BigInt &convert_to(int to_base) {
        if (to_base == this->base) return *this;
        vector<int> result;
        BigInt &num = *this;
        do {
            result.push_back(num % to_base);
            num /= to_base;
        } while (num != 0);
        num.data[0] = result[0];
        for (int i = 1; i < result.size(); i++) {
            num.data.push_back(result[i]);
        }
        return num;
    }
    bool operator!=(int x){
        return !(this->operator==(x));
    }
    bool operator!=(const BigInt &x){
        return !(this->operator==(x));
    }
    bool operator==(int x) {
        BigInt a(this->base, x);
        return ((*this) == a);
    }
    bool operator==(const BigInt &a) {
        int now_base = this->base;
        if (a.base - this->base) this->convert_to(a.base);
        int flag = 1;
        if (a.data.size() - this->data.size()) flag = 0;
        for (int i = 0; i < a.data.size() && flag; i++) {
            if (a.data[i] - this->data[i]) flag = 0;
        }
        this->convert_to(now_base);
        return flag;
    }

private:
    vector<int> data;
    int base;
    void proccess_digit() {
        vector<int> &vec = this->data;
        for (int i = 0; i < vec.size(); i++) {
            if (vec[i] < base) continue;
            if (i + 1 == vec.size()) vec.push_back(vec[i] / base);
            else vec[i + 1] += vec[i] / base;
            vec[i] %= base;
        }
        return ;
    }
    static int decode(char ch) {
        if (is_digit(ch)) return ch - '0';
        if (is_upper(ch)) return ch - 'A' + 10;
        return ch - 'a' + 36;
    }
    static char encode(int x) {
        if (x < 10) return x + '0';
        if (x < 36) return x - 10 + 'A';
        return x - 36 + 'a';
    }
    
friend ostream &operator<<(ostream &, const BigInt &);
};

ostream &operator<<(ostream &out, const BigInt &a) {
    for (int i = a.data.size() - 1; i >= 0; i--) {
        out << BigInt::encode(a.data[i]);
    }
    return out;
}

int main() {
    int base_a, base_b;
    string str;
    cin >> base_a >> base_b >> str;
    BigInt num(base_a, str);
    cout << base_a << " " << num << endl;
    num.convert_to(base_b);
    cout << base_b << " " << num << endl;
    return 0;
}
```



## 大浮点数

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <deque>
using namespace std;

struct BigFloat {
    BigFloat(int x) {
        lpart.push_back(x);
        proccess_digit();
    }
    void operator*=(int x) {
        for (int i = 0; i < lpart.size(); i++) lpart[i] *= x;
        for (int i = 0; i < rpart.size(); i++) rpart[i] *= x;
        proccess_digit();
        return ;
    }
    void operator<<=(int x) {
        while (x--) {
            if (lpart.size()) {
                rpart.push_front(lpart[lpart.size() - 1]);
                lpart.pop_back();
            } else {
                rpart.push_front(0);
            }
        }
        if (lpart.size() == 0) lpart.push_front(0);
        trim();
        return ;
    }
    void trim() {
        while (lpart.size() > 1 && lpart[0] == 0) lpart.pop_front();
        while (rpart.size() && rpart[rpart.size() - 1] == 0) rpart.pop_back();
        return ;
    }
    void proccess_digit() {
        for (int i = rpart.size() - 1; i >= 0; --i) {
            if (rpart[i] < 10) continue;
            if (i == 0) {
                lpart[lpart.size() - 1] += rpart[i] / 10;
            } else {
                rpart[i - 1] += rpart[i] / 10;
            }
            rpart[i] %= 10;
        }
        for (int i = lpart.size() - 1; i >= 0; --i) {
            if (lpart[i] < 10) continue;
            if (i == 0) lpart.push_front(0), ++i;
            lpart[i - 1] += lpart[i] / 10;
            lpart[i] %= 10;
        }
        trim();
        return ;
    }
    deque<int> lpart, rpart;
};

ostream &operator<<(ostream &out, const BigFloat &a) {
    for (int i = 0; i < a.lpart.size(); i++) {
        out << a.lpart[i];
    }
    if (a.rpart.size() == 0) return out;
    out << ".";
    for (int i = 0; i < a.rpart.size(); i++) {
        out << a.rpart[i];
    }
    return out;
}

int main() {
    int n, p[4];
    string str;
    cin >> n;
    cin >> str;
    BigFloat ans = 1;
    for (int i = 0; i < n; i++) {
        char ch;
        for (int j = 0; j < 4; j++) {
            cin >> p[j] >> ch;
        }
        ans *= p[str[i] - 'A'];
        ans <<= 2;
    }
    cout << ans << endl;
    return 0;
}
```



# 56. 国王游戏

微扰+大整数

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
struct Data {
    int a, b;
    bool operator<(const Data &obj) const {
        return a * b < obj.a * obj.b;
    }
};
vector<Data> arr;

struct BigInt {
    BigInt(int x) {
        num.push_back(x);
        process_digit();
    }
    bool operator>(const BigInt &obj) {
        if (num.size() - obj.num.size()) return num.size() > obj.num.size();
        for (int i = 0; i < num.size(); ++i) {
            if (num[i] == obj.num[i]) continue;
            return num[i] > obj.num[i];
        }
        return false;
    }
    void operator*=(int x) {
        for (int i = 0; i < num.size(); ++i) {
            num[i] *= x;
        }
        process_digit();
    }
    BigInt(vector<int> &ret) : num(ret) {}
    BigInt operator/(int x) {
        //i:商在哪一位, temp:余数
        int i = num.size(), temp = 0;
        while (i && temp * 10 + num[i - 1] < x) temp = temp * 10 + num[i - 1], i--;
        if (i == 0) return BigInt(0);
        vector<int> ret(i);
        while (i) {
            temp = temp * 10 + num[i - 1];
            ret[i - 1] = temp / x;
            temp %= x;
            i--;
        }
        return BigInt(ret);
    }
    void process_digit() {
        for (int i = 0; i < num.size(); ++i) {
            if (num[i] < 10) continue;
            if (i + 1 == num.size()) num.push_back(0);
            num[i + 1] += num[i] / 10;
            num[i] %= 10;
        }
        return ;
    }
    vector<int> num;
};

ostream &operator<<(ostream &out, const BigInt &obj) {
    for (int i = obj.num.size() - 1; i >= 0; i--) {
        out << obj.num[i];
    }
    return out;
}

int main() {
    int n, a, b;
    cin >> n;
    for (int i = 0; i <= n; ++i) {
        cin >> a >> b;
        arr.push_back((Data){a, b});
    }
    sort(arr.begin() + 1, arr.end());
    BigInt p = arr[0].a, ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (p / arr[i].b > ans) ans = p / arr[i].b;
        p *= arr[i].a;
    }
    cout << ans << endl;
    return 0;
}

```



## 大整数

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;

auto in_range = [](int b, int e) {
    return [=](int x) {
        return (x <= e && x >= b);
    };
};

auto is_digit = in_range('0', '9');
auto is_upper = in_range('A', 'Z');
auto is_lower = in_range('a', 'z');

class BigInt {
public :
    BigInt(int base, int x) {
        this->base = base;
        this->data.push_back(x);
        this->proccess_digit();
    }
    BigInt() : BigInt(10, 0) {}
    BigInt(int base, const string &num_str) {
        this->base = base;
        for (int i = num_str.size() - 1; i >= 0; --i) {
            this->data.push_back(BigInt::decode(num_str[i]));
        }
    }

    BigInt &operator*=(int x) {
        vector<int> &vec = this->data;
        for (int i = 0; i < vec.size(); i++) {
            vec[i] *= x;
        }
        this->proccess_digit();
        return *this;
    }
    BigInt &operator+=(int x) {
        vector<int> &vec = this->data;
        vec[0] += x;
        this->proccess_digit();
        return *this;
    }
    BigInt &operator+=(const BigInt &x) {
        vector<int> &vec = this->data;
        for (int i = 0; i < x.data.size(); i++) {
            if (i + 1 >= vec.size()) vec.push_back(x.data[i]);
            vec[i] += x.data[i];
        }
        this->proccess_digit();
        return *this;
    }
    BigInt &operator/=(int x) {
        vector<int> &vec = this->data;
        int i = vec.size() - 1, temp = 0;
        while (i >= 0 && temp * base + vec[i] < x) {
            temp = temp * base + vec[i];
            vec.erase(vec.begin() + (i--));
        }
        if (i == -1) { 
            vec.push_back(0); 
            return *this;
        }
        while (i >= 0) {
            temp = temp * base + vec[i];
            vec[i--] = temp / x;
            temp %= x;
        }
        return *this;
    }
    int operator%(int x) {
        vector<int> &vec = this->data;
        int temp = 0;
        for (int i = vec.size() - 1; i >= 0; i--) {
            temp = temp * base + vec[i];
            temp %= x;
        }
        return temp;
    }
    BigInt &convert_to(int to_base) {
        if (to_base == this->base) return *this;
        vector<int> result;
        BigInt &num = *this;
        do {
            result.push_back(num % to_base);
            num /= to_base;
        } while (num != 0);
        num.data[0] = result[0];
        for (int i = 1; i < result.size(); i++) {
            num.data.push_back(result[i]);
        }
        return num;
    }
    bool operator!=(int x){
        return !(this->operator==(x));
    }
    bool operator!=(const BigInt &x){
        return !(this->operator==(x));
    }
    bool operator==(int x) {
        BigInt a(this->base, x);
        return ((*this) == a);
    }
    bool operator==(const BigInt &a) {
        int now_base = this->base;
        if (a.base - this->base) this->convert_to(a.base);
        int flag = 1;
        if (a.data.size() - this->data.size()) flag = 0;
        for (int i = 0; i < a.data.size() && flag; i++) {
            if (a.data[i] - this->data[i]) flag = 0;
        }
        this->convert_to(now_base);
        return flag;
    }

private:
    vector<int> data;
    int base;
    void proccess_digit() {
        vector<int> &vec = this->data;
        for (int i = 0; i < vec.size(); i++) {
            if (vec[i] < base) continue;
            if (i + 1 == vec.size()) vec.push_back(vec[i] / base);
            else vec[i + 1] += vec[i] / base;
            vec[i] %= base;
        }
        return ;
    }
    static int decode(char ch) {
        if (is_digit(ch)) return ch - '0';
        if (is_upper(ch)) return ch - 'A' + 10;
        return ch - 'a' + 36;
    }
    static char encode(int x) {
        if (x < 10) return x + '0';
        if (x < 36) return x - 10 + 'A';
        return x - 36 + 'a';
    }
    
friend ostream &operator<<(ostream &, const BigInt &);
};

ostream &operator<<(ostream &out, const BigInt &a) {
    for (int i = a.data.size() - 1; i >= 0; i--) {
        out << BigInt::encode(a.data[i]);
    }
    return out;
}

int main() {
    int base_a, base_b;
    string str;
    cin >> base_a >> base_b >> str;
    BigInt num(base_a, str);
    cout << base_a << " " << num << endl;
    num.convert_to(base_b);
    cout << base_b << " " << num << endl;
    return 0;
}
```

