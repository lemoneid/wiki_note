---
id : A2.Linux命令
title : A2.Linux命令
typora-root-url : ../
---

[TOC]

# Linux命令



# 命令系统

## shell、terminal和console

> `shell`是一种命令接下，它给用户提供一个输入命令并接受机器返回结果的界面。 `bash`是`shell`中的一种
>
> `terminal` 终端，是一个封装的程序,一个terminal运行一个shell来扩充功能
>
> `console` 一般只能有一个(显示器或电脑用串口线连接)



```mermaid
graph LR
	A(Keyboard) -- stdin--- B((Program))
    B-- 1stdout--- C(display)
 	B-- 2stdout--- C(display)
```

keyboard + display = Text terminal

> terminal 是黑框框，bash 是执行的`root@aliyun:~ `

## Linux帮助手册

#### 1. --help

指令的基本用法与选项介绍。

#### 2. man

man 是 manual 的缩写，将指令的具体信息显示出来。

当执行 `man date` 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：

#### 3. info

info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。

#### 4. doc

/usr/share/doc 存放着软件的一整套说明文件。

### 

`tldr` 常用命令，需联网，但有时超时，不可用

`command -h或--help`  部分命令有帮助信息来自man手册

### man使用方法

`man -k `	查找关键字 可以  eg: 	`man -k reboot | grep reboot`

`man -f`     查找 find

| Ctrl+f(orward)  | 向下翻一页 | Ctrl+d(own) | 向下翻半页 |
| --------------- | ---------- | ----------- | ---------- |
| Ctrl+b(ackward) | 向上翻一页 | Ctrl+u(p)   | 向上翻半页 |
| /               | 查找       | q(uit)      | 退出       |

```shell
yanzhiwei@aliyun:~$ man -f tty
tty (1)              - print the file name of the terminal connected to standard input
tty (4)              - controlling terminal
yanzhiwei@aliyun:~$ man 1 tty
```



### man手册各部分

```shell
LS(1)                             							UserCommands                              LS(1)

NAME  命令全面，简单的说明及用法
       ls - list directory contents

SYNOPSIS 基本语法
       ls [OPTION]... [FILE]...  [OPTION]...  []表示可有可无   ...表示多个参数

DESCRIPTION  详细说明语法中参数的用法
省略
Exit status:  错误返回值
       0      if OK,

       1      if minor problems (e.g., cannot access subdirectory),

AUTHOR	作者
       Written by Richard M. Stallman and David MacKenzie.

REPORTING BUGS  bug提交方式
       GNU coreutils online help: <http://www.gnu.org/software/coreutils/>

COPYRIGHT  版权保护
       Copyright  © 2017 Free Software Foundation, Inc.  

SEE ALSO  在哪可看到更多关于该命令的文档
       Full documentation at: <http://www.gnu.org/software/coreutils/ls>
       or available locally via: info '(coreutils) ls invocation' 


```

### man手册命令含义

| 序号  | 含义                                                         | eg         |
| ----- | ------------------------------------------------------------ | ---------- |
| 1     | 1.用户在shell环境中可以操作的指令或可执行文件；              | ls         |
| 2     | 2.系统核心可呼叫的函数与工具等；                             | reboot     |
| 3     | 3，一些常用的函数与函数库，大部委为C的函数库                 | readdir    |
| 4     | 4，装置档案的说明，通常在/dev下的档案；                      | null       |
| 5     | 5，配置文件或者是某些档案的格式；                            | interfaces |
| 6     | 6，游戏；                                                    | lol        |
| 7     | 7.惯例与协议等，例如linux文件系统、网络协议、ASCII code等等的说明； | tcp        |
| 8     | 8.系统管理员可用的管理指令；                                 | reboot     |
| 9     | 9.跟kernel有关的文件。                                       |            |
| o,n,l | 依次为 旧、新、本地文档                                      |            |



| man手册快捷键                    | 功能               | 快捷键 | 功能  |
| -------------------------------- | ------------------ | ------ | ----- |
| 翻页                             | space              | 下一行 | Enter |
| /                                | 查找               | q(uit) | 退出  |
| Ctrl + f(orward),b(ackward) | 向下翻一页，上 |        |       |
| Ctrl+d(won),u(p)                 | 向下翻半页，上     |        |       |

### 关机

#### 1. who

在关机前需要先使用 who 命令查看有没有其它用户在线。

#### 2. sync

为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。

#### 3. shutdown

```html
## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown
```

### 

## Bash

**`seq`命令**用于产生从某个数到另外一个数之间的所有整数。

```shell
for i in `seq 1 20 `; do   执行二十次命令 
touch test$i    创建文件
done 
```

### 键盘

- 幕后控制台 Ctrl+Alt+F1,2,3..6

- Tab 自动补全

- ctrl-r  搜索命令行历史记录

- Ctrl+a 移动光标到行首

- Ctrl+e 移动光标到行尾

- ctrl-u 删除行内光标->行首

- ctrl-k 删除行内光标->行尾

- ctrl-w 删除你键入的最后一个单词

- ctrl-l  清屏clear

- ctrl+s 终止屏幕输出（即停止回显），你敲的依然有效，只是看不见

- ctrl+q 恢复屏幕输出

- Alt+? 显示可能的自动补全列表，也可以按两次Tab键来实现

- Alt+* 插入所有可能的自动补全


### 设置默认shell

```shell
chsh -s /bin/zsh
```

### 历史命令

- `history`

  ```shell
    186  eixt
    187  logout
    188  history 
  yanzhiwei@aliyun:~$ !188   执行第118号命令
  ```

- 上下箭头

### 通配符

- ？ 单个任意字符

- \*   任意几个任意字符

  | **通配符**            | **含义**                                    | **实例**                                                     |
  | --------------------- | ------------------------------------------- | ------------------------------------------------------------ |
  | *                     | 匹配 0 或多个字符                           | a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。 |
  | ?                     | 匹配任意一个字符                            | a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。 |
  | [list]                | 匹配 list 中的任意单一字符                  | a[xyz]b  a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。 |
  | [!list]或[\^list]     | 匹配 除list 中的任意单一字符                | a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。 |
  | [c1-c2]               | 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] | a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b... a9b。     |
  | [!c1-c2]或[\^c1-c2]   | 匹配不在c1-c2的任意字符                     | a[!0-9]b 如acb adb                                           |
  | {string1,string2,...} | 匹配 sring1 或 string2 (或更多)其一字符串   | a{abc,xyz,123}b 列出aabcb,axyzb,a123b                        |

## 任务管理

1. `&`   在命令后加`&`，表示后台执行

```shell
command &
```

2. `;`   在命令之间以`;`相连，表示顺序执行

```shell
command1;command2
```

3. `&&` 命令之间以`&&`相连，只有command1成功执行，command2才执行      类比C语言语法

```shell
command1 && command2
```

4. `||`命令之间以`||`相连，只有command1执行失败，command2才执行      类比C语言语法

```shell
command1 || command2
```

5. `  ``  `   命令包含\`另一命令\`。\`command\`优先执行，该子命令；将其结果带入父命令继续执行。 

   ```shell
   command `command`
   ```

6. `Ctrl + z`  暂时挂起

```shell
yanzhiwei@aliyun:~/test$ vim a.cpp[1]+  Stopped                 vim a.cpp
```

7. `bg` 将挂起的命令后台运行。 后+任务编号

```shell
[1]+  Stopped                 vim a.cppyanzhiwei@aliyun:~/test$ bg[1]+ vim a.cpp &
```

8. `fg` 将后台执行的命令转为前台执行,默认为最近一次， 与`%`等价   

9. `jobs` 查看所有在后台执行和挂起的任务以及任务编号

## 进程

### 信号

常见信号

- man 7 signal
- 1 HUP 终端挂起。控制进程终止

- 2 INT 键盘中断：终止进程  Ctrl+C

- 3 QUIT 键盘退出：退出程序  Ctrl+D Ctrl+\

- 9 KILL 无条件终止进程：可杀死任何进程

- 15 TERM kill默认，程序结束信号：与kill不同，TERM信号可被阻塞和终止


#### kill

发送信号

* 杀掉进程
* `kill -9 pid`杀掉指定进程

- kill -l
### 结束进程

1. `Ctrl + c` 一般结束进程
2. `kill PID `
3. `pkill 进程名称`   注意。尽量在普通用户下kill

#### pkill
  - 根据名字，删除单个进程
  - -f
#### killall
  - 结束同名所有进程


### 查看进程
#### pgrep

#### ps

* 当前运行的进程的快照，指定ps命令的那个时刻的那些进程
* `ps -aux` 查看所有的在内存中的进程信息
* `ps -ajx` 查看进程组相关信息，可以追踪进程之间的血缘关系
* `ps -ef` 线城市所有进程信息，并显示程序间的关系
* `ps -u username` 显示指定用户username信息

```shell
yanzhiwei@aliyun:~/test$ ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 Apr21 ?        00:00:01 /sbin/init noibrs splashroot         2     0  0 Apr21 ?        00:00:00 [kthreadd]root         4     2  0 Apr21 ?        00:00:00 [kworker/0:0H]
```

#### pstree

查看进程树。

```shell
pstree -A 查看所有进程树
-p 优雅的方式展示进程树
```

#### top

 动态进程查看

* 实时显示系统中各个进程的资源占用情况，按"q"退出top命令
* `top -H -p pid`显示对应pid的所有线程资源使用情况
* `load average` 表示系统最近1min,5min,15min的平均负载，越大表示负载越来越小
* %MEM物理内存占用比
* Cpu(s)和%cpu
  * Cpu(s)表示的是所有用户进程占用整个cpu的平均值
  * %CPU显示的是进程占用一个核的百分比，而不是整个cpu（8核）的百分比，有时候可能大于100，那是因为该进程启用了多线程占用了多个核心，所以有时候我们看该值得时候会超过100%，但不会超过总核数*100。

####  htop

### nohup 命令 [选项]

​      将任务提交到后台，输出附加到 `~/nohup.out` 文件。即便用户退出登录，提交的命令仍继续执行。    

### 进程状态

| 状态 | 说明                                                         |
| :--: | ------------------------------------------------------------ |
|  R   | running or runnable (on run queue); 正在执行或者可执行，此时进程位于执行队列中。 |
|  D   | uninterruptible sleep (usually I/O); 不可中断阻塞，通常为 IO 阻塞。 |
|  S   | interruptible sleep (waiting for an event to complete) ;  可中断阻塞，此时进程正在等待某个事件完成。 |
|  Z   | zombie (terminated but not reaped by its parent); 僵死，进程已经终止但是尚未被其父进程获取信息。 |
|  T   | stopped (either by a job control signal or because it is being traced) ;  结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 |

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png)

### SIGCHLD

当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：

- 得到 SIGCHLD 信号；
- waitpid() 或者 wait() 调用会返回。

其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。

在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。

![](/Image/A2.Linux命令-photo/flow.png)

### wait()

```c
pid_t wait(int *status)
```

父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。

参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。

### waitpid()

```c
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。

options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

 

## 管道、重定向

`echo $? `打印上一条执行命令的返回值，0 为成功

`echo` 英译回声，打印的意思

### llinux中的三种IO设备：

1. 标准输入（STDIN）,文件描述符号为：0，默认从键盘获取输入

2. 标准输出（STDOUT）,文件描述符号位：1，默认输出到显示终端

3. 标准错误（STDERR）,文件描述符号为：2，默认输出到显示终端

典例 

```shell
ping 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=4 ttl=52 time=4.05 mskill 64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=5 ttl=52 time=4.05 ms64 bytes from 220.181.38.148 (220.181.38.148): icmp_seq=6 ttl=52 time=4.08 mskill stdin；说明是三个不同文件
```





#### 1. 输出重定向

**标准输出STDOUT和标准错误输出STDERR）**

- `>` 标准输出覆盖重定向        `man ls > ls.log`  没有文件默认新建；`.log`日志  
- `>>` 标准输出追加重定向
- `2>` 标准错误输出重定向
- `2>>` 标准错误输出追加重定向
- `&>` 将标准输出和标准错误输出都同时重定向（相当于二次重定向`2>&1`）
- `&>>` 将标准输出和标准错误输出都同时追加重定向


  #### 2. 输入重定向

**（标准输入）**

- `<` 输入重定向；

  ```shell
  gcc a.c./a.out < input   input文件为输入的数据
  ```

- `<<END` 多行输入；(END为多行输入的结束标志)通常用于脚本创建新文件时写入固定内容; `END` 就是一个结束符，自定义，`hahah`,`EOF`都行

  ```shell
  yanzhiwei@aliyun:~/test$ cat >> temp <<EOF> sdfas> fd> asdfgadsgsdkjfgfg> EOFyanzhiwei@aliyun:~/test$ cat temp sdfasfdasdfgadsgsdkjfgfg
  ```

  

> 输入输出重定向可同时进行；`./a.out > dir < input` = `./a.out > dir < input`

#### 3.管道

`|` 把前一个命令的执行结果当做后一个命令的输入

### 转义符

让通配符，或者shell'元字符 变成普通字符，不需要使用它。那么这里我们就需要用到转义符了。 shell提供转义符有三种。



| 字符       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| ‘’(单引号) | 硬转义，其内部所有的shell 元字符、通配符都会被关掉。不允许出现单引号 |
| “”(双引号) | 软转义，其内部只允许出现特定的shell 元字符：$用于参数替换; `(反单引号，esc键下面)用于命令替换;\\用于转义单个字符 |
| \\(反斜杠) | 又叫转义，去除其后紧跟的元字符或通配符的特殊意义             |

```shell
yanzhiwei@aliyun:~/test$ echo '$HOME'$HOMEyanzhiwei@aliyun:~/test$ echo $HOME/home/yanzhiwei
```



#### 转义符对应表



### shell元字符

shell除了有通配符之外，由shell负责预先先解析后，将处理结果传给命令行之外，shell还有一系列自己的其他特殊字符。



| 字符 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| =    | 变量名=值，为变量赋值。注意=左右紧跟变量名和值，中间不要有空格 |
| ``   | 取命令的执行结果， 与下文的$有相似之处                       |
| $    | 变量值替换，\$变量名替换为shell变量的值;为避免在文本连接时混淆，请使用\${变量名};\$0...\$9 代表shell文件的参数。\$()``;\${}限定变量名的范围；\$[]整数的计算； |
| >    | prog > file 将标准输出重定向到文件。                         |
| >>   | prog >> file 将标准输出追加到文件。                          |
| <    | prog < file 从文件file中获取标准输入                         |
| <<   |                                                              |
| \|   | 管道命令，例：p1                                             |
| &    | 后台运行命令，最大好处是无需等待命令执行结束，就可以在同一命令行下继续输入命令 |
| ()   | 在子shell中执行命令                                          |
| {}   | 在当前shell中执行命令，或用在变量替换的界定范围(例如上面的${变量名}用法)。 |
| []   | 字符通配，匹配括号内之一                                     |
| ;    | 命令结束符。例如p1;p2表示先执行p1,再执行p2                   |
| &&   | 前一个命令执行成功后，才继续执行下一个命令。例：p1 && p2 ;若p1执行成功后，才执行p2,反之，不执行p2; |
| \|\| | 前一个命令执行失败后，才继续执行下一个命令。例：p1 \|\| p2 ;若p1执行成功后，不执行p2,反之，才执行p2; |
| !    | 执行历史记录中的命令                                         |
| %    | %1 相当于 fg1                                                |
| ^    | 取非，和！雷同；`^string1^sring2^` 将上一命令的string1替换为string2 |
| ~    | home目录                                                     |
|      | 注释                                                         |
| *    | 通配符，任意字符                                             |
| ?    | 通配符，任一字符                                             |
| .    | 当前目录； source                                            |
| -    | 减号；上次工作目录                                           |
| :    | 真值；空命令                                                 |
| \    | 转义                                                         |
| /    | 目录分隔符                                                   |



# Linux系统信息

中国时区:东八区

timestamp 时间戳

Unix epoch 计算机元年，1970-01-01

## 基本命令

| 命令   | 功能                       | 命令             | 功能                                    |
| ------ | -------------------------- | ---------------- | --------------------------------------- |
| uptime | 打印系统运行时长和平均负载 | w                | 当前登录用户列表及正在执行的任务        |
| who    | 显示当前登录系统的用户信息 | whoami  who am i | 打印当前有效的用户名称 who am i logname |
| last   | 显示用户最近登录的信息     | uname            | 打印当前系统信息                        |
| date   | 显示或设置系统时间与如期   | cal              | 显示日历                                |

"\$PATH"  软转义，`“ ”` 是为了表明`$PSTH`是一个字符串



### uptime

`uptime [phsv]` 

```shell
yanzhiwei@aliyun:~$ uptime
 09:25:31 up 2 days, 15:06,  1 user,  load average: 0.49, 1.10, 2.32  用man手册查看代表含义
```

### w

`w [husfv] <user> <...>`

| USER       | TTY                    | FROM       | LOGIN@   | IDLE     | JCPU | PCPU                 | WHAT                   |
| ---------- | ---------------------- | ---------- | -------- | -------- | ---- | -------------------- | ---------------------- |
| 登陆用户名 | 登录后系统分配的终端号 | 远程主机名 | 登录时间 | 空闲时间 | 404  | 当前进程所占用的时间 | 当前进程正在执行的命令 |

>  404: 和终端相连的所有进程占用的时间,包含当前正在执行的后台作业 
>  **Linux一切皆文件**


```shell
yanzhiwei@aliyun:~$ w
 09:34:56 up 2 days, 15:16,  2 users,  load average: 1.02, 1.29, 1.91
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
yanzhiwe pts/0    183.197.57.134   09:25    0.00s  0.05s  0.00s w
root     pts/1    183.197.57.134   09:31    7.00s  0.03s  0.03s -bash

root@aliyun:/dev/pts echo "hello" > /dev/pts/0    向另一人发信息; 表明Linux一切皆文件
yanzhiwei@aliyun:~$ hello
```

> w 显示时 公网IP改变 
>
> NAT 网络地址准换方法。 ipv4资源稀缺

`wall 信息` 根据权限发送给其他人信息 

```shell
root@aliyun:~ wall "Hi"       wall 广播某条信息，普通用户可以发放普通用户，而不可发给root； root 可发给普通用户;
                                                                               
Broadcast message from root@aliyun (pts/1) (Fri Apr 24 10:37:27 2020):         
                                                                               
Hi
为普通用户
Broadcast message from root@aliyun (pts/1) (Fri Apr 24 10:37:27 2020):         
                                                                               
Hi
```

`pts`类型文件:远程连接时,系统给分配的远程终端

### who

`who`显示登录系统的用户信息

```shell
yanzhiwei@aliyun:~$ sudo -i     登录用户为yanzhiwe，临时切换为root
[sudo] password for yanzhiwei: 
root@aliyun:~ who
yanzhiwei pts/0        2020-04-24 10:31 (183.197.57.134)
root     pts/1        2020-04-24 10:34 (183.197.57.134)
yanzhiwei pts/2        2020-04-24 10:34 (183.197.57.134)
root@aliyun:~ who
yanzhiwei pts/0        2020-04-24 10:31 (183.197.57.134)
root     pts/1        2020-04-24 10:34 (183.197.57.134)
yanzhiwei pts/2        2020-04-24 10:34 (183.197.57.134)
root@aliyun:~ whoami
root
root@aliyun:~ who am i 
yanzhiwei pts/2        2020-04-24 10:34 (183.197.57.134)
root@aliyun:~ logname
yanzhiwei

```

`id`命令 查看当前系统用户

```shell
root@aliyun:~ id
uid=0(root) gid=0(root) groups=0(root)
root@aliyun:~ id yanzhiwei
uid=1001(yanzhiwei) gid=1001(yanzhiwei) groups=1001(yanzhiwei),27(sudo)
root@aliyun:~ usermod -G sudo yanzhiwei
```

### last

`last <fnx> <username...> < tty..>`

 ```shell
yanzhiwei@aliyun:~$ last   显示用户最近登录信息
root     pts/2        183.197.237.163  Sat Apr 18 17:15 - 19:32  (02:17)
yzw      pts/1        183.197.237.163  Sat Apr 18 17:00 - 17:00  (00:00)
root     pts/1        183.197.237.163  Sat Apr 18 16:55 - 16:59  (00:04)
reboot   system boot  4.15.0-91-generi Sun Apr 19 00:17 - 18:18 (2+18:01)
reboot   system boot  4.15.0-91-generi Sat Apr 18 23:10 - 16:16  (-6:53)

wtmp begins Sun Mar 29 12:49:47 2020
yanzhiwei@aliyun:~$ last -n 10  "num"   指定输出记录数
yanzhiwe pts/2        183.197.57.134   Fri Apr 24 10:34   still logged in
root     pts/1        183.197.57.134   Fri Apr 24 10:34   still logged in
yanzhiwe pts/0        183.197.57.134   Fri Apr 24 10:31   still logged in
root     pts/1        183.197.57.134   Fri Apr 24 09:31 - 09:46  (00:14)
yanzhiwe pts/0        183.197.57.134   Fri Apr 24 09:25 - 09:45  (00:20)
root     pts/1        183.197.57.134   Thu Apr 23 18:51 - 18:54  (00:02)
yanzhiwe pts/0        183.197.57.134   Thu Apr 23 17:59 - 22:10  (04:10)
yanzhiwe pts/0        183.197.57.134   Wed Apr 22 21:51 - 00:01  (02:09)
yanzhiwe pts/0        183.197.57.134   Wed Apr 22 19:57 - 21:45  (01:48)
yanzhiwe pts/0        183.197.237.248  Wed Apr 22 08:24 - 13:27  (05:02)

wtmp begins Sun Mar 29 12:49:47 2020                  
yanzhiwei@aliyun:~$ last -f /var/log/wtmp "file" 指定记录文件
root     pts/1        183.197.237.163  Sat Apr 18 16:37 - 16:43  (00:05)
root     pts/1        183.197.237.163  Sat Apr 18 16:34 - 16:37  (00:02)
root     pts/0        183.197.237.163  Sat Apr 18 16:17 - 18:29  (02:11)
reboot   system boot  4.15.0-91-generi Sun Apr 19 00:17 - 18:18 (2+18:01)
reboot   system boot  4.15.0-91-generi Sat Apr 18 23:10 - 16:16  (-6:53)

wtmp begins Sun Mar 29 12:49:47 2020
yanzhiwei@aliyun:~$ last -x 显示系统关机重启等信息
root     pts/0        183.197.237.163  Sat Apr 18 16:17 - 18:29  (02:11)
runlevel (to lvl 5)   4.15.0-91-generi Sat Apr 18 16:17 - 18:18 (3+02:01)
reboot   system boot  4.15.0-91-generi Sun Apr 19 00:17 - 18:18 (2+18:01)
shutdown system down  4.15.0-91-generi Sat Apr 18 16:16 - 00:17  (08:00)
runlevel (to lvl 5)   4.15.0-91-generi Sat Apr 18 15:10 - 16:16  (01:06)
reboot   system boot  4.15.0-91-generi Sat Apr 18 23:10 - 16:16  (-6:53)
shutdown system down  4.15.0-91-generi Sun Mar 29 12:49 - 23:10 (20+10:20)

wtmp begins Sun Mar 29 12:49:47 2020
 ```

### uname

`uname <a> `

```shell
yanzhiwei@aliyun:~$ uname -a  系统、主机名，内核版本，系统发行版本及时间，系统架构，处理器架构，硬件架构，系统内核
Linux aliyun 4.15.0-91-generic 92-Ubuntu SMP Fri Feb 28 11:09:48 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux   
yanzhiwei@aliyun:~$ 
```

```shell
yanzhiwei@aliyun:~$ cat /etc/os-release  realease 发布 
NAME="Ubuntu"
VERSION="18.04.4 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.4 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
yanzhiwei@aliyun:~$ cat /etc/hostname  主机名
aliyun
```

### data

`data <dsu> <参数>`

```shell
yanzhiwei@aliyun:~$ date -d @0   
Thu Jan  1 08:00:00 CST 1970   计算机元年 我们在东八区，此时格林威治时间为0点
root@aliyun:~ date +%s
1587700847
root@aliyun:~ date +"%Y-%m-%d %H:%M:%S"   类比于C语言的格式化字符串
2020-04-24 12:00:09
```

> NTP协议 使计算机时间同步化的一种协议

### cal

`cal<13jy> <参数>`

选项 -1，-3:最近一个月三个月； -j: 显示一年的第几天；-y:显示当前年

参数 月：指定月份； 年：指定年份



# 文件与目录

## 目录

| 命令  | 功能     | 命令  | 功能             |
| ----- | -------- | ----- | ---------------- |
| mkdir | 创建目录 | pwd   | 打印当前工作目录 |
| mkdir | 创建目录 | rmdir | 删除目录         |

绝对路径

相对路径

### cd

- `cd /etc`   绝对路径，直接切换到/etc目录

- cd ..  	

- cd .

- cd ~ 家目录

- cd -  回到上次工作目录

缺省情况就是默认情况

`env` 打印环境变量

```shell
yanzhiwei@aliyun:~/test$ env  打印环境变量
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;3
SSH_CONNECTION=183.197.57.134 33984 172.17.62.153 22
LESSCLOSE=/usr/bin/lesspipe %s %s
LANG=en_US.UTF-8
DISPLAY=localhost:10.0
S_COLORS=auto
XDG_SESSION_ID=483
USER=yanzhiwei
PWD=/home/yanzhiwei/test
HOME=/home/yanzhiwei
SSH_CLIENT=183.197.57.134 33984 22
SSH_TTY=/dev/pts/0
MAIL=/var/mail/yanzhiwei
TERM=xterm
SHELL=/bin/bash
SHLVL=1
LOGNAME=yanzhiwei
XDG_RUNTIME_DIR=/run/user/1001
PATH=/home/yanzhiwei/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
LESSOPEN=| /usr/bin/lesspipe %s
_=/usr/bin/env
OLDPWD=/home/yanzhiwei
```

### pwd 

`pwd [-LP]`     为了是区分链接

- -L:逻辑工作目录;   链接类似于快捷方式

- -P:物理工作目录;    找到真正目录

```shell
yanzhiwei@aliyun:~$ cd /var/  
yanzhiwei@aliyun:/var$ ls -al run
lrwxrwxrwx 1 root root 4 Mar 29 12:39 run -> /run
yanzhiwei@aliyun:/var$ cd run
yanzhiwei@aliyun:/var/run$ pwd -L
/var/run
yanzhiwei@aliyun:/var/run$ pwd -P
/run
```

### mkdir

`mkdir [pm] \<dir> `

- -p 自动创建父目录
- -m 设置权限

```shell
yanzhiwei@aliyun:~/test$ mkdir 123/456
mkdir: cannot create directory ‘123/456’: No such file or directory
yanzhiwei@aliyun:~/test$ mkdir -p 123/456
yanzhiwei@aliyun:~/test$ ls
123    man_ls  
yanzhiwei@aliyun:~/test$ cd 123
yanzhiwei@aliyun:~/test/123$ ls
456
yanzhiwei@aliyun:~/test/123$ mkdir -m 0777 345
yanzhiwei@aliyun:~/test/123$ ls
345  456
yanzhiwei@aliyun:~/test/123$ ls -ald 345    -d 列出目录本身，而不是内容
drwxrwxrwx 2 yanzhiwei yanzhiwei 4096 Apr 24 20:33 345
```

权限 mod = 777 会显示为高亮，例如上面懂得 /345

### rmdir

`rmdir [p] \<dir>`



> PATH="$PATH":/home/yanzhiwei/bin     " " 为软转义 这里只是为强调是字符串； 变量赋值

``` shell
yanzhiwei@aliyun:~/test$ a=b
yanzhiwei@aliyun:~/test$ echo b
b
yanzhiwei@aliyun:~/test$ echo {a}a
{a}a
yanzhiwei@aliyun:~/test$ echo ${a}a
ba
yanzhiwei@aliyun:~/test$ echo $a:a
b:a
```



### ln

 [![img](/Image/A2.Linux命令-photo/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653436666430332d306364612d346436302d396231632d3063323536656461663662322e706e67)](https://camo.githubusercontent.com/2b0c839d61700c8ef2caf3190cb6d42e66a1277b266f695190cecc9a244034e2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653436666430332d306364612d346436302d396231632d3063323536656461663662322e706e67) 



```shell
ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件
-i 	覆盖时询问用户
```

#### 1. 实体链接

在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。

删除任意一个条目，文件还是存在，只要引用数量不为 0。

有以下限制：不能跨越文件系统、不能对目录进行链接。

```shell
$ ln /etc/crontab .
$ ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
```



#### 2. 符号链接

符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。

当源文件被删除了，链接文件就打不开了。

因为记录的是路径，所以可以为目录建立符号链接。

```shell
$ ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -> /etc/crontab
```



## 文件与目录的管理

| 命令     | 功能               | 命令    | 功能     |
| -------- | ------------------ | ------- | -------- |
| ls       | 显示文件及目录信息 | cp      | 拷贝     |
| rm       | 删除               | mv      | 移动     |
| basename | 取文件名           | dirname | 取目录名 |

### ls

`ls <aldh> `

- `-d <file>` 显示目录本身, 而非内容
- `-h  human `以符合人类的方式看

```shell
yanzhiwei@aliyun:~/test$ ls -ald .
drwxrwxr-x 3 yanzhiwei yanzhiwei 4096 Apr 24 20:32 .
yanzhiwei@aliyun:~/test$ ls -aldh .
drwxrwxr-x 3 yanzhiwei yanzhiwei 4.0K Apr 24 20:32 .
```

* `ls -lrt` 递归显示文件的详细信息并按照时间排序 

  

### cp

`cp [irapdslu] <sour> <des>`

- -i 若文件存在，询问用户
- -r 递归复制
- -a pdr的集合
- -p  连同文件属性cp
- -d 若源文件为连接文件的属性，则复制连接文件的属性
- -u 原文件比目的文件新才cp



### rm   (remove 移除)

`rm [irf] <dri_or_file>`

- -f force 强制

> 一般`-f` format、file、force

### mv

`mv [ifu] <source...> <dest>` 可用于重命名

`mv source1 source2 source3 dir` 必须为dir目录

### dirname 和 basename

```shell
yanzhiwei@aliyun:~/test/123$ dirname /test/123/456
/test/123
yanzhiwei@aliyun:~/test/123$ basename /test/123/456
456

```

> 用于文件路径和名称的获取

`dirname`和`basename `不需要参数文件真实存在



### file 文件名

  显示文件类型    

`-i`  显示 mime类型


## 文件内容的查阅

| 命令 | 功能                   | 命令 | 功能                       |
| ---- | ---------------------- | ---- | -------------------------- |
| cat  | 正向连续读             | tac  | 反向连续读                 |
| nl   | 输出行号显示文件       | od   | 以二进制方式查看文件内容   |
| more | 一页一页的显示文件内容 | less | 类似于more，但可以上下翻看 |
| tail | 只看末尾的几行         | head | 只看头几行                 |

### cat

`cat [-AbEbTv] <file>`

- -A 相当于-vET
- -v 列出看不出的字符，类似于vim可视模式； vim中 `:set list`
- -E 显示断行符为$
- -T 显示TAB为^I
- -b 显示行号，不包括空行
- -n  连同空行列出行号

### nl

`nl [-bnw] \<file>`

- -b a :相当于 cat -n
- -b t :相当于 cat -b
- -n ln，rn，rz :屏幕最左，字段最右，字段最右显示同时前面自动补全0
- -w `<num>`  :行号所占位数

### more

`more <file>`

- /string 向下查找string关键字
- :f  显示文件名称和当前显示的行数
- q 离开

### less

`less <file>`

- /string 向下查找;  n : 继续向下
- /?string 反向查找;  N: 继续反向

### head

`head [-n num] <file>`

- `-n num` : 显示文件前num行
- `-n -num` :除去后num行，都显示

### tail

`tail [-n num] <file>`

- `-n num` : 显示文件后num行
- `-n -num` :除去前num行，都显示

查看一个文件的第116行到120行

```shell
yanzhiwei@aliyun:~/test/123$ man ls | nl -b a -w 5 -n rz | head -n 120 | tail -n 5
00116	       -N, --literal
00117	              print entry names without quoting
00118	
00119	       -o     like -l, but do not list group information
00120	
```



## 修改文件时间与新建文件

### 文件的三个时间

- mtime	 modify    默认，内通数据改动时才更新
- ctime      change   文件的权限， 属性改动时更新
- atime      access    文件的内容被取用access时，更新

```shell
(base) worst@worst:~/2.code$ ls -l --time=ctime   / dir     默认为mtime， --time只可=ctime或atime
总用量 16
drwxr-xr-x 10 worst worst 4096 7月  25  2019 1.暑期集训营
drwxr-xr-x  2 worst worst 4096 7月  23  2019 2.python
drwxr-xr-x  2 worst worst 4096 4月  27 22:22 3.测试
drwxr-xr-x  6 worst worst 4096 10月 19  2019 4.日常

```



### touch

​	`touch  <-acdmt] <file>`    主要用于修改时间,一般就是创建空白文件.

- -a:仅修改访问时间 



## 文件隐藏属性

### chattr

`chattr [ +-= ] [ ASacdistu ] <f ile_or_dir >`

- A : 不修改atime, 节省磁盘，避免忙碌
- S : 同步写入。写入磁盘，再返回；程序到磁盘中间有 缓冲写（内核写入磁盘），超过块(4k)再写入；--> 数据库，保证数据一致性。
- a : append(追加),只能增加数据； --> 适合用于日志，防止删除
- c : 自动压缩,解压 --> 主要用于备份系统中
- d: 不会被dump程序备份
- i : 不能删除、修改、建立连接 --> 若删除，先删除权限
- s : 文件删除时, 直接从磁盘删除  --> 用于敏感数据
- u : 文件删除时, 数据内容存在磁盘中 --> 默认，很高效

### lsattr

`lsattr [-adR] <file_or_dir>`

- -a : 打印隐藏文件的隐藏属性
- -d : 如果是目录，仅打印目录的信息
- -R ：递归

```shell
(base) worst@worst:~/4.test$ touch a
(base) worst@worst:~/4.test$ ll
总用量 16
drwxr-xr-x  2 worst worst 4096 4月  28 14:39 ./
drwxr-xr-x 54 worst worst 4096 4月  28 09:13 ../
-rw-r--r--  1 worst worst    0 4月  28 14:39 a
-rwxr-xr-x  1 worst worst   65 4月  28 08:36 first.sh*
-rwxr-xr-x  1 worst worst  230 4月  28 08:35 test.sh*
(base) worst@worst:~/4.test$ chattr +a a   只可追加
chattr: 不允许的操作 设置 a 的标志时
(base) worst@worst:~/4.test$ sudo !!      执行上一次命令
sudo chattr +a a
[sudo] worst 的密码： 
(base) worst@worst:~/4.test$ lsattr -a a
-----a--------e--- a
(base) worst@worst:~/4.test$ vim a
(base) worst@worst:~/4.test$ echo a > a  不可覆盖
bash: a: 不允许的操作
(base) worst@worst:~/4.test$ echo a >> a
(base) worst@worst:~/4.test$ cat a
a

```



## ==**文件的特殊权限**==

| 权限       | 粘滞位 | 作用对象               | 效果                                   |
| ---------- | ------ | ---------------------- | -------------------------------------- |
| set_uid    | s      | 二进制程序文件，非脚本 | 用户在执行改程序是获取程序所有者权限   |
| set_gid    | s      | 目录和二进制程序文件   | 用户在该目录里，有效组变为目录所属组   |
| sticky bit | t      | 目录                   | 在该目录里，用户只能删除自己创建的内容 |

| u    | 粘   |      | g    | 滞   |      | o    | 位   |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| r    | w    | x    | r    | w    | x    | r    | w    | x    |
| x    | ->   | s    | 后   | 面   | 同   | 理   |      |      |
| 无x  | ->   | S    | 原来 | 有   | x    | 则   | 小   | 写   |

set_uid    password修改

set_gid

![image-20200428145233838](/Image/A2.Linux命令-photo/image-20200428145233838-1623667342643.png)

## 命令与文件的查询

| 命令   | 功能                   | 命令    | 功能           |
| ------ | ---------------------- | ------- | -------------- |
| which  | 寻找执行文件           | whereis | 寻找特定文件   |
| locate | 搜索文件（可部分查找） | find    | 多样化高级查找 |

### which

查找PATH路径下所有的可执行文件

```shell
$ which [-a] command
-a ：将所有指令列出，而不是只列第一个
```



### whereis

`whereis [-bmsu] <file_or_dir>`      寻找特定文件

- -b ：只查找二进制文件
- -m ：之查找manual路径下的文件
- -s ： 只查找source源文件
- -u ： 查找其他文件

```shell
(base) worst@worst:~/4.test$ whereis stdio
stdio: /usr/include/stdio.h /usr/share/man/man3/stdio.3.gz
(base) worst@worst:~/4.test$ whereis math
math: /usr/include/math.h
```



### locate

`locate [-ir] keyword`      模糊定位， 类似于Windows（Everything），建立索引

- -i ：忽略大小写

- -r ：后面可接正则表达式

- 相关文件： /etc/updatedb.conf   和  /var/lib/mlocate

  `updatedb` 更新数据库，索引更新

```shell
yanzhiwei@aliyun:~/test$ touch Test.txt
yanzhiwei@aliyun:~/test$ locate *est.t
yanzhiwei@aliyun:~/test$ locate *est.txt
yanzhiwei@aliyun:~/test$ ls
123     temp    test11  test14  test17  test2   test4  test7  Test.txt
a.cpp   test1   test12  test15  test18  test20  test5  test8  touch
man_ls  test10  test13  test16  test19  test3   test6  test9
yanzhiwei@aliyun:~/test$ updatedb
updatedb: can not open a temporary file for `/var/lib/mlocate/mlocate.db'
yanzhiwei@aliyun:~/test$ sudo updatedb   更新数据库，
[sudo] password for yanzhiwei: 
yanzhiwei@aliyun:~/test$ locate *est.txt
/home/yanzhiwei/test/Test.txt
```



### find

`find [PATH] [option] [action]`

与时间相关 -atime，-ctime， -mtime

- -mtime n ： n天前的"一天之内"修改的文件
- -mtime +n ：n天前，不包含n，修改过的文件
- -mtime -n ：n天之内，包含n，修改过的文件
- -newer file ：比file还要新的文件

+4、4 和 -4 的指示的时间范围如下：
![img](/Image/A2.Linux命令-photo/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36353866633565372d373963302d343234372d393434352d6436396266313934633533392e706e67)

与用户或用户组相关的参数：

- -uid n ：用户UID为n
- -gid n ： 群组GID为n
- -user name ：用户名为name
- -group name ：群组名为name
- nouser ： 文件所有者不存在 /etc/passwd 的文件
- nogroup ：文件所在组不存在/etc/group 的文件

与文件权限及名称相关

- -name filename ：文件名为filename
- -size [+-] SIZE ：查找比SIZE大或小的
- -type TYPE ：f b c d l s p
- -perm mode ：mode 刚好等于的文件
- -perm -mode ：全部包含mode的文件           查找指定权限的文件

```shell
(base) worst@worst:~/2.code$ find -exec ls -l {} \;
总用量 16
drwxr-xr-x 10 worst worst 4096 7月  25  2019 1.暑期集训营
drwxr-xr-x  2 worst worst 4096 7月  14  2019 2.python
drwxr-xr-x  2 worst worst 4096 4月  27 22:22 3.测试
drwxr-xr-x  6 worst worst 4096 10月 19  2019 4.日常
总用量 16
-rw-r--r-- 1 worst worst 328 7月  10  2019 class.py
-rw-r--r-- 1 worst worst 320 7月  10  2019 is_prime.py
-rw-r--r-- 1 worst worst 420 7月  10  2019 prime_shai.py
-rw-r--r-- 1 worst worst 350 7月  10  2019 test.py
```

```shell
yanzhiwei@aliyun:~/test$ find ~ -mtime -4 -type f 2>/dev/null
/home/yanzhiwei/.cache/ctrlp/mru/cache.txt
/home/yanzhiwei/1.code/EP01-2.c
/home/yanzhiwei/1.code/EP01-1.c
/home/yanzhiwei/1.code/EP06-1.c
/home/yanzhiwei/1.code/a.out
/home/yanzhiwei/1.code/test.cpp
/home/yanzhiwei/1.code/scan.c
/home/yanzhiwei/1.code/1.test.c

```

```shell
yanzhiwei@aliyun:~/test$ find ~ -mtime -3 -type f -user yanzhiwei -size -1024 -name "*.c" 2>/dev/null
/home/yanzhiwei/1.code/EP01-2.c
/home/yanzhiwei/1.code/EP01-1.c
/home/yanzhiwei/1.code/EP06-1.c
/home/yanzhiwei/1.code/scan.c
/home/yanzhiwei/1.code/1.test.c
/home/yanzhiwei/1.code/printf.c
```

```shell
yanzhiwei@aliyun:~/test$ find ~ -mtime -3 -type f -user yanzhiwei -size -1024 -name "*.c" -perm -644 2>/dev/null | xargs ls -al    xargs   转换参数， stdin获取转到参数
-rw-rw-r-- 1 yanzhiwei yanzhiwei 448 Apr 25 18:14 /home/yanzhiwei/1.code/1.test.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 494 Apr 25 18:38 /home/yanzhiwei/1.code/EP01-1.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 465 Apr 25 18:43 /home/yanzhiwei/1.code/EP01-2.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 435 Apr 25 18:53 /home/yanzhiwei/1.code/EP06-1.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 434 Apr 25 15:35 /home/yanzhiwei/1.code/printf.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 388 Apr 25 15:50 /home/yanzhiwei/1.code/scan.c
yanzhiwei@aliyun:~/test$ find ~ -mtime -3 -type f -user yanzhiwei -size -1024 -name "*.c" -perm -644 2>/dev/null -exec ls -l {} \;    -exec执行， {}用于替换替换内容，\; 转义：需要; 而不是顺序执行
-rw-rw-r-- 1 yanzhiwei yanzhiwei 465 Apr 25 18:43 /home/yanzhiwei/1.code/EP01-2.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 494 Apr 25 18:38 /home/yanzhiwei/1.code/EP01-1.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 435 Apr 25 18:53 /home/yanzhiwei/1.code/EP06-1.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 388 Apr 25 15:50 /home/yanzhiwei/1.code/scan.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 448 Apr 25 18:14 /home/yanzhiwei/1.code/1.test.c
-rw-rw-r-- 1 yanzhiwei yanzhiwei 434 Apr 25 15:35 /home/yanzhiwei/1.code/printf.c

```

`xargs`



## 用户管理

### 细节

​        root 用户为根用户,也就是系统管理员,拥有全部权限    

​      一个用户只能拥有一个 群组编号 ，但是还可以归属于其它附加群组    

​      用户管理的重要配置文件：    

| /etc/passwd  | 用户名 密码位 用户编号 归属群组编号 姓名 $HOME目录 登录Shell |
| ------------ | ------------------------------------------------------------ |
| /etc/shadow  | 用户名 已加密密码 密码改动信息 密码策略                      |
| /etc/group   | 群组名 密码位 群组编号 组内用户                              |
| /etc/gshadow | 群组密码相关文件                                             |
| /etc/sudoers | 用户名 权限定义 权限                                         |

- ​	请使用“**visudo**”命令修改`/etc/sudoers`，而不要直接编辑        
- ​	可以使用 **pwconv** 命令创建影子密码，将 `/etc/passwd` 文件中的密码转换到 `/etc/shadow` 文件    

### su [用户名]

​      切换到其它用户，默认切换到 root用户。提示密码为目标用户密码    

| -f      | 快速切换，忽略配置文件     |
| ------- | -------------------------- |
| - \| -l | 重新登录                   |
| -m \|-p | 不更改环境变量             |
| -c 命令 | 切换后执行命令，并退出切换 |

### sudo 命令

​      以其它用户的身份执行命令，默认以 root 的身份执行。提示密码为当前用户密码 。

只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。  

| -s                  | 切换为 root shell           |
| ------------------- | --------------------------- |
| -i                  | 切换为 root shell，并初始化 |
| -u 用户名\|用户编号 | 执行命令的身份              |
| -l                  | 显示自己的权限              |

### passwd [用户名]

​      设定用户密码    

| -d      | 清除密码                         |
| ------- | -------------------------------- |
| -l      | 锁定账户                         |
| -e      | 使密码过期，在下次登录时更改密码 |
| -S      | 显示密码认证信息                 |
| -x 天数 | 密码过期，最大使用时间           |
| -n 天数 | 冻结密码，最小使用时间           |
| -s      | 更改 登录Shell                   |
| -f      | 更改用户信息                     |

​        示例：    

```
$passwd
Changing password for user
(current) UNIX password:      原密码
Enter new UNIX password:      新密码
Retype new UNIX password:     确认新密码    
```

### gpasswd 群组名

​      更改群组    

| -a 用户名        | 将用户加入群组                                               |
| ---------------- | ------------------------------------------------------------ |
| -d 用户名        | 将用户从群组中删除                                           |
| -r               | 删除密码                                                     |
| -A 用户名        | 将用户设置为群组管理员(群组管理员或 root 才可以使用 gpasswd 命令） |
| -M 用户1,用户2…… | 设置群组成员                                                 |

### chsh -s Shell [用户名]

​      更改登录 Shell    

### usermod 用户名

​      修改用户账号    

| -d 目录     | 设定 $HOME 目录                 |
| ----------- | ------------------------------- |
| -m          | 设定 $HOME 目录时自动建立该目录 |
| -s Shell    | 修改用户 登录Shell              |
| -l 新登录名 | 修改为新登录名                  |
| -u 用户编号 | 修改用户编号                    |
| g 群组名    | 修改用户归属群组                |
| -G 群组名   | 修改用户归属辅组                |
| -L          | 锁定帐户                        |
| -U          | 解除锁定                        |
| -e 过期时间 | 设定用户账号过期时间            |
| -f 缓冲天数 | 设定密码过期后多长时间关闭账号  |
| -c 字符串   | 修改用户备注                    |

### useradd 用户名

​      新建用户    

| -d 目录     | 设定 $HOME 目录                                         |
| ----------- | ------------------------------------------------------- |
| -m          | 自动建立 $HOME 目录                                     |
| -M          | 不自动建立 $HOME 目录                                   |
| -s Shell    | 设定用户 登录Shell                                      |
| -u 用户编号 | 设定用户编号                                            |
| -g 群组名   | 设定用户归属群组                                        |
| -G 群组名   | 设定用户归属附加群组                                    |
| -n          | 不建立以用户名为名称的群组                              |
| -e 过期时间 | 设定用户账号过期时间                                    |
| -f 缓冲天数 | 设定密码过期后多长时间关闭账号                          |
| -c 字符串   | 设定用户备注                                            |
| -D [表达式] | 更改预设值 （预设值保存于 /etc/default/useradd 文件中） |

- ​	新建用户规则保存于 `/etc/login.defs` 文件中    
- ​	新建用户默认文件保存于 `/etc/skel/` 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 `$HOME` 目录      

### userdel 用户名 
 -r  删除用户相关文件和目录 

### id [用户名]

​      显示用户 用户编号 群组编号 归属附加群组    

## 磁盘和内存管理

**文件大小和占用空间大小是不一样的，因为要对齐**

### 细节

 Linux 中，设备用`/dev/`目录下的文件表示。例如

```
/dev/hda1 第一块硬盘的第一主分区
/dev/hdb5 第二块硬盘的第一逻辑分区
/dev/sda4 第一块 SATA 硬盘的第四主分区，或者扩展分区
/dev/null 黑洞设备    
```

###   mount 设备文件 [挂载路径]

​      挂载文件系统    

| -t                       | 指定文件系统的类型                                           | 通常不必指定，mount 自动检测                                 |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 常见类型                 | reiserfs                                                     | ReiserFS 3.6版                                               |
| xfs                      | SGI 技术                                                     |                                                              |
| jfs                      | IBM 技术                                                     |                                                              |
| ext3                     | Linux 传统文件系统                                           |                                                              |
| vfat                     | fat fat32                                                    |                                                              |
| ext2                     | Linux 传统文件系统，不带日志                                 |                                                              |
| ntfs                     | WINNT                                                        |                                                              |
| iso9660                  | 光盘                                                         |                                                              |
| smbfs                    | Windows 文件共享                                             |                                                              |
| -o [选项1] [选项2] ..... |                                                              |                                                              |
| 选项                     | loop                                                         | 环设备。光盘、ISO 映像文件等，通常用于挂载映像文件（而不是设备文件） |
| bind                     | 绑定。将一个目录（而不是设备文件）挂载到另一个目录           |                                                              |
| ro \| rw                 | 只读 readonly；可读写 read-write                             |                                                              |
| sync \| async            | 同步模式\|异步模式。决定修改是否立即写入文件系统             |                                                              |
| atime \| noattime        | 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 noatime |                                                              |
| auto \| noauto           | 自动挂载模式                                                 |                                                              |
| exec \| noexec           | 是否允许执行                                                 |                                                              |
| defaults                 | 使用预设的选项 rw, suid, dev, exec, auto, nouser, async      |                                                              |
| iocharset=UTF-8          | 指定字符集，可简写为 utf8                                    |                                                              |
| codepage=936             | 指定代码页，可简写为 cp936  西文系统代码页为 437             |                                                              |
| umask=权限掩码是         | 设定权限掩码                                                 |                                                              |
| uid=用户编号             | 设定归属用户                                                 |                                                              |
| gid=群组编号             | 设定归属群组                                                 |                                                              |
| remount                  | 以不同选项重新挂载                                           |                                                              |
| -L 卷标                  | 挂载带有特殊卷标的分区                                       |                                                              |
​	挂载 NTFS 分区时请使用 **utf8** 选项；挂载 FAT 分区时请使用 **iocharset=utf8,codepage=936** 选项，以避免乱码    

​      **mount -a**    

​      挂载 `/etc/fstab` 文件中定义的所有设备。示例：    

```
sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom
sudo mount -t vfat -o remount iocharset=utf8,codepage=936  /dev/hda5 /media/hda5    
```

### umount 设备文件 | 挂载路径

​      卸载已挂载文件系统    

### du [路径]

​      计算文件或目录空间占用

显示每个文件和目录的磁盘使用空间    

| -h               | 人性化显示。自动以 G、M、K 为单位显示占用空间大小 |
| ---------------- | ------------------------------------------------- |
| --max-depth=数字 | 显示目录深度                                      |
| -l               | 重复计算硬链接文件大小                            |
| -L               | 计算符号链接文件大小                              |
| -a               | 显示当前目录子目录中的文件                        |
| -c               | 显示文件数s                                       |


## 

### df

​      查看已挂载文件系统的磁盘空间占用    

显示磁盘分区上可以使用的磁盘空间

| -a              | 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如`/proc 文件系统` |
| --------------- | ------------------------------------------------------------ |
| -T              | 显示文件系统类型                                             |
| -k              | 以 k 字节为单位显示                                          |
| -i              | 显示 i节点 信息，而不是磁盘块                                |
| -t 文件系统类型 | 显示指定类型的文件系统的磁盘空间使用情况                     |
| -x 文件系统类型 | 列出排除指定类型文件系统的磁盘空间使用情况（与 t 选项相反）  |
| -l              | 只显示本地文件系统                                           |

### free

​      查看内存、缓冲区、交换空间的占用    

| -b    | 以字节为单位显示数值   |
| ----- | ---------------------- |
| -k    | 以千字节为单位显示数值 |
| -m    | 以兆字节为单位显示数值 |
| -g    | 以吉字节为单位显示数值 |
| -l    | 显示内存占用峰值       |
| -o    | 不显示缓冲区占用       |
| -t    | 统计结果               |
| -s 秒 | 刷新频率               |

* Mem是物理内存的使用情况
* Swap是交换空间的使用情况
* total是物理内存和交换空间的总大小
* used是物理内存和交换空间已经被使用的大小
* free是物理内存和交换空间可用空间（从内核和系统的角度看，真正尚未被使用的物理内存数量）
* shared 列显示被共享使用的物理内存大小。
* buff/cache 列显示被 buffer 和 cache 使用的物理内存大小（其实是内存为缓存磁盘数据设置的缓冲区）。
* available 列显示还可以被应用程序使用的物理内存大小，当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求，理想来说available  = free + buffer + cache

### sync

​      同步文件系统。将缓冲区中的数据写入文件系统    

### fdisk 磁盘设备文件

​      分区表修改工具(磁盘设备文件应为整块磁盘，而不是磁盘中的分区。例如 `/dev/sda` ，而不是 `/dev/sda1`)    

| m    | 使用帮助                                                     |
| ---- | ------------------------------------------------------------ |
| l    | 查看已知文件系统类型                                         |
| p    | 显示分区信息                                                 |
| n    | 新建分区 （p:主分区 l:扩展分区 参见 [“分区概念”一节](https://i.linuxtoy.org/docs/guide/ch08.htmlpartition) ) |
| d    | 删除分区                                                     |
| t    | 改变分区类型                                                 |
| w    | 将改动写入分区表                                             |
| q    | 放弃改动并退出                                               |

​      **fdisk -l** 查看所有磁盘分区信息    

### cfdisk

​      更加友善的分区表修改工具    

### mkfs.文件系统类型 分区设备文件

​      将分区格式化为文件系统。示例：    

```shell
sudo mkfs.reiserfs /dev/hda1
sudo mkfs.xfs /dev/sda1    
```

## 压缩文件名

Linux 底下有很多压缩文件名，常见的如下：

| 扩展名    | 压缩程序                              |
| --------- | ------------------------------------- |
| *.Z       | compress                              |
| *.zip     | zip                                   |
| *.gz      | gzip                                  |
| *.bz2     | bzip2                                 |
| *.xz      | xz                                    |
| *.tar     | tar 程序打包的数据，没有经过压缩      |
| *.tar.gz  | tar 程序打包的文件，经过 gzip 的压缩  |
| *.tar.bz2 | tar 程序打包的文件，经过 bzip2 的压缩 |
| *.tar.xz  | tar 程序打包的文件，经过 xz 的压缩    |

## 压缩指令

### 1. gzip

gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。

经过 gzip 压缩过，源文件就不存在了。

有 9 个不同的压缩等级可以使用。

可以使用 zcat、zmore、zless 来读取压缩文件的内容。

```
$ gzip [-cdtv] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
- ：  为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
```

 

### 2. bzip2

提供比 gzip 更高的压缩比。

查看命令：bzcat、bzmore、bzless、bzgrep。

```
$ bzip2 [-cdkzv] filename
-k ：保留源文件
```

 

### 3. xz

提供比 bzip2 更佳的压缩比。

可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。

查看命令：xzcat、xzmore、xzless、xzgrep。

```
$ xz [-dtlkc] filename
```



## 打包

压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。

```
$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；切记，这个参数是最后一个参数，后面只能接档案名。
-C 目录 ： 在特定目录解压缩。
```

| 使用方式 | 命令                                                  |
| -------- | ----------------------------------------------------- |
| 打包压缩 | tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 |
| 查 看    | tar -jtv -f filename.tar.bz2                          |
| 解压缩   | tar -jxv -f filename.tar.bz2 -C 要解压缩的目录        |

**打包**

\ tar -cf all.tar *.jpg
这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。

\ tar -rf all.tar *.gif
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。

\ tar -uf all.tar logo.gif
这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。

\ tar -tf all.tar
这条命令是列出all.tar包中所有文件，-t是列出文件的意思

\ tar -xf all.tar
这条命令是解出all.tar包中所有文件，-t是解开的意思

**压缩**

tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg 

tar -czf jpg.tar.gz *.jpg  //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz

 tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2

tar -cZf jpg.tar.Z *.jpg  //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z

rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux

zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux

**解压**

tar -xvf file.tar //解压 tar包

tar -xzvf file.tar.gz //解压tar.gz

tar -xjvf file.tar.bz2  //解压 tar.bz2

tar -xZvf file.tar.Z  //解压tar.Z

unrar e file.rar //解压rar

unzip file.zip //解压zip

------

## 其它

### echo 字符串

​      回显。较复杂的字符串，可以使用 **`"`** 括起来。    

| 选项     | -n           | 输出内容不换行 |
| -------- | ------------ | -------------- |
| -E       | 不解析脱字符 |                |
| -e       | 解析脱字符   |                |
| 控制字符 | \\           | 反斜线         |
| \a       | 警告         |                |
| \b       | 退格         |                |
| \n       | 换行         |                |
| \r       | 回车         |                |
| \t       | 水平制表符   |                |

### clear

​      清空屏幕    

### alias 输入内容=实际内容

​      别名，为命令指定一个别名，以简化输入。例如：    

```
alias ls='ls -AF --color=auto'    
```

- ​	可以将您的定义保存在 `~/.bashrc` 文件中    

### export 变量名

  将变量导出为环境变量，常写变量赋值一同使用，例如：    

```
export PATH="$PATH:xxx"    
```

### shutdown

​      关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)    

| -h            | 关闭电源                         |
| ------------- | -------------------------------- |
| -r            | 重启                             |
| -n            | 强行关机，不向 init进程 发送信号 |
| -k            | 模拟关机，向登录者发送关机警告   |
| -t 秒         | N秒后关机                        |
| time 时间     | 定时关机                         |
| -c [说明信息] | 取消关机                         |
| -f            | 重启时忽略检测文件系统           |
| -F            | 重启时强制检测文件系统           |

### reboot

​      重新启动计算机。选项与 halt 相似    



## 缩写

| cd   | Change Directory            |
| ---- | --------------------------- |
| dd   | Disk Dump                   |
| df   | Disk Free                   |
| du   | Disk Usage                  |
| pwd  | Print Working Directory     |
| ps   | Processes Status            |
| PS   | Prompt Strings              |
| su   | Substitute User             |
| rc   | Run Command                 |
| Tcl  | Tool Command Language       |
| cups | Common Unix Printing System |
| apt  | Advanced Packaging Tool     |
| bg   | BackGround                  |
| ping | Packet InterNet Grouper     |

如果首字母后为“h”，通常保留

| chsh  | CHange SHell       |
| ----- | ------------------ |
| chmod | CHange MODe        |
| chown | CHange OWNer       |
| chgrp | CHange GRouP       |
| bash  | Bourne Again SHell |
| zsh   | Z SHell            |
| ksh   | Korn SHell         |
| ssh   | Secure SHell       |

递归缩写[[3](https://i.linuxtoy.org/docs/guide/ch02s02.htmlftn.id3048209)]也属于这一类，如：

| GNU  | GNU's Not Unix              |
| ---- | --------------------------- |
| PHP  | PHP: Hypertext Preprocessor |
| RPM  | RPM Package Manager         |
| WINE | WINE Is Not an Emulator     |
| PNG  | PNG's Not GIF               |
| nano | Nano's ANOther editor       |

有些缩写可能有多种定义，如：

```shell
rpm
RPM Package Manager 
RedHat Package Manager
  
bc
Basic Calculator
Better Calculator  
```

如果只有一个单词，通常取每个音节的首字母：

| cp   | CoPy   |
| ---- | ------ |
| ln   | LiNk   |
| ls   | LiSt   |
| mv   | MoVe   |
| rm   | ReMove |

对于目录，通常使用前几个字母作为缩写：

| bin  | BINaries              |
| ---- | --------------------- |
| dev  | DEVices               |
| etc  | ETCetera              |
| lib  | LIBrary               |
| var  | VARiable              |
| proc | PROCesses             |
| sbin | Superuser BINaries    |
| tmp  | TeMPorary             |
| usr  | Unix Shared Resources |

这种缩写的其它情况

| diff   | DIFFerences        |
| ------ | ------------------ |
| cal    | CALendar           |
| cat    | CATenate           |
| ed     | EDitor             |
| exec   | EXECute            |
| tab    | TABle              |
| regexp | REGular EXPression |

如果某种缩写比较深入人心，例如“mesg”代表“message”，在新的复合缩写中，将沿用这种缩写方式

| dmesg  | Diagnostic MESsaGe |
| ------ | ------------------ |
| sed    | Stream EDitor      |
| stty   | Set TTY            |
| fstab  | FileSystem TABle   |
| passwd | PASSWorD           |

有些缩写中，第一个字母“g”，代表“GNU”

| awk   | Aho Weiberger and Kernighan  |      |
| ----- | ---------------------------- | ---- |
| gawk  | GNU AWK                      |      |
| gpg   | GNU Privacy Guard            |      |
| grep  | GNU Regular Expression Print |      |
| egrep | Extended GREP                |      |



------

[[3](https://i.linuxtoy.org/docs/guide/ch02s02.htmlid3048209)] 定义中包含自身缩写，如 GNU： 

**`GNU`**'s Not Unix

使用这个定义来解释定义中的缩写：

(GNU's Not Unix)'s Not Unix

这意味着它是可以无限递归的



## 命令选项

- -a	

  all : 全部，所有 (ls , lsattr , uname) archive : 存档 (cp , rsync) append : 附加 (tar -A , 7z)

- -b

  blocksize : 块大小，带参数 (du , df) batch : 批处理模式 (交互模式的程序通常拥有此选项，如 top -b)

- -c

  commands : 执行命令，带参数 (bash , ksh , python) create : 创建 (tar)

- -d

  debug : 调试 delete : 删除 directory : 目录 (ls)

- -e

  execute : 执行，带参数 (xterm , perl) edit : 编辑 exclude : 排除

- -f

  force : 强制，不经确认(cp , rm ,mv) file : 文件，带参数 (tar) configuration file : 指定配置文件(有些守护进程拥有此选项，如 ssh , lighttpd)

- -g

  

- -h

  --help : 帮助 human readable : 人性化显示(ls , du , df) headers : 头部

- -i

  interactive : 交互模式，提示(rm , mv) include : 包含

- -k

  keep : 保留 kill 

- -l

  long listing format : 长格式(ls) list : 列表 load : 读取 (gcc , emacs)

- -m

  message : 消息 (cvs) manual : 手册 (whereis) create home : 创建 home 目录 (usermod , useradd)

- -n

  number : 行号、编号 (cat , head , tail , pstree , lspci) no : (useradd , make)

- -o

  output : 输出 (cc , sort) options : 选项 (mount)

- -p

  port : 端口，带参数 (很多网络工具拥有此选项，如 ssh , lftp ) protocol : 协议，带参数 passwd : 密码，带参数

- -q

  quiet : 静默

- -r

  reverse : 反转 recursive : 递归 (cp , rm , chmod -R)

- -s

  silent : 安静 size : 大小，带参数 subject

- -t

  tag type : 类型 (mount)

- -u

  user : 用户名、UID，带参数

- -v

  verbose : 冗长 version : 版本

- -w

  width : 宽度 warning : 警告

- -x

  exclude : 排除 (tar , zip)

- -y

  yes

- -z

  zip : 启用压缩 (bzip , tar , zcat , zip , cvs)

------

## 包管理工具

| 任务           | apt                        | zypp                             | yum                                | pacman                | emerge                                |
| -------------- | -------------------------- | -------------------------------- | ---------------------------------- | --------------------- | ------------------------------------- |
|                | Debian, Ubuntu             | openSUSE                         | Fedora, CentOS (redhat系)          | Archlinux             | Gentoo                                |
| 安装包         | apt-get install pkg        | zypper install pkg               | yum install pkg                    | pacman -S pkg         | emerge pkg                            |
| 移除包         | apt-get remove pkg         | zypper remove pkg                | yum erase pkg                      | pacman -R pkg         | emerge -C pkg                         |
| 更新包列表     | apt-get update             | zypper refresh                   | yum check-update                   | pacman -Sy            | emerge --sync \| layman -S (添加仓库) |
| 更新系统       | apt-get upgrade            | zypper update                    | yum update                         | pacman -Su            | emerge -avuDN world                   |
| 列出源         | cat /etc/apt/sources.list  | zypper repos                     | yum repolist                       | cat /etc/pacman.conf  | layman -L                             |
| 添加源         | edit /etc/apt/sources.list | zypper addrepo 仓库地址 仓库名称 | add 仓库 to /etc/yum.repos.d/      | edit /etc/pacman.conf | layman -a                             |
| 移除源         | edit /etc/apt/sources.list | zypper removerepo 仓库名称       | remove 仓库 from /etc/yum.repos.d/ | edit /etc/pacman.conf | layman -d                             |
| 搜索包         | apt-cache search pkg       | zypper search pkg                | yum search pkg                     | pacman -Qs pkg        | emerge --search                       |
| 列出已安装的包 | dpkg -l                    | rpm -qa                          | rpm -qa                            | pacman -Qii           | cat /var/lib/portage \| more          |





```sh
ls -l $(which cp) #参数替换
 echo $(($((5**2)) * 3))  #取幂， 括号
 mkdir {2006..2012}-0{1..9}  #括号展开
  mkdir $(echo a{A{1,2},B{3,4}}b) 
  #引用的第一种类型,双引号。如果你把文本放在双引号中,shell 使用的特殊字符,都失去它们的特殊含义,被当作普通字符来看待。有几个例外:$,\ (反斜杠),和 ‘(倒引号)。
# 这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效,然而参数展开、算术展开和命令替换仍然执行。使用双引号,我们可以处理包含空格的文件名。

echo $(cal)             #没有引用的命令替换导致命令行包含 38 个参数
echo "$(cal)"          #只有一个参数,参数中包括嵌入的空格和换行符。
#单引号如果需要禁止所有的展开
Ctrl-r 		#反向增量搜索。从当前命令行开始,向上增量搜索。
Alt-p 		#反向搜索,非增量搜索。(输入要查找的字符串,按下 Enter来执行搜索)。
Alt-n 		#向前搜索,非增量。
Ctrl-o 	 #执行历史列表中的当前项,并移到下一个。如果你想要执行历史列表中一系列的命令,这很方便。
!!  					#重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
!number 	#重复历史列表中第 number 行的命令。
passwd [user] #更改用户密码
vim 连接行 J
sudo sshfs -o nonempty,allow_other,exec yanzhiwei@aliyun/ /mnt/tecmint #远程挂载当前

find ~ ( -type f -not -perms 0600 ) -or ( -type d -not -perms 0700 )
find ~ -type f -name "*.JPG" -size +1M | wc -l
find ~ -type f -name 'foo*' -ok  ls -l '{}' ';'
"-exec"选项的作用是把 find 命令的结果放入"{}"中，再由命令 2 直接处理。
区别在于："-exec"的命令会直接处理；"-ok"的命令 2 在处理前会先询问
find ~ -iname "*.jpg" -print0 | xargs --null ls -l 
#find 命令的输出被管道到 xargs 命令,之后,xargs 会为 ls 命令构建参数列表
#xargs: 参数行过长  可用	print0
cat -A foo.txt
cat >> foo.txt
cat -ns foo.txt
 sort -t: -k 3n /etc/passwd
 ls -lh | sort -h -k 5
sort -t: -k1,1  /etc/passwd #以冒号隔开的第一个字段：用户名称进行排序
sort -t: -k4n,-k3n  /etc/passwd #以冒号隔开，先以第四段进行排序，然后以第三段进行排序
ls -l /usr/bin | sort -nr -k5 | head
sort foo.txt | uniq -cd
cut -d ':' -f 1 /etc/passwd | head
cut -f 3 distros.txt | cut -c 7-10
tr -d '\r' < dos_file > unix_file
tr a-zA-Z n-za-mN-ZA-M
```

