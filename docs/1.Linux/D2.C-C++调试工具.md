---
id : D2.C-C++调试工具
title : D2.C-C++调试工具
typora-root-url : ../
---

# 调试命令

#### gdb

* `l` 列出函数代码及行数
* `b 16` 在16行设置断点
* `b func` 在函数func设置断点
* `r` 运行程序
* `n` 单条执行程序
* `p i` 打印i变量的值
* `bt` 查看函数堆栈
* `finish` 退出函数
* `q` 结束调试

#### strace

* 监控用户空间进程和内核的交互，跟踪系统调用和信号传递
* `strace -c ./test` 统计./test使用的系统调用
* `strace -p pid` 跟踪现有进程

#### ipcs

* 用于报告系统的消息队列，信号量和共享内存等使用情况
* `ipcs -a`用于列出本用户所有相关的ipcs参数
* `ipcs -q`用于列出进程中的消息队列
* `ipcs -s`用于列出所有的信号量
* `ipcs -m`用于列出所有的共享内存信息
* `ipcs -l`用于列出系统限额，比如共享内存最大限制
* `ipcs -u`用于列出当前的使用情况

#### ipcrm

* 用于移除一个消息队列，或者共享内存段，或者一个信号集，同时会将与ipc对象相关联的数据也一起移除，只有超级管理员，或者ipc对象的创建者才能这样做
* `ipcrm -M shmkey`  移除用shmkey创建的共享内存段
* `ipcrm -m shmid`    移除用shmid标识的共享内存段
* `ipcrm -Q msgkey`  移除用msqkey创建的消息队列
* `ipcrm -q msqid`  移除用msqid标识的消息队列
* `ipcrm -S semkey`  移除用semkey创建的信号
* `ipcrm -s semid`  移除用semid标识的信号 

## valgrind检查内存泄漏

防范的根本思想在于在对缓冲区（一般为数组）进行拷贝前，要保证复制的长度不要超过缓冲区的空间大小。

- 常见的内存问题

  - 动态内存泄漏；
  - 资源泄漏，代码中以文件描述符为例；
  - 动态内存越界；
  - 数组越界；
  - 动态内存double free；
  - 使用野指针。

  

* 检查内存泄露原理

  * 检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。
  * 截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存 

* 最常用的是memcheck，用于发现绝大多数的内存错误使用情况

  * 使用未初始化的内存
  * 使用已经释放的内存
  * 内存访问越界

* memcheck原理

  * Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。
    * Valid-Value 表：对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。
    * Valid-Address 表：对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。
  * 检测原理：
    * 当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，**memcheck则报告读写错误**。
    * 内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会**报告使用未初始化内存错误**。 

  

## 程序从main函数开始吗

* 程序在main函数开始之前，已经完成了全局变量的初始化，堆栈初始化和系统I/O
* main之前完成全局变量的构造，在main之后完成全局变量的析构
* 另外atexit函数还可以在main函数之后运行，它接受一个函数指针作为参数

