---
id : A2.udp-football
title : A2.udp-football
typora-root-url : ../
---



## 多人实时足球项目设计

### 技术点

线程：多线程，互斥锁，条件变量，线程池

信号：SIGINT，SIGALARM，间隔定时器

IO：文件打卡，文件读写，非阻塞IO，IO多路复用，Select，Epoll

网络：TCP，UDP，SOCKET

### 界面

![image-20210916103201059](/Image/A2.udp-football-photo/image-20210916103201059.png)



### 整体框架

1. 本游戏是一个基于UDP网络编程的C/S架构的应用，需要独立完成 `server` 和 `client` 两端；
2. 玩游戏时，玩家启动 `cllent` 端，选择自己的队伍，登录 `server` 后，在球场外等待，之后自主进入球场，开始游戏；
3. 游戏过程中，由server端接收 `client` 的控制信息，决定玩家的移动，踢球，带球等游戏行为，再将游戏实时信息发送给所有客户端：
4. 玩家可以在游戏端发送聊天信息到客户端，同时也可以收到其他玩家的信息，当然也可以发送私聊信息给某位玩家

### 功能说明

1. 操作：
   - `space` 打开力度条，再次按下选中力度
   - `j` 停球
   - `k` 普通力度踢球
   - `l` 带球
   - `enter` 打开输入框，输入聊天信息

2. 移动：
   -  `w` 向上移动
   -  `s` 向下移动 
   -   `a` 向左移动
   -   `d` 向右移动

3. 规则判断：
   - 出界，直接在出界位置由对方球员发球
   - 进球，直接在球门前由守门员开球

### 详细说明
#### 服务端
1. 启动
   - 启动时默认读取配置文件，获取端口 `port` ，游戏地图大小等参数
   - 同样也可以在启动时，通过指定选项，若指定选项，则配置文件中的配置不生效。
2. 并发设置
   - 主线程
      - 主线程是一个 `acceptor `，循环等待用户**登录**，登录后将用户按照队伍不同加到各自从反应堆中
      - 在主线程中，开启定时器，注册时钟信号处理函数，收到时钟信号，向 `client` 发送游戏数据
      - 主线程中注册 `sigint` 信号处理函数，收到 `ctrl + c` 时，告知客户端下线，结束运行

   - 子线程
      - 两个子线程，每一个对应着一个队伍
      - 该线程为从反应堆，使用 `epoll` 等待用户控制信息，收到控制信息后，更新游戏数据

客户端 

1. 启动 
   - 启动时读取配置文件，获取服务端的 `ip`，`port` 等信息，获取玩家用户名，队伍
   - 启动时也可以指定选项，若指定选项，则配置文件中的配置不生效

2. 并发设置 
   - 主线程
     - 主线程向 `server` 发送登录信息，若收到响应，则成功登录，否则退出运行
     - 主线程中注册 `sigint ` 信号处理函数，收到 `ctrl＋c` 时，告知 `server` 下线，结束运行
     - 主线程负责接收键盘输入，判断游戏行为。子线程
   - 子线程
     - 子线程负责收服务端广播的信息，并做出解析
     - 重绘游戏界面

## 接口集合

### 数据接口

> 在 `common/datatype.h`

#### 球相关

文件：`datatype.h`

```cpp

struct Bpoint{
    double x;
    double y;
};

struct Aspeed{
    double x;//x上的加速度
    double y;//y上的加速度
};

struct Speed{
    double x;//x上的速度
    double y;//y上的速度
};

struct BallStatus {
    struct Speed v;//速度
    struct Aspeed a;//加速度
    int t;//时间
    int who;//谁
    char name[20];//名字
    int carry;
    //pthread_mutex_t mutex;
};
struct Score{
    int red;
    int blue;
};
```

#### 球员相关

文件：`datatype.h`

```cpp

struct Point{
    int x, y;
};

//#define MAX //每队球员数量

struct User{/*用户*/
    int team; //0 RED  1 BLUE
    char name[20];//name
    int fd; //存储该玩家用户对应的连接
    int online; // 1 在线 0 不在线
    int flag; //未响应的次数
   // struct sockaddr_in addr;
    struct Point loc;//position//人的位置
    int carry;
};

```

#### 数据交互相关

文件：`datatype.h`

```cpp
#define MAXMSG 1024 //日常的信息交互，如聊天信息，统一为512长度

// 登录相关
struct LogRequest{
    char name[20];
    int team;//0 RED 1 BLUE
    char msg[512];
};

struct LogResponse{
    int type;//0 success 1 failed
    char msg[512];
};


#define ACTION_KICK 0x01
#define ACTION_CARRY 0x02
#define ACTION_STOP 0x04

struct Ctrl {
    //control
    int action;
    int kick;
    int dirx;//方向x
    int diry;//方向y
    int strength;
};

#define FT_TEST 0x01 //服务端心跳信息
#define FT_WALL 0x02 //服务端以字符串方式广播游戏情况
#define FT_MSG 0x04 //客户端发送的信息，服务端转发的信息
#define FT_ACK 0x08 //客户端对心跳ACK确认
#define FT_FIN 0x10 //客户端，服务端下线前，对彼此的告知
#define FT_CTL 0x20 //客户端发送的控制信息
#define FT_GAME 0x40 //服务端向客户端广播的游戏实时图画json发送
#define FT_SCORE 0x80 //服务端对客户端广播的游戏比分变化,json发送(包括进球人)
#define FT_GAMEOVER 0x100 //游戏结束

struct FootBallMsg {
    //登陆后的信息交互
    int type; // type & FT_HEART
    int size;
    int team;//队
    char name[20];//名字
    struct Ctrl ctl;
    char msg[MAXMSG];//信息
};
```

#### 球场数据相关

文件：`datatype.h`

```cpp
struct Map{
    int width;
    int height;
    struct Point start; /*球场开始的位置*/ // Starting Point
    int gate_width;  // Goal size
    int gate_height;
};
```

#### 全局变量

#### 服务端

```cpp
// struct Map court;
struct Bpoint ball;/*球的位置*/
struct BallStatus ball_status;/*球的状态*/
struct Score score;/*比分*/
int repollfd, bepollfd; //从反应堆 sub_reactor
struct Map court;/*球场*/
```

## 通用接口

#### `get_conf_value`

> 从配置⽂件中，根据key找到value

⽂件：`common.c` 、`common.h`

```cpp
//判断path和key的合法性
//fopen(path, "r")
//while (getline(&line, &size, fp))
//		if strstr(line, key) != NULL
//判断下一个字符，是不是等于号
//strncpy()

char *get_value(char *path, char *key) {
    FILE *fp = NULL;
    ssize_t nrd;
    char *line = NULL, *sub = NULL;
//    extern char conf_ans[50];
    size_t linecap;
    if(path == NULL || key == NULL) {
         fprintf(stderr, "Error in argument!\n");
        return NULL;
    }
    if((fp = fopen(path, "r")) == NULL) {
        perror("fopen");
        return NULL;
    }
    while((nrd = getline(&line, &linecap, fp))!= -1) {
        if((sub = strstr(line, key)) == NULL) {
            continue;
        } else {
             if (line[strlen(key)] == '=') {
             strncpy(conf_ans, sub + strlen(key) + 1, nrd - strlen(key) - 2);
             *(conf_ans + nrd - strlen(key) - 2) = '\0';
             break;
            }
        }
    }
    free(line);
    fclose(fp);
    if(sub==NULL) {
        return NULL;
    }
    return conf_ans;
}
```

#### `global`

⽂件：`global.c` 、`global.h`

```cpp
char conf_ans[50];
```





#### `make_non_block`

```cpp
void make_nonblock_ioctl(int fd) {
    unsigned long ul = 1;
    ioctl(fd, FIONBIO, &ul);
}

void make_block_ioctl(int fd) {
    unsigned long ul = 0;
    ioctl(fd, FIONBIO, &ul);
}

void make_nonblock(int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {
        return;
    }
    flag |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
}

void make_block(int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {
        return ;
    }
    flag &= ~O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
}

```



## Socket接口

### socket_create_udp

> 创建一个绑定确定端⼝的UDP套接字

⽂件: `udp_server.c` 、`udp_server.h`

```cpp
//创建一个UDP套接字
//创建SOCK_DGRAM
//设置地址重用
//设置非阻塞套接字
//绑定INADDR_ANY & port
int socket_create_udp(int port) {
    int server_listen;
    if ((server_listen = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        return -1;
    }
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = INADDR_ANY;
    int opt = 1;
    setsockopt(server_listen, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    make_nonblock(server_listen);
    if (bind(server_listen, (struct sockaddr *)&server, sizeof(server)) < 0) {
        return -1;
    }
    return server_listen;
}



```

#### `socket_udp`

> 创建⼀个主动的UDP套接字

⽂件： `udp_client.c` 、`udp_client.h`

```cpp
//创建一个SOCK_DGRAM，UDP套接字
int socket_udp() {
    int sockfd;
    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket");
        return -1;
    }
    printf("socket creat.\n");
    return sockfd;
}
```

## Epoll接口

#### `add_to_sub_reactor`

> 将主反应堆上接⼊的客户添加到⼀个从反应堆

⽂件: `udp_epoll.c` 、 `udp_epoll.h`

```cpp
void add_event(int epollfd, int fd, int events);
void del_event(int epollfd, int fd);
int udp_connect(int epollfd, struct sockaddr_in *serveraddr);
int udp_accept(int epollfd, int fd, struct User *user);
void add_to_sub_reactor(struct User *user);

//注册epoll事件到epoll实例中
void add_event(int epollfd, int fd, int events) {
    struct epoll_event ev;
    ev.events = events;
    ev.data.fd = fd;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev);
    return;
}

//注册epoll实例，使用data.ptr保存用户user的地址
void add_event_ptr(int epollfd, int fd, int events, struct User *user) {
    struct epoll_event ev;
    ev.events = events;
    ev.data.ptr = (void *)user;

    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev);
    DBG(GREEN"Sub Thread"NONE":After Epoll Add %s.\n", user->name);
    return;
}

//从epollfd中注销fd文件

void del_event(int epollfd, int fd) {
    epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL);
    return;
}

int udp_connect(int epollfd, struct sockaddr_in * serveraddr) {
    int sockfd;
  //  if((sockfd = socket_udp()) < 0) {
    if((sockfd = socket_create_udp(port)) < 0) {
        perror("socket_udp");
        return -1;
    }
    DBG(GREEN"INFO"NONE": Before connect. \n");
    if (connect(sockfd, (struct sockaddr *)serveraddr, sizeof(struct sockaddr)) < 0) {
        perror("connect");
        return -1;
    }
    DBG(GREEN"INFO"NONE" : After connect.\n");
    int ret = send(sockfd, "Login!", sizeof("Login!"), 0);
    DBG(RED"RET = %d\n"NONE, ret);
   // add_event(epollfd, sockfd, EPOLLIN);
    return sockfd;
}



int check_online(struct LogRequest *request) {
    struct User *team = (request->team ? bteam : rteam);
    for(int i = 0; i < MAX; i++) {
        if(rteam[i].online && !strcmp(rteam[i].name, request->name))return 1;
        if(bteam[i].online && !strcmp(bteam[i].name, request->name))return 1;
    }
    return 0;
}

int udp_accept(int epollfd, int fd, struct User *user) {
    struct sockaddr_in client;
    int new_fd, ret;
    struct LogRequest request;
    struct LogResponse response;

    bzero(&request, sizeof(request));
    bzero(&response, sizeof(response));
    socklen_t len = sizeof(struct sockaddr_in);
    ret = recvfrom(fd, (void *)&request, sizeof(request), 0,
                   (struct sockaddr *)&client, &len);
    if (ret != sizeof(request)) {
        response.type = 1;
        strcpy(response.msg, "Login failed with NetWork errors!");
        sendto(fd, (void *)&response, sizeof(response), 0,
               (struct sockaddr *)&client, len);
        return -1;
    }

    if(check_online(&request)) {
        response.type = 1;
        strcpy(response.msg, "You Are Alreadly Playint This Game SomeWhere!");
        sendto(fd, (void *)&response, sizeof(response), 0,
               (struct sockaddr *)&client, len);
        return -1;
    }

    response.type = 0;
    strcpy(response.msg, "Login success. Enjoy yourself.");
    sendto(fd, (void *)&response, sizeof(response), 0,
           (struct sockaddr *)&client, len);

    if(request.team)
    DBG(GREEN"INFO"NONE" : "BLUE" %s on %s : %d longin! (%s)\n"NONE,
        request.name, inet_ntoa(client.sin_addr), ntohs(client.sin_port),
        request.msg);
    else
    DBG(GREEN"INFO"NONE" : "RED" %s on %s : %d longin! (%s)\n"NONE,
        request.name, inet_ntoa(client.sin_addr), ntohs(client.sin_port),
        request.msg);

    strcpy(user->name, request.name);
    user->team = request.team;
    new_fd = udp_connect(epollfd, &client);
    user->fd = new_fd;
    return new_fd;
}


int find_sub(struct User *team) {//找到不在线的空
    for(int i = 0; i< MAX; i++) {
        if(!team[i].online) return i;
    }
    return -1;
}

void add_to_sub_reactor(struct User *user) {
    struct User *team = (user->team ? bteam : rteam);
    DBG(YELLOW"Main Thread : "NONE"Add to sub_reactor.\n");
    int sub = find_sub(team);
    team[sub] = *user;//数组中存放的结构体user
    team[sub].online = 1;
    team[sub].flag = 10;
    DBG(L_RED"sub = %d, name = %s\n"NONE, sub, team[sub].name);
    if(user->team)
        add_event_ptr(bepollfd, team[sub].fd, EPOLLIN | EPOLLET, &team[sub]);
    else
        add_event_ptr(repollfd, team[sub].fd, EPOLLIN | EPOLLET, &team[sub]);

    return;
}
```



## 共用接口

#### `show_data_stream`

> 显示收到的数据类型

⽂件：`show_data_stream.h` 、` show_data_stream.c`



```cpp
char data_stream[20];
void show_data_stream(char type);

extern char data_stream[20];
extern WINDOW *Help;
extern struct Map court;
//type 'l'(login) 'c'(carry) 'k'(kick) 's'(stop) 'n'normal 'e'(exit)
//data_stream数组后移一位，将type加到第一位
//根据type不同，使用wattron设置Help窗口的领色
//在合适位置打印一个空格
void show_data_stream(char type) {
    for(int i = 18; i > 1; i--) {
        data_stream[i] = data_stream[i - 1];
    }
    data_stream[1] = type;
    for(int i = 1; i < 19; i++) {
        switch(data_stream[i]) {
            case 'l': {
                wattron(Help, COLOR_PAIR(7));
            }break;
            case 'c': {
                wattron(Help, COLOR_PAIR(8));
            }break;
            case 'k': {
                wattron(Help, COLOR_PAIR(9));
            }break;
            case 's': {
                wattron(Help, COLOR_PAIR(10));
            }break;
            case 'n': {
                wattron(Help, COLOR_PAIR(11));
            }break;
            case 'e': {
                wattron(Help, COLOR_PAIR(12));
            }break;
        }
        mvwprintw(Help, court.height, i, " ");
        wrefresh(Help);
    }
    return;
}


```

![image.MBVXA1](/Image/A2.udp-football-photo/image.MBVXA1.png)

#### server_exit

> 服务端收到 `ctrl + c` 信号后的退出函数数

⽂件: `server_exit.c` 、 `server_exit.h`

```cpp
#define MAX 50
extern struct User *rteam, *bteam;

extern struct Bpoint ball;
extern struct Score score;

void server_exit(int signum) {
    struct FootBallMsg msg;
    msg.type = FT_FIN;
    for(int i = 0; i < MAX; i++) {
        if(rteam[i].online) send(rteam[i].fd, (void *)&msg, sizeof(msg), 0);
        if(bteam[i].online) send(bteam[i].fd, (void *)&msg, sizeof(msg), 0);
    }
    endwin();
    DBG(RED"Server stopped!\n"NONE);
    exit(0);
}

```

#### `server_send`

> 向所有在线的player发送⼀条消息

⽂件：`server_exit.c` 、 `server_exit.h`

```cpp
void server_send() {
	struct FootBallMsg msg;
	msg.type = FT_GAME;
	for (int i = 0; i < MAX; i++) {//发送给所有在线的客户
		if (rteam[i].online) {
			strcpy(msg.msg, cJSON_Print(game_msg()));
			send(rteam[i].fd, (void *)&msg, sizeof(msg), 0);
		}
		if (bteam[i].online) {
			strcpy(msg.msg, cJSON_Print(game_msg()));
			send(bteam[i].fd, (void *)&msg, sizeof(msg), 0);
		}
	}
}
```

#### `thread_pool`

> 从反应堆线程池处理IO事件

⽂件: `thread_pool.c` 、 `thread_poll.h`

##### thread_poll.h

```cpp
#define MAXTASK 100 //最多任务
#define MAXTHREAD 10 //放10个线程
struct task_queue{
    int sum;//多少个
    int epollfd;//对应的从反应堆
    struct User **team;//队
    int head;
    int tail;
    pthread_mutex_t mutex;//互斥锁
    pthread_cond_t cond;
};

void task_queue_init(struct task_queue *taskQueue, int sum, int epollfd);//初始化
void task_queue_push(struct task_queue *taskQueue, struct User *user);//入队
struct User *task_queue_pop(struct task_queue *taskQueue);//弹出一个用户
void *thread_run(void *arg);//做什么用的，回调函数

```



##### thread_poll.c

```cpp

extern int repollfd, bepollfd;
extern struct Bpoint ball;
extern struct BallStatus ball_status;
void do_echo(struct User *user) {
    struct FootBallMsg msg;
    char tmp[512] = {0};
    int size = recv(user->fd, (void *)&msg, sizeof(msg), 0);
    user->flag = 10;
    if(msg.type & FT_ACK) {
        show_data_stream('l');
        if(user->team)//blue_team
            DBG(L_BLUE" %s "NONE"❤\n", user->name);
        else //red_team
            DBG(L_RED" %s "NONE"❤\n", user->name);
    } else if(msg.type & (FT_WALL | FT_MSG)) {
        if(user->team)
            DBG(L_BLUE" %s :"NONE L_RED"%s\n"NONE, user->name, msg.msg);
        else
            DBG(L_RED" %s :"NONE L_RED"%s\n"NONE, user->name, msg.msg);
        strcpy(msg.name, user->name);
        msg.team = user->team;
        Show_Message(, user, msg.msg, );
        send(user->fd, (void *)&msg, sizeof(msg), 0);//把信息回过去
    } else if(msg.type & FT_FIN) {
        show_data_stream('e');
        DBG(RED"%s logout.\n", user->name);
        sprintf(tmp, "%s logout.", user->name);
        Show_Message(, NULL, tmp, 1);
        user->online = 0;
        int epollfd_tmp = (user->team ? bepollfd : repollfd);
        del_event(epollfd_tmp, user->fd);
    } else if(msg.type & FT_CTL) {
        show_data_stream('n');
        Show_Message(, user, "Ctl Message", 0);
        if(msg.ctl.dirx || msg.ctl.diry) {
            user->loc.x += msg.ctl.dirx;
            user->loc.y += msg.ctl.diry;
            if(user->loc.x <= 1) user->loc.x = 1;
            if(user->loc.x >= court.width - 1) user->loc.x = court.width - 1;
            if(user->loc.y <= 1) user->loc.y = 1;
            if(user->loc.y >= court.height -1) user->loc.y = court.height - 1;
        }
        if(msg.ctl.action & ACTION_KICK) {
            show_data_stream('k');
            ball_status.carry = 0;
            if(can_kick(&user->loc, msg.ctl.strength)) {
                ball_status.who = user->team;
                strcpy(ball_status.name, user->name);
            }
        }
        if(msg.ctl.action & ACTION_STOP) {
            show_data_stream('j') ;
            ball_status.carry = 0;
            if(ball_stop(&user->loc)) {
            ball_status.who = user->team;
            strcpy(ball_status.name, user->name);
            }
        }
        if(msg.ctl.action & ACTION_CARRY) {
            show_data_stream('l');
            ball_status.carry = 1;
            user->carry = 1;
            ball_status.who = user->team;
            strcpy(ball_status.name, user->name);
        }
    }
}

//初始化
void task_queue_init(struct task_queue *taskQueue, int sum, int epollfd){
    taskQueue->sum = sum;
    taskQueue->epollfd = epollfd;
    taskQueue->team = calloc(sum, sizeof(void *));//申请内存sum个
    taskQueue->head = taskQueue->tail = 0;
    pthread_mutex_init(&taskQueue->mutex, NULL);//互斥锁初始化
    pthread_cond_init(&taskQueue->cond, NULL);//条件变量初始化
    return;
}

//push
//把用户user放到队列中
void task_queue_push(struct task_queue *taskQueue, struct User *user) {
    pthread_mutex_lock(&taskQueue->mutex);//先加锁
    taskQueue->team[taskQueue->tail] = user;
    DBG(L_GREEN"Thread poll :"NONE" Task Push %s\n", user->name);//谁入队
    if(++taskQueue->tail == taskQueue->sum) {//满了
        DBG(L_GREEN"Thread poll : "NONE"Task Queue End.\n");
        taskQueue->tail = 0;
    }
    pthread_cond_signal(&taskQueue->cond);//解锁前发个信号
    pthread_mutex_unlock(&taskQueue->mutex);//解锁
    return;
}

//Pop
struct User *task_queue_pop(struct task_queue *taskQueue) {
    pthread_mutex_lock(&taskQueue->mutex);//先加锁
    while(taskQueue->tail == taskQueue->head) {//是否为空
        DBG(L_GREEN"Thread poll : "NONE
            "Task Queue Empty, Waiting For Task.\n");
        pthread_cond_wait(&taskQueue->cond, &taskQueue->mutex);//等信号
    }
    struct User *user = taskQueue->team[taskQueue->head];//拿出头

    DBG(L_GREEN"Thread poll : "NONE"Task Pop %s.\n", user->name);

    if(++taskQueue->head == taskQueue->sum) {//++删掉头//为空的时候
        DBG(L_GREEN"Thread poll : "NONE"Task Queue End.\n");
        taskQueue->head = 0;
    }
    pthread_mutex_unlock(&taskQueue->mutex);//关闭锁
    return user;
}

//分离线程
//死循环弹出队列元
///调用do_echo处理I0，传入参数为队列弹出的
void *thread_run(void *arg) {
    pthread_t tid = pthread_self();
    pthread_detach(tid);
    struct task_queue *taskQueue = (struct task_queue *)arg;
    while(1) {
        struct User *user = task_queue_pop(taskQueue);//去除user
        do_echo(user);//操作
    }
    return NULL;
}
```



#### `heart_beat`

> 服务端通过⼼跳机制判断客户端是否在线，单独线程执⾏

⽂件：`heart_beat.c`、 `heart_beat.h`

```cpp
#define MAX 50
extern struct User *rteam, *bteam;
extern int bepollfd, repollfd;

//遍历team数组，判在线，则发送FT_TEST心跳包，flag--
//判断palyer的f1ag是否为减为0，为0则判断为下线
//数组中标记为online = 0
//在从反应堆中注销IO

void heart_beat_team(struct User *team) {
    struct FootBallMsg msg;
    msg.type = FT_TEST;
    for(int i = 0; i < MAX; i++) {
        if(team[i].online) {
            if(!team[i].flag) {
                team[i].online = 0;
                continue;
            }
            send(team[i].fd, (void *)&msg, sizeof(msg), 0);
            team[i].flag --;
            if(team[i].flag <= 0) {
                char tmp[512] = {0};
                sprintf(tmp, "%s is remove from list.", team[i].name);
                Show_Message(, NULL, tmp, 1);
                team[i].online = 0;
                int epollfd_tmp = (team[i].team ? bepollfd : repollfd);
                del_event(epollfd_tmp, team[i].fd);
            }
        }
    }
    return;
}

//死循环，固定时间调用
void *heart_beat(void *arg) {
    while(1) {
        sleep(10);
        heart_beat_team(bteam);
        heart_beat_team(rteam);
    }
    return NULL;
}
```



#### `can_kick`

> 判断player是否可以踢球，若成功，则更新球的运⾏⽅向，加速度， 速度

⽂件： `ball_status.c`、 `ball_status.h`

```cpp
extern WINDOW *Message;
extern struct Bpoint ball;
extern struct BallStatus ball_status;
//palyer和ball坐标对此
//判断palyer和ball的坐标在上下左右2个单位距离内，则可跟球
//橱据player和ball的相对位置，计算球的运动方向，加速度方向，假设球只能在palyer和ball的延长线上运动
//假设player跟球的接触时间为.2秒，默认加速度为40，力度增加，加速度也增加
//可踢球返回1，否则返回
int can_kick(struct Point *loc, int strength) {
    int px = loc->x, py = loc->y; //将人和球的坐标对其
    if (abs(px - (int)ball.x) <= 2 && abs(py - (int)ball.y <= 2)) {
        if (px == (int)ball.x && py == (int)ball.y) return 0;
        double dx = (ball.x - px) / pow(pow((ball.x - px), 2) + pow((ball.y - py), 2), 0.5);
        double dy = (ball.y - py) / pow(pow((ball.x - px), 2) + pow((ball.y - py), 2), 0.5);
        ball_status.a.x = -3 * dx; //a of air resistans
        ball_status.a.y = -3 * dy;
        ball_status.v.x = strength * 8 * dx;
        ball_status.v.y = strength * 8 * dy;
        char tmp[512] = {0};
        sprintf(tmp, "a(%lf, %lf) v(%lf, %lf)", ball_status.a.x, ball_status.a.y, ball_status.v.x, ball_status.v.y);
        Show_Message(Message, NULL, tmp, 1);
        return 1;
    }
    return 0;
}

```

#### `ball_stop`

> 让球停止

⽂件： `ball_stop.c`、 `ball_stop.h`

```cpp
extern WINDOW *Message;
extern struct Bpoint ball;
extern struct BallStatus ball_status;

int ball_stop(struct Point *loc) {
	int px = loc->x;
	int py = loc->y;
	if (abs(px - (int)ball.x) <= 2 && abs(py - (int)ball.y) <= 2) {
		ball_status.a.x = 0;
		ball_status.a.y = 0;
		ball_status.v.x = 0;
		ball_status.v.y = 0;
        return 1;
    }
    return 0;
}
```



#### `gameui`

##### `game.h`

```cpp
#define DEFARG(name, default_value) ((#name[0]) ? (name + 0) : default_value)
#define Show_Message(arg0, arg1, arg2, arg3) show_message(DEFARG(arg0, Message),DEFARG(arg1, NULL), arg2, DEFARG(arg3, 0))

#define MAX 50

struct Map court;/*球场*/


WINDOW *Football, *Message, *Help, *Score, *Write, *Football_t;
WINDOW *create_newwin(int width, int height, int startx, int starty);/*创建一个窗口*/

void destroy_win(WINDOW *win);//销毁一个窗口
void gotoxy(int x, int y);//移动打印光标
void gotoxy_putc(int x, int y, char c);//打印字符
void gotoxy_puts(int x, int y, char *s);//打印字符串
void w_gotoxy_putc(WINDOW *win, int x, int y, char c);//在窗口上打印字符
void w_gotoxy_puts(WINDOW *win, int x, int y, char *s);//在窗口上打印字符串
void initfootball();//初始化整个足球场
void init_help();//初始化帮助信息
void *draw(void *arg);//绘制图

void show_message(WINDOW *win, struct User *user, char *msg, int type);//展示消息
```



##### `game.c`

```cpp
extern struct Map court;
extern WINDOW *Football, *Message, *Help, *Score, *Write, *Football_t;
int message_num = 0;
WINDOW *create_newwin(int width, int height, int startx, int starty) {
    //Create WINDOW
    WINDOW *win;
    win = newwin(height, width, starty, startx);
    box(win, 0, 0);/*0 0是字符默认行列起始位置*/
    wrefresh(win);/*刷新窗口缓冲，显示box*/
    return win;//创建了一个窗口对象
}

void destroy_win(WINDOW *win) {//销毁窗口
    //Destroy WINDOW

    //delete line
    wborder(win, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ');//删掉线
    wrefresh(win);
    delwin(win);
}


void gotoxy(int x, int y) {
    move(y , x);
}

void gotoxy_putc(int x, int y,char c) {
    move(y, x);
    addch(x);
    move(LINES - 1, 1);
    refresh();
}
void gotoxy_puts(int x, int y,char *c) {
    move(y, x);
    addstr(c);
    move(LINES - 1, 1);
    refresh();
}

void w_gotoxy_putc(WINDOW *win, int x, int y, char c) {
    mvwaddch(win, y, x, c);
    move(LINES - 1, 1);
    wrefresh(win);
}

void w_gotoxy_puts(WINDOW *win, int x, int y, char *s) {
    mvwprintw(win, y, x, s);
    move(LINES - 1, 1);
    wrefresh(win);
}

void initfootball() {//初始化足球场
    initscr();
    clear();
    if(!has_colors() || start_color() == ERR) {
        endwin();
        fprintf(stderr, "终端不支持颜色！\n");
    }
    init_pair(1, COLOR_GREEN, COLOR_BLACK);
    init_pair(2, COLOR_RED, COLOR_BLACK);
    init_pair(3, COLOR_WHITE, COLOR_BLACK);    
    init_pair(4, COLOR_YELLOW, COLOR_BLACK);
    init_pair(5, COLOR_CYAN, COLOR_BLACK);    
    init_pair(6, COLOR_BLUE, COLOR_BLACK);
    init_pair(7, COLOR_BLUE, COLOR_GREEN);
    init_pair(8, COLOR_BLUE, COLOR_RED);
    init_pair(9, COLOR_BLUE, COLOR_WHITE);
    init_pair(10, COLOR_BLUE, COLOR_YELLOW);
    init_pair(11, COLOR_BLUE, COLOR_CYAN);
    init_pair(12, COLOR_BLUE, COLOR_BLUE);

    Football_t=create_newwin(court.width + 4, court.height + 2, court.start.x - 2, court.start.y - 1);
    Football = subwin(Football_t, court.height, court.width, court.start.y, court.start.x);
    box(Football, 0, 0);
    WINDOW *Message_t=create_newwin(court.width + 4, 7, court.start.x - 2, court.start.y + 1 + court.height);
    Message = subwin(Message_t, 5, court.width + 2, court.start.y + court.height + 2, court.start.x - 1);
    scrollok(Message, 1);
    Help=create_newwin(20, court.height + 2, court.start.x + court.width + 2, court.start.y - 1);
    Score=create_newwin(20,  7, court.start.x + court.width + 2, court.start.y + 2 + court.height - 1);
    Write=create_newwin(court.width + 24, 5, court.start.x - 2, court.start.y + 1 + court.height + 7);
}
void init_help() {
    w_gotoxy_puts(Help, 1, 1, "[wasd]:\n| control direction");
    w_gotoxy_puts(Help, 1, 4, "[ j ]:\n| stop ball");
    w_gotoxy_puts(Help, 1, 7, "[ k ]:\n| kick ball");
    w_gotoxy_puts(Help, 1, 10, "[ l ]:\n| carry ball");
    w_gotoxy_puts(Help, 1, 13, "[space]:\n| choose strength");
    w_gotoxy_puts(Help, 1, 16,"[enter]:\n| send msg");
}


void *draw(void *arg) {
    initfootball();
    init_help();
    while(1) {
        sleep(10);
    }
}


/*在哪个窗口显示信息*/
/*user谁*/
/*msg信息*/
void show_message(WINDOW *win, struct User *user, char *msg, int type) {
    //时间
    time_t time_now = time(NULL);
    struct tm* tm= localtime(&time_now);
    char timestr[20] = {0};
    char username[80] = {0};
    sprintf(timestr, "%02d:%02d:%02d ", tm->tm_hour, tm->tm_min, tm->tm_sec);
    
    if (type) {
        //系统信息
        wattron(win, COLOR_PAIR(4));
        strcpy(username, "Server Info : ");
    } else {
        if(user->team) 
            wattron(win, COLOR_PAIR(6));
        else 
            wattron(win, COLOR_PAIR(2));
        sprintf(username, "%s : ", user->name);
    }
    //打印信息
    if(message_num < 4) {
        w_gotoxy_puts(win, 10, message_num, username);
        wattron(win, COLOR_PAIR(3));
        w_gotoxy_puts(win, 10 + strlen(username), message_num, msg);
        wattron(win, COLOR_PAIR(5));
        w_gotoxy_puts(win, 1, message_num, timestr);
        message_num++;
    } else {
        message_num = 4;
        scroll(win);//滚动
        w_gotoxy_puts(win, 10, message_num, username);
        wattron(win, COLOR_PAIR(3));
        w_gotoxy_puts(win, 10 + strlen(username), message_num, msg);
        wattron(win, COLOR_PAIR(5));
        w_gotoxy_puts(win, 1, message_num, timestr);
        message_num++;
    }

    wrefresh(win);
}

```





#### `server_re_drew`

> 服务端游戏刷新，定时执行，每次执⾏时，判断球的状态，沿着什么⽅向移动多远动，人应该移动到什么位置

⽂件：`server_re_drew.c `、`server_re_drew.h`

```cpp
void re_drew_player(int team, char *name, struct Point *loc);
void re_drew_team(struct User *team);
void re_draw_ball();
void init_score();
void re_drew();
#define MAX 50
extern struct User *rteam, *bteam;
extern WINDOW *Football;

extern struct Bpoint ball;
extern struct BallStatus ball_status;
extern struct Score score;

void re_drew_player(int team, char *name, struct Point *loc) {
    char p = 'K';
    if(team) {
        wattron(Football, COLOR_PAIR(6));
    } else {
        wattron(Football, COLOR_PAIR(2));
    }
    w_gotoxy_putc(Football, loc->x, loc->y, p);
    w_gotoxy_puts(Football, loc->x + 1, loc->y - 1, name);
}

void re_drew_team(struct User *team) {
    for(int i = 0; i < MAX; i++) {
        if(!team[i].online)continue;
        re_drew_player(team[i].team, team[i].name, &team[i].loc);
    }
}

void re_draw_ball() {
    int px, py;
    if(ball_status.carry == 0) {
    double t = 0.1;
    if((int)ball_status.v.x != 0 ||(int)ball_status.v.y != 0 ) {
        ball.x += ball_status.v.x * t + ball_status.a.x * 0.5 * 0.01;
        ball.y += ball_status.v.y * t + ball_status.a.y * 0.5 * 0.01;
        ball_status.v.x += ball_status.a.x * t;
        ball_status.v.y += ball_status.a.y * t;
    }
    if (ball_status.v.x || ball_status.v.y) {
		char tmp[512] = {0};
		sprintf(tmp, "a(%lf, %lf) v(%lf, %lf)", ball_status.a.x, ball_status.a.y, ball_status.v.x, ball_status.v.y);
		Show_Message( , NULL, tmp, 1);
	}
	if (ball.x <= 0 || ball.x >= 114 || ball.y <= 0 || ball.y >= 24) {
        if((int)ball.y >= court.height / 2 - 4 && (int)ball.y <= court.height / 2 + 4 && ball.x <= 1) {
            score.blue ++;
        }
        if((int)ball.y >= court.height / 2 - 4 && (int)ball.y <= court.height / 2 + 4 && ball.x >= 114) {
            score.red ++;
        }
		ball.x = court.width / 2;
		ball.y = court.height / 2;
		ball_status.v.x = ball_status.v.y = 0;
		ball_status.a.x = ball_status.a.y = 0;
	}
    } else if(ball_status.carry == 1) {
        int dir[8][2] = {1, 0, -1, 0,
                        1, 1, 1, -1,
                        0, 1, 0, -1,
                        -1, 1, -1, -1};
        for(int i = 0; i < MAX; i++) {
            if(rteam[i].carry == 1) {
                px = rteam[i].loc.x;
                py = rteam[i].loc.y;
            }
            if(bteam[i].carry == 1) {
                px = bteam[i].loc.x;
                py = bteam[i].loc.y;
            }
        }
        if (abs(px - (int)ball.x) <= 3 && abs(py - (int)ball.y <= 3)) {
		    ball_status.v.x = ball_status.v.y = 0;
		    ball_status.a.x = ball_status.a.y = 0;
            ball.x = px + dir[rand() % 8][rand() % 2];
            ball.y = py + dir[rand() % 8][rand() % 2];
        }
    }
    w_gotoxy_putc(Football, (int)ball.x, (int)ball.y, 'O');
}

void ball_door(){
    for(int i = court.height / 2 - 4; i <= court.height / 2 + 4; i++){
        w_gotoxy_putc(Football_t, 1, i, 'x');
        w_gotoxy_putc(Football_t, 117, i, 'x');
    }
}

void init_score() {
    w_gotoxy_puts(Score, 1, 1, "red blue\n");
    char tmp[50];
    sprintf(tmp, "%d:%d", score.red, score.blue);
    w_gotoxy_puts(Score, 1, 2, tmp);
}


void re_drew() {
    werase(Football);
    box(Football_t, 0, 0);
    box(Football, 0, 0);
    re_drew_team(rteam);
    re_drew_team(bteam);
    ball_door();
    init_score();
    re_draw_ball();
    server_send();//每次绘制一下图，就发送json打包发送客户端
    wrefresh(Football);
    wrefresh(Football_t);
}
```

#### `clientt_re_drew`

> 客户端游戏刷新，定时执行，每次执⾏时，判断球的状态，沿着什么⽅向移动多远动，人应该移动到什么位置

⽂件：`client_re_drew.c `、`client_re_drew.h`

```cpp
void re_drew_player(cJSON *users);
void re_drew_ball(cJSON *c_ball);
void re_drew_score(cJSON *c_score);
void ball_door();
void re_drew(cJSON *root);
#define MAX 50
extern WINDOW *Football, *Football_t, *Score;
extern struct Bpoint ball;
extern struct Score score;

void re_drew_player(cJSON *users) {
    int user_cnt = cJSON_GetArraySize(users);
	for (int i = 0; i < user_cnt; i++) {
		cJSON *user = cJSON_GetArrayItem(users, i);
		int team = cJSON_GetObjectItem(user, "team")->valueint;
		int locx = cJSON_GetObjectItem(user, "locx")->valueint;
		int locy = cJSON_GetObjectItem(user, "locy")->valueint;
		char p = 'K';
        if(team) {
            wattron(Football, COLOR_PAIR(6));
        } else {
            wattron(Football, COLOR_PAIR(2));
        }
        w_gotoxy_putc(Football, locx, locy, p);
        w_gotoxy_puts(Football, locx + 1, locy - 1, cJSON_GetObjectItem(user, "name")->valuestring);
    }
}

void re_drew_ball(cJSON *c_ball) {
	int ballx = cJSON_GetObjectItem(c_ball, "x")->valueint;
	int bally = cJSON_GetObjectItem(c_ball, "y")->valueint;
	w_gotoxy_putc(Football, ballx, bally, 'o');
}

void re_drew_score(cJSON *c_score) {

    score.blue = cJSON_GetObjectItem(c_score, "bscore")->valueint;
	score.red = cJSON_GetObjectItem(c_score, "rscore")->valueint;
    
    w_gotoxy_puts(Score, 1, 1, "red blue\n");
    char tmp[50];
    sprintf(tmp, "%d:%d", score.red, score.blue);
    w_gotoxy_puts(Score, 1, 2, tmp);
}

void ball_door(){
    for(int i = court.height / 2 - 4; i <= court.height / 2 + 4; i++){
        w_gotoxy_putc(Football_t, 1, i, 'x');
        w_gotoxy_putc(Football_t, 117, i, 'x');
    }
}

void re_drew(cJSON *root) {
	cJSON *users = cJSON_GetObjectItem(root, "users");
	cJSON *c_ball = cJSON_GetObjectItem(root, "ball");
	cJSON *c_score = cJSON_GetObjectItem(root, "score");

    werase(Football);
    box(Football_t, 0, 0);
    box(Football, 0, 0);
    re_drew_player(users);
    re_drew_ball(c_ball);
    re_drew_score(c_score);
    ball_door();
    wrefresh(Football);
    wrefresh(Football_t);
}
```





## 客户端接口

#### `client_recv`

接收来则服务端的信息，并进行处理

⽂件：`client_recv.h`、`client_recv.c`

```cpp
void *client_recv(void *arg) {
    while(1) {
        struct FootBallMsg msg;
        bzero(&msg, sizeof(msg));
        recv(sockfd, (void *)&msg, sizeof(msg), 0);
        if(msg.type & FT_TEST) {
            DBG(RED"HeartBeat from Server 心\n"NONE);
            msg.type = FT_ACK;
            send(sockfd, (void *)&msg, sizeof(msg), 0);
        } else if(msg.type & (FT_MSG | FT_WALL)) {
            DBG(GREEN"Server Msg : "NONE"%s\n", msg.msg);
        } else if(msg.type & FT_FIN){
            DBG(GREEN"Server is going to stop.\n"NONE);
            endwin();
            exit(0);
        } else if (msg.type & FT_GAME) {//服务端向客户端广播的json实时地图
			DBG(YELLOW"JSON:"NONE"%s", msg.msg);
			cJSON *root = cJSON_Parse(msg.msg);
			re_drew(root);
		} else {
            DBG(GREEN"Msg Unsupport\n"NONE);
            exit(0);
        }
        
    }
}
/*
{
	"name":	"test",
	"ball":	{
		"x":	57,
		"y":	12
	},
	"score":	{
		"bscore":	0,
		"rscore":	0
	},
	"users":	[{
			"team":	0,
			"name":	"ZFB",
			"locx":	2,
			"locy":	12
		}]
}
*/

```





#### `show_strength`

> 显示踢球时的⼒度，并通过控制按键时机达到控制踢球⼒度的效果

⽂件:` show_strength.c `、`show_strength.h`

```cpp
extern WINDOW *Write;
extern int sockfd;

//在Write窗口中，显示踢球力度条，光标在进度条上快速移动
//设置为0非阻塞IO
//whille 等待`空格`或者`K`键的按下，如果按下退出，取得当前的strength。
//通过sockfd向服务端发送控制信息，跟球

#include "head.h"
extern WINDOW *Write;
extern int sockfd;

void show_strength() {
    int mousex = 2, offset = 1;
    int maxx, maxy, strength;
    getmaxyx(Write, maxy, maxx);
    for(int i = 2; i < maxx - 2; i++) {
        if(i < maxx / 5 || i > maxx - maxx / 5) {
            wattron(Write, COLOR_PAIR(9));
        } else if(i < (maxx / 5) * 2 || i > (maxx / 5) * 3) {
            wattron(Write, COLOR_PAIR(12));
        } else {
            wattron(Write, COLOR_PAIR(8));
        }
        mvwprintw(Write, 2, i, " ");
    }
    wattron(Write, COLOR_PAIR(3));
    make_nonblock(0);
    while(1) {
        char c = getchar();
        if(c != -1) {
            if(c == ' ' || c == 'k') {
                make_block(0);
                break;
            }
        }
        usleep(20000);
        if(mousex >= maxx - 2) {
            offset = -1;
        } else if(mousex <= 2) {
            offset = 1;
        }
        mvwprintw(Write, 3, mousex, " ");
        mvwprintw(Write, 1, mousex, " ");
        mousex += offset;
        mvwprintw(Write, 3, mousex, "|");
        mvwprintw(Write, 1, mousex, "|");
        mvwprintw(Write, 4, maxx, " ");
        wrefresh(Write);
    }
    int arr[5] = {1, 2, 3, 2, 1};
    struct FootBallMsg msg;
    bzero(&msg, sizeof(msg));
    msg.type = FT_CTL;
    msg.ctl.action = ACTION_KICK;
    msg.ctl.strength = arr[mousex / (maxx / 5)];
    send(sockfd, &msg, sizeof(msg), 0);
    return;
}
```



![image.5SC3A1](/Image/A2.udp-football-photo/image.5SC3A1.png)





#### `send_chat`

> ⽤户输⼊聊天信息，并发送给服务端

⽂件：`send_chat.c` 、`send_chat.h`

```cpp
extern int sockfd;
extern WINDOW *Write;
extern struct FootBallMsg chat_msg;
//打开echo回显
//打开行缓冲
//在Wr1te窗口中输入数据并读入
//判断读入信息非空，发送
//重绘Writ
//关闭echo
//关闭行缓冲
void send_chat() {
    echo();
    nocbreak();
    bzero(&chat_msg.msg, sizeof(chat_msg.msg));
    w_gotoxy_puts(Write, 1, 1, "Input Message:");
    mvwscanw(Write, 2, 1, "%[^\n]s", chat_msg.msg);
    if (strlen(chat_msg.msg)) {
        send(sockfd, (void *)&chat_msg, sizeof(chat_msg), 0);
    }
    werase(Write);
    box(Write, 0, 0);
    wrefresh(Write);
    noecho();
    cbreak();
    return;
}
```

![image.SW30A1](/Image/A2.udp-football-photo/image.SW30A1.png)

#### `send_ctl`

> 客户端发送控制信息到服务端

⽂件：`send_ctl.c` 、 `send_ctl.h`

```cpp
extern int sockfd;
extern struct FootBallMsg ctl_msg;

void send_ctl() {
    if (ctl_msg.ctl.dirx || ctl_msg.ctl.diry) {
        send(sockfd, (void *)&ctl_msg, sizeof(ctl_msg), 0 );
    }
    ctl_msg.ctl.dirx = ctl_msg.ctl.diry = 0;
}
```



## 主程序

### client

```cpp
#include "../common/head.h"
#include "../common/udp_client.h"
#include "../common/client_recver.h"
#include "../common/game.h"
#include "../common/send_chat.h"
#include "../common/send_ctl.h"
char server_ip[20] = {0};
int server_port = 0;
char *conf = "./football.conf";
struct FootBallMsg chat_msg;
struct FootBallMsg ctl_msg;
struct Score score;
int sockfd;

void ball_send_stop() {
    struct FootBallMsg msg;
    bzero(&msg, sizeof(msg));
    msg.type = FT_CTL;
    msg.ctl.action = ACTION_STOP;
    send(sockfd, &msg, sizeof(msg), 0);
}

void logout(int signum) {
    struct FootBallMsg msg;
    msg.type = FT_FIN;
    send(sockfd, (void *)&msg, sizeof(msg), 0);
    endwin();
    exit(1);
}

int main(int argc, char **argv) {
    int opt;
    pthread_t recv_t, draw_t;
    struct LogRequest request;
    struct LogResponse response;
    bzero(&request, sizeof(request));

    bzero(&chat_msg, sizeof(chat_msg));
    bzero(&ctl_msg, sizeof(ctl_msg));

    chat_msg.type = FT_MSG;
    ctl_msg.type = FT_CTL;

    while ((opt = getopt(argc, argv, "h:p:n:t:m:")) != -1) {
        switch (opt) {
            case 'h': {
                strcpy(server_ip, optarg);
            } break;
            case 'p': {
                server_port = atoi(optarg);
            } break;
            case 'n': {
                strcpy(request.name, optarg);
            } break;
            case 't': {
                request.team = atoi(optarg);
            } break;
            case 'm': {
                strcpy(request.msg, optarg);
            } break;
            default: {
                fprintf(stderr, "Usage : %s [-h host] [-p port]\n", argv[0]);
                exit(1);
            }
        }
    }

    argc -= (optind - 1);
    argv += (optind - 1);

    if (argc > 1) {
        fprintf(stderr, "Usage : %s [-h host] [-p port]\n", argv[0]);
        exit(1);
    }

    if (!server_port) server_port = atoi(get_value(conf, "SERVERPORT"));
    if (!strlen(server_ip)) strcpy(server_ip, get_value(conf, "SERVERIP"));
    if (!strlen(request.name)) strcpy(request.name, get_value(conf, "NAME"));
    if (!strlen(request.msg)) strcpy(request.msg, get_value(conf, "LOGMSG"));
    if (!request.team) request.team = atoi(get_value(conf, "TEAM"));

    court.width = atoi(get_value(conf, "COLS"));
    court.height = atoi(get_value(conf, "LINES"));
    court.start.x = 3;
    court.start.y = 1;


    signal(SIGINT, logout);
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(server_port);
    server.sin_addr.s_addr = inet_addr(server_ip);

    socklen_t len = sizeof(server);

DBG(GREEN "INFO" NONE
              " : server_ip = %s, server_port = %d, name = %s, team = %s, "
              "logmsg = %s\n",
        server_ip, server_port, request.name, (request.team ? "BLUE" : "RED"),
        request.msg);

    if ((sockfd = socket_udp()) < 0) {
        perror("socket_udp");
        exit(1);
    }

    sendto(sockfd, (void *)&request, sizeof(request), 0,
           (struct sockaddr *)&server, len);

    fd_set set;
    FD_ZERO(&set);
    FD_SET(sockfd, &set);
    struct timeval tv;
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    int retval = select(sockfd + 1, &set, NULL, NULL, &tv);
    if (retval == -1) {
        perror("select");
        exit(1);
    } else if (retval) {
        int ret = recvfrom(sockfd, (void *)&response, sizeof(response), 0,
                           (struct sockaddr *)&server, &len);
        if (ret != sizeof(response) || response.type) {
            DBG(RED
                "ERROR : " NONE
                "The Game Server refused your login request!\n\t This may be "
                "helpful: %s\n",
                response.msg);
            exit(1);
        }
    } else {
        DBG(RED "ERROR : " NONE "The Game Server is offline.\n");
        exit(1);
    }

    DBG(GREEN "SERVER : " NONE " %s \n", response.msg);
    connect(sockfd, (struct sockaddr *)&server, len);
#ifndef _D
    pthread_create(&draw_t, NULL, draw, NULL);
#endif
    pthread_create(&recv_t, NULL, client_recv, NULL);

    signal(14, send_ctl);
    struct itimerval itimer;
    itimer.it_interval.tv_sec = 0;
    itimer.it_interval.tv_usec = 100000;
    itimer.it_value.tv_sec = 0;
    itimer.it_value.tv_usec = 100000;

    setitimer(ITIMER_REAL, &itimer, NULL);


    noecho();
    cbreak();
    keypad(stdscr, TRUE);
    while (1) {
        int c = getchar();
        switch (c) {
            case 'a': {
                ctl_msg.ctl.dirx -= 1;
            } break;
            case 'd': {
                ctl_msg.ctl.dirx += 1;
            } break;
            case 'w': {
                ctl_msg.ctl.diry -= 1;
            } break;
            case 's': {
                ctl_msg.ctl.diry += 1;
            } break;
            case 13: {
                send_chat();
            } break;
            case ' ': {
                show_strength();
            } break;
            case 'j':{
                ball_send_stop();
            } break;
            case 'l':{
                struct FootBallMsg msg;
                bzero(&msg, sizeof(msg));
                msg.type = FT_CTL;
                msg.ctl.action = ACTION_CARRY;
                send(sockfd, &msg, sizeof(msg), 0);
            }break;
            default:
                break;
        }
    }

    sleep(10);

    return 0;
}
```



#### football.conf

```cpp
SERVERIP=39.97.167.241
SERVERPORT=8888
NAME=yzw
LOGMSG="Hi, Let's Play!"
TEAM=1
LINES=25
COLS=115
```



### server

```cpp
char *conf = "./server.conf";

struct User *rteam;/*红队*/
struct User *bteam;/*蓝队*/
int data_port;/*数据端口*/
int port = 0;
int repollfd, bepollfd;

// struct Map court;
struct Bpoint ball;/*球*/
struct BallStatus ball_status;/*球的状态*/
struct Score score;/*比分*/
int main(int argc, char **argv) {
    int opt, listener, epoll_fd;
    pthread_t draw_t, red_t, blue_t, heart_t;
    while ((opt = getopt(argc, argv, "p:")) != -1) {
        switch (opt) {
            case 'p':
                port = atoi(optarg);
                break;
            default:
                fprintf(stderr, "Usage: %s [-p port]\n", argv[0]);
                exit(1);
        }
    }
    argc -= (optind - 1);
    argv += (optind - 1);

    if (argc > 1) {
        fprintf(stderr, "Usage: %s [-p port]\n", argv[0]);
        exit(1);
    }

    if (!port) port = atoi(get_value(conf, "PORT"));
    data_port = atoi(get_value(conf, "DATAPORT"));

    court.width = atoi(get_value(conf, "COLS"));
    court.height = atoi(get_value(conf, "LINES"));
    court.start.x = 3;
    court.start.y = 1;

    rteam = (struct User *)calloc(MAX, sizeof(struct User));
    bteam = (struct User *)calloc(MAX, sizeof(struct User));

    ball.x = court.width / 2;
    ball.y = court.height / 2;

    if ((listener = socket_create_udp(port)) < 0) {
        perror("socket_create_udp");
        exit(1);
    }

    DBG(GREEN "INFO" NONE " : Server start on Port %d\n", port);
#ifndef _D//绘制界面
    pthread_create(&draw_t, NULL, draw, NULL);
#endif
    epoll_fd = epoll_create(MAX * 2);
    repollfd = epoll_create(MAX);
    bepollfd = epoll_create(MAX);

    if (epoll_fd < 0 || repollfd < 0 || bepollfd < 0) {
        perror("epoll_create");
        exit(1);
    }

    struct task_queue redQueue;
    struct task_queue blueQueue;

    task_queue_init(&redQueue, MAX, repollfd);
    task_queue_init(&blueQueue, MAX, bepollfd);

    pthread_create(&red_t, NULL, sub_reactor, (void *)&redQueue);
    pthread_create(&blue_t, NULL, sub_reactor, (void *)&blueQueue);
    pthread_create(&heart_t, NULL, heart_beat, NULL);

    signal(SIGINT, server_exit);
    struct epoll_event ev, events[MAX * 2];
    ev.events = EPOLLIN;
    ev.data.fd = listener;

    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listener, &ev);
    struct sockaddr_in client;
    socklen_t len = sizeof(client);

    signal(14, re_drew);

    struct itimerval itimer;
    itimer.it_interval.tv_sec = 0;
    itimer.it_interval.tv_usec = 50000;
    itimer.it_value.tv_sec = 5;
    itimer.it_value.tv_usec = 0;
    setitimer(ITIMER_REAL, &itimer, NULL);

    Show_Message( , , "Waiting for Login.", 1);
    while (1) {
        DBG(YELLOW "Main Thread" NONE " : Before epoll_wait\n");
        int nfds = epoll_wait(epoll_fd, events, MAX * 2, -1);
        DBG(YELLOW "Main Thread" NONE " : After epoll_wait\n");

        for (int i = 0; i < nfds; ++i) {
            struct User user;
            char buff[512] = {0};
            DBG(YELLOW "EPOLL" NONE " : Doing with %dth fd\n", i);
            if (events[i].data.fd == listener) {
                int new_fd = udp_accept(epoll_fd, listener, &user);
                if (new_fd > 0) {
                    sprintf(buff, "%s Login the Game.", user.name);
                    DBG(YELLOW "Main Thread" NONE
                               " : Add %s to %s sub_reactor.\n",
                        user.name, (user.team ? "BLUE" : "RED"));
                    add_to_sub_reactor(&user);//用户加到相应的反应堆里
                    Show_Message(, ,buff, 1);
                }
            } else {
                recv(events[i].data.fd, buff, sizeof(buff), 0);
                printf(PINK "RECV" NONE " : %s\n", buff);
            }
            // char info[1024] = {0};
            // w_gotoxy_puts(Message, 1, 2, info);
        }
    }
    return 0;
}
```

#### server.conf

```cpp
LINES=25
COLS=115
PORT=8888
DATAPORT=9999
```

