---
id : B1.临时笔记
title : B1.临时笔记
typora-root-url : ../
---

# 临时笔记



缓存:高速存储设备对低速存储设备的备份

缓存机制:只能存储部分数据,究竟是哪部分
**/C++ 整套的语法不具备“功能完备性”，单纯地使用这门语言本身提供的功能无法创建任何有意义的程序，必须借助操作系统的 API 接口函数来达到相应的功能**

唯一不变的就是变化本身

- va_list
- va_start 在标准的C中，va_start接受一个额外参数，也就是最后一个【固定参数】的名称
- va_end

内存分为**物理内存**和**虚拟内存**，物理内存对应计算机中的内存条，虚拟内存是操作系统内存管理系统假象出来的

在不考虑cpu缓存的情况下，计算机运行程序本质上就是对内存中的**数据的操作**，通俗地来说，就是将内存条某些部分的数据搬进搬出或者搬来搬去，其中“搬进搬出”是指将内存中的二进制数据搬入cpu寄存器及运算器中进行相应的加减运算或者将寄存器中的数据搬回内存单元中，而“搬来搬去”是指将内存中的数据由这个位置搬到另外一个位置（当然，一般不是直接搬，而是借助寄存器作为中间存储区）。如下图所示：

![img](/Image/B1.临时笔记-photo/pointer1.webp)



![img](/Image/B1.临时笔记-photo/pointer1-1624113916219.webp)

由于存储的只是数据的内存首地址，所以指针变量存储的内存地址所指向的数据类型决定着如何解析这个首地址



C++是一种**强类型的语言**，其中有一种类型叫**void类型**

内存分布必须还要充分考虑到**字节对齐**

![img](/Image/B1.临时笔记-photo/pointer16.webp)



函数名赋值时函数名前面加不加取地址符&都一样，也就是说PF pf = f等价于PF pf = &f。这个**&是可以省略**的。但是这是单个函数的情况，在C++中取类的方法函数的地址时，这个&符号式不能省略的，见下面的例子

![img](/Image/B1.临时笔记-photo/pointer17.webp)


Linux环境编程：从应用到内核

高峰 李彬

12个笔记

0.1 一个Linux程序的诞生记

 

为什么不能在头文件中定义全局变量？这是因为定义全局变量的代码会存在于所有以#include包含该头文件的文件中，也就是说所有的这些文件，都会定义一个同样的全局变量，这样就不可避免地造成了冲突

 

 

编译环节是指对源代码进行语法分析，并优化产生对应的汇编代码的过程。

 

 

汇编的过程比较简单，就是将源代码翻译成可执行的指令，并生成目标文件。对应的gcc命令为“gcc-c 

 

 

链接是生成最终可执行程序的最后一个步骤，

 

 

就是将各个目标文件——包括库文件（库文件也是一种目标文件）链接成一个可执行程序。在这个过程中，涉及的概念比较多，如地址和空间的分配、符号解析、重定位等。在Linux环节下，该工作是由GNU的链接器ld完成的。实际上我们可以使用-v选项来查看完整和详细的gcc编译过程，命令如下。gcc -g -Wall -v 0_1_hello_word.c -o hello_world。

0.2 程序的构成

 

Linux下二进制可执行程序的格式一般为ELF格式

 

 

text段为代码段，用于保存可执行指令。data段为数据段，用于保存有非0初始值的全局变量和静态变量。bss段用于保存没有初始值或初值为0的全局变量和静态变量，当程序加载时，bss段中的变量会被初始化为0。这个段并不占用物理空间——因为完全没有必要，这些变量的值固定初始化为0，因此何必占用宝贵的物理空间？

 

 

debug段：顾名思义，用于保存调试信息。·dynamic段：用于保存动态链接信息。·fini段：用于保存进程退出时的执行程序。当进程结束时，系统会自动执行这部分代码。·init段：用于保存进程启动时的执行程序。当进程启动时，系统会自动执行这部分代码。·rodata段：用于保存只读数据，如const修饰的全局变量、字符串常量。·symtab段：用于保存符号表。

0.4 背景概念介绍

 

用户空间的程序默认是通过栈来传递参数的。对于系统调用来说，内核态和用户态使用的是不同的栈，这使得系统调用的参数只能通过寄存器的方式进行传递。

0.4.2 C库函数

 

Linux环境下，使用的C库一般都是glibc，它封装了几乎所有的系统调用，代码中使用的“系统调用”，实际上就是调用C库中的函数。C库函数同样位于用户态，所以编译器可以统一处理所有的函数调用，而不用区分该函数到底是不是系统调用。

0.4.3 线程安全

 

为了实现线程安全，该代码要么只能使用局部变量或资源，要么就是利用锁等同步机制，来实现全局变量或资源的串行访问。

1.4.2 close源码跟踪

 

[插图] 1.4.2　close源码跟踪 首先，来看一下close的源码实现，代码如下： SYSCALL_DEFINE1(close, unsigned int, fd) { struct file * filp; /* 得到当前进程的文件表 */ struct files_struct *files = current->files; struct fdtable *fdt; int retval; spin_lock(&files->file_lock); /* 通过文件表，取得文件描述符表 */ fdt = files_fdtable(files); /* 参数fd大于文件描述符表记录的最大描述符，那么它一定是非法的描述符 */ if (fd >= fdt->max_fds) goto out_unlock; /* 利用fd作为索引，得到file结构指针 */ filp = fdt->fd[fd]; /* 检查filp是否为NULL。正常情况下，filp一定不为NULL。 */ if (!filp) goto out_unlock; /* 将对应的filp置为0*/ rcu_assign_pointer(fdt->fd[fd], NULL); /* 清除fd在close_on_exec位图中的位 */ FD_CLR(fd, fdt->close_on_exec); /* 释放该fd，或者说将其置为unused。*/ __put_unused_fd(files, fd); spin_unlock(&files->file_lock); /* 关闭file结构 */ retval = filp_close(filp, files); /* can't restart close syscall because file table entry was cleared */ if (unlikely(retval == -ERESTARTSYS || retval == -ERESTARTNOINTR || retval == -ERESTARTNOHAND || retval == -ERESTART_RESTARTBLOCK)) retval = -EINTR; return retval; out_unlock: spin_unlock(&files->file_lock); return -EBADF; } EXPORT_SYMBOL(sys_close); __put_unused_fd源码如下所示：

微信读书





系统中所有的信息——包括磁盘文件、内
存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。
作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不
同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。这方面的基本原理
算法设计与分析基础(第 3 版)
是不可能的。
图4.6 代表五门课程先决条件的结构图
这个算法为什么是有效的呢？当一个顶点v退出 DFS 栈时,在比v更早出栈的顶点中，
不可能存在顶点u拥有一条从u到ν的边(否则,(u,v)会成为一条回边)。所以，在退栈次序
的队列中，任何这样的顶点u都会排在v的后面，并且在逆序队列中会排在v的前面。
对图 4.6 应用该算法，图 4.7 是它的一个图示。注意，在图 4.7(c)中，我们画出了有向
图中的边，而且像问题定义中要求的那样，它们都是从左指向右的。这样做可以方便我们
观察拓扑排序问题的实例，并检查解的正确性。
C5i
C4z
C33
c1.C2。
出栈次序：
C5, C4, C3, c1,C2
拓扑排序表:
(a)
(b】
(e]
图4.7 （a)需要求拓扑排序问题的有向图；(b)DFS 遍历栈，下标数字指出出栈的次序：(c)该问题的解
第二种算法基于减(减一)治技术的一个直接实现：不断地做这样一件事，在余下的有
向图中求出一个源(source)，它是一个没有输入边的顶点，然后把它和所有从它出发的边都
删除。(如果有多个这样的源，可以任意选择一个。如果这样的源不存在，算法停止，因为
该问题是无解的——参见本节习题第 6 题的 a 小题。)顶点被删除的次序就是拓扑排序问题
的一个解。图 4.8 给出了应用该算法对图 4.6 求解的过程。
注意，使用源删除算法获得的解和基于 DFS 的算法求得的解是不同的。当然，它们两
者都是正确的。因此，拓扑排序问题可能会有若干个不同的可选解。
由于我们使用的例子的规模非常小，可能会使大家对拓扑排序有一个错误的印象。但
请想象一个庞大的项目(例如建筑项目或者研究项目),它可能会包括数以千计的相互关联
的任务，并且具有已知的先决条件。在这种情况下，我们需要做的第一件事就是确定给定
的先决条件的集合是不矛盾的。做到这一点的一个便利方法就是对该项目的图求一个拓扑
排序的解。只有做到了这一点，我们才能开始安排任务，就是使得整个项目的总完成时间
最短。这当然需要另一种算法的支持，我们可以在运筹学的通用教科书里找到它，也可以
在一些专门探讨所谓的 CPM(Critical Path Method,关键路径法)和 PERT(Program Evaluation
and Review Technique,程序评估和检查技术)方法的书中找到它。
拓扑排序在计算机科学中有很多应用，包括程序编译中的指令调度，电子表格单元格
的公式求值顺序以及解决链接器中的符号依赖问题。
<回到页数 34
当前页数122 总页数437
隐藏


第4章减治法
4.3 生成组合对象的算法
遵照计划，本节将讨论生成组合对象的算法。组合对象中最重要的类型就是排列、组
合和给定集合的子集。一般来说，这种情况出现在要对不同的选择进行考虑的问题中。当
我们在第 3 章中讨论穷举查找时，就已经接触过这类问题了。离散数学有一个分支名为组
合数学，专门研究组合对象。数学家当然主要关心各种计算组合数量的方程，这些方程作
用很大，它们指出有多少个对象需要生成。尤其重要的是，这些方程表明：作为问题规模
的一个函数，组合对象的数量一般来说是呈指数增长的，有时甚至会更快。但我们这里感
兴趣的主要是如何生成它们，而不仅仅是计算它们的数量。
4.3.1 生成排列
我们从排列开始。为了简单起见，假设需要对元素进行排列的集合是从1到n的简单整
数集合。为了使它更具有一般性,可以把它们解释为n个元素集合{ai,…,4n}中元素的下标。
对于生成{1,…,n}的所有 n!个排列的问题，减一技术有什么好建议呢？该问题的规模减一
就是要生成所有(n-1)!个排列。假设这个较小的问题已经解决了,我们可以把n插入n-1个
元素的每一种排列中的n个可能位置中去，来得到较大规模问题的一个解。按照这种方式
生成的所有排列都是独一无二的(为什么?),并且它们的总数量应该是n(n- 1)!=n!.这样,
我们得到了{1,…,n}的所有排列。
我们既可以从左到右也可以从右到左把n插入前面生成的排列中。从实际情况来看,
下面这种做法是有好处的：一开始从右到左把n插入 12…(n－ 1)的位置中，然后每处理一
个{1,…,n-l}的新排列时，再调换方向。图 4.9 给出了应用该方法从底向上对 n =3 的情况
进行处理的例子。
开始
从右到左将 2插入 1 12 21
从右到左将 3 插入 12 123 132 312
从左到右将 3 插入21。
321 231 213
图4.9从底至上生成排列
以这种次序来生成排列有什么好处呢？因为实际上它满足所谓的最小变化要求
(minimal-change requirement):因为仅仅需要交换直接前趋中的两个元素就能得到任何一个
新的排列(请检查一下图 4.9 中生成的排列)。这个最小变化要求不仅有利于提高该算法的速
度，而且对使用这些排列的应用也有好处。例如，在 3.4 节中我们用穷举查找解旅行推销
员问题时需要城市的一个
算法设计与分析基础(第 3 版)
对于n的较小值来说，不用生成排列的方式来得到n个元素的相同次序的排列是有可
能的。为了做到这一点，我们给一个排列中的每个元素k赋予一个方向。我们在所讨论的
每个元素上画一个小箭头来指出它的方向，例如：
3右
如果元素k的箭头指向一个相邻的较小元素，我们说它在这个以箭头标记的排列中是
移动(mobile)的。例如，对于排列3241 来说，3 和 4 是移动的，而 2 和1 不是。通过使用
移动元素这个概念，我们可以给出所谓的 Johnson-Trotter 算法的描述，它也是用来生成排
列的。
算法 JohnsonTrotter(n)
/I实现用来生成排列的 Johnson-Trotter 算法
//输入：一个正整数 n
/I输出：{1,…,㎡}的所有排列的列表
将第一个排列初始化为了..
while 存在一个移动元素 do
求最大的移动元素 k
把k和它箭头指向的相邻元素互换
调转所有大于k的元素的方向
将新排列添加到列表中
在这里我们对 n = 3 应用该算法，其中最大的移动整数用粗体字表示：
T23 i32 312 35T23iIT3
这个算法是生成排列的最有效的算法之一。该算法实现的运行时间和排列的数量是呈
正比的，也就是说属于集合©(n!)。当然，除非n的值非常小，否则它的速度是慢得难以忍
受的。然而，这不是这个算法的错，而应该说是这个问题的“错”：它要求生成的项的确
是太多了。
有人可能会说 Johnson-Trotter 算法生成的排列的次序不是非常自然。例如，排列
n n-1…1的自然位置似乎应该是列表的最后一个。将排列按照升序排队，的确是这样的,
这也被称为字典序，如果数字被解释成字母表中的字符，这就是它们在字典中的排列顺序。
例如，对于 n= 3 来说,
123 132 213 231 312 321
如何按照字典序生成 qa_…q,q,后面的排列呢？如果 α，< q,(肯定有一半序列是这
样的情况)，可以简单地调换最后这两个元素的位置。例如，123 后面应该是 132。如果
a,> a,，则需要找到序列的最长递减后缀 apl >arz >…>a,(但 ay< api)；然后把 aq与后缀
中大于它的最小元素进行交换，以使 a;增大；再将新后缀颠倒，使其变为递增排列。例如，
经过这样的变换，362541 后面会跟着







习题提示
第1章
匀题 1.1
1.在因特网上查找会更快一些，但去图书馆也是有帮助的。
2.其实，支持两方面的论据都存在。但有一个非常确实的原则和本题是相关的：科
学事实和数学表达式是不能取得专利的。(你认为这是什么原因?)那么，这是不
是排除了对所有的算法授予专利呢？
3.可以假设我们不是为机器，而是在为人写算法。但是，仍然要确保我们的表述不
存在明显的歧义。克努特拿小甜饼食谱和算法做了一个有趣的比较([Knul], p.6)。
4.基于[]的定义，这个问题有一个相当简单直接的算法。
5.试着设计一个最多做 mn 次比较的算法。

6. a.就遵循课本中给出的欧几里得算法。
   b.比较一下这两个算法所做的除法次数。
   7.证明如果d 能够整除 m 和 m(也就是说,存在某些正整数 5 和 t,使得 m=sd, n =td)，
   那么它也可以整除n和 r=m mod n，反之亦然。利用公式m=qn+p(O≤ r<n)以
   及这样一个事实：如果d 能够整除u和v，那么，它也能够整除 u+v和u-v。(为
   什么?)
   8.对于两个任意选定的整数m<n，执行算法的一次迭代。
7. a 的答案可以立即给出;b则需要检查每一对1<m<n≤10的数字,才能给出答案.
8. a.利用方程
   ged(m,n)=ged(m-n,n)，其中m≥n>0
   b.关键是要计算出，对于一个初始对 m,n 来说，能够写在板上的不同数字的总
   数是多少。我们可以利用该问题和 a的关系。考虑一些较小的例子，尤其是那
   些n=1和 n= 2 的例子，也是会有帮助的。
   11.对于某些系数来说，这个问题显然无解。
   12.手工跟踪该算法(例如 n=10)并研究算法的输出有助于回答这两个问题。
   习题 1.2
   1.农夫必须多次穿越这条河，而且第一次只有一种可行的做法。
   2.和第 1 题中的古代谜题不同，求解谜题的第一步并不是显而易见的。
   3.这里的主要问题是可能会概念不清。
   当前页数394 总页数437