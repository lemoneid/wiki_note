---
id : B3.多进程
title : B3.多进程
typora-root-url : ../
---

# 多进程


![image-20200806161620688](/Image/B3.多进程-photo/image-20200806161620688.png)

内核kernel将上层应用与硬件连接起来,驱动硬件;

我们一直在zsh中,which是否内置与shell,`echo $0`

程序:可执行的二进制文件

systemd进程:1号进程,而非init(淘汰)



### 进程的创建

![image-20200806161904786](/Image/B3.多进程-photo/image-20200806161904786.png)

ppid:parent process id

资源统计信息:time 命令

信号:信号是明确给某一进程

内存清除:就是重写

==写拷贝== :
在exec之前 两个进程用的是 相同的物理空间（内存区）（所谓用是只读，不能写的），子进程的代码段、数据段、堆栈都是指向父进程的物理空间 。当父子进程中有 更改相应段的行为发生 时，再 为子进程相应的段分配物理空间（这时创建拷贝的进程的页表条目会指向这个新的物理页面（拷贝），然后恢复这个页面的可写权限） ，如果不是因为exec，内核会给 子进程的数据段、堆栈段分配相应的物理空间 （至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同， 子进程的代码段也会分配单独的物理空间 。
通常来说，fork函数的代码段基本是只读类型的，而且在运行阶段也只是复制，并不会对内容进行修改，因此父子进程是共享代码段，而数据段、Bss段、堆栈段等会在运行的过程中发生写过程，这样就导致了不同的段发生相应的写时拷贝过程，实现了不同进程的独立空间


### 进程的变身

形式：exec\[lv][pe]

list，path，vector

vector:二维数组,main主函数

list:数组

- l和v分别表示列表还是数组(向量)的方式提供参数

- p表示在用户的==path==路径下查找可执行文件
- e表示为新进程提供新的环境变量

```c
		#include <unistd.h>

       extern char **environ;

       int execl(const char *path, const char *arg, ...
                       /* (char  *) NULL */); //NULL表示列表结束
       int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);
       int execle(const char *path, const char *arg, ...
                       /*, (char *) NULL, char * const envp[] */);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[], char *const envp[]);

```

![image-20200806162318945](/Image/B3.多进程-photo/image-20200806162318945.png)

1. 进程改变为执行的进程
2. 信号接收默认处理方式:一种是什么也不做,一种是直接杀死



### 进程的退出

![image-20200806162352639](/Image/B3.多进程-photo/image-20200806162352639.png)

0-255没有返回-1

_exit:内核函数

进程最多:1024个id

![image-20200806162411050](/Image/B3.多进程-photo/image-20200806162411050.png)



一般父进程与子进程组id相同

fork()函数;

```cpp
//必须写    
if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }
```



### git进程的协同调用

```c
#include "head.h" 
#define filename "temp"

int m_flag = 0;
int main(int argc, char **argv) {
    int opt;
    pid_t pid;
    char *msg = NULL;
    while ((opt = getopt(argc, argv, "m:")) != -1) {
        switch (opt) {
            case 'm':
                m_flag = 1;
                msg = strdup(optarg);
                break;
            default:
                fprintf(stderr,"Usage: %s [-m message]\n", argv[0]);
                exit(1);
        }
    }
    if (m_flag) {
        if (msg) {
            printf("%s\n", msg);
            free(msg);
        }
        return 0;
    }
    
    if ((pid = fork()) < 0) {
        perror("fork error");
        exit(1);
    }
    if (pid == 0) {
        execlp("vim", "vim", filename, NULL);
    } else {
            wait(NULL);
            if (access(filename, R_OK) != 0) {
                perror("access error");
                exit(1);
            }
            if((pid = fork()) < 0) {
                perror("fork error");
                exit(1);
            }
            if (pid == 0) {
                //printf("cat!\n");
                execlp("cat", "cat", filename, NULL);
            } else {
                wait(NULL);
                //printf("rm\n");
                execlp("rm", "rm", filename, NULL);
            }
    }
    return 0;
}

```





# 进程管理

![img](/Image/B3.多进程-photo/f8f1f82a16255fc4_img3)

![image-20200806183724200](/Image/B3.多进程-photo/image-20200806183724200.png)

就绪:已经获得资源



![img](/Image/B3.多进程-photo/f8f1f82a16255fc4_img6)

![img](/Image/B3.多进程-photo/f8f1f82a16255fc4_img7)



虚拟内存:

==写拷贝==:

并发:一段时间内,都执行;

并行:真正的同时执行;

调度:运行那个进程,运行多久

同步:有先有后的执行,顺序确定;

cpu->cpu寄存器->cache(3级缓存)->内存->外存

## 创建多个子进程



```c
#include "head.h" 

int main(int argc, char **argv) {
    pid_t pid;
    int x = 0;
    for (int i = 0; i < 100; ++i) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    } 
    if (pid == 0) {
        DBG(GREEN"<Debug>"NONE "我是第 %d 个孩子\n", x);
    } else {
        for (int i = 0; i < x; ++i) {
            wait(NULL);
        }
    }

    return 0;
}

```









## 通过文件锁写入文件，多进程累加

### 1.struct结构体

```c
#include "head.h"

struct Num {
    int now, sum;
};

char num_file[] = "./.num";
char lock_file[] = "./.lock";

size_t set_num(struct Num *num) {
    FILE *fp = fopen(num_file, "w");
    size_t nwrite = fwrite(num, sizeof(struct Num), 1, fp);
    fclose(fp);
    return nwrite;
} 

size_t get_num(struct Num *num) {
    FILE *fp = fopen(num_file, "r");
    if (fp == NULL) {
        perror("fopen_r()");
        return -1;
    }
    size_t nread = fread(num, sizeof(struct Num), 1,  fp);
    fclose(fp);
    if (nread < 0) {
        return -1;
    }
    return nread;
}

void do_add(int max, int x) {
    struct Num num;
    while (1) {
        FILE *lock = fopen(lock_file, "w");
        flock(lock->_fileno, LOCK_EX);
        if (get_num(&num) < 0) {
            fclose(lock);
            continue; 
        }
        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\n", x, num.now, num.sum);
        if (num.now > max) {
            flock(lock->_fileno, LOCK_UN);
            break;
        }
        
        num.sum += num.now;
        num.now++;
        set_num(&num);
        flock(lock->_fileno, LOCK_UN);
    }
    return ;
}

int main(int argc, char ** argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ins\n", argv[0]);
        exit(1);
    }
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);
    struct Num num;
    num.now = 0;
    num.sum = 0;

    //save to File
    set_num(&num);

    pid_t pid;
    int x;
    for (int i = 0; i < ins; ++i) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
        
    if (pid == 0) {
        //do add
        do_add(max, x);
        exit(0);
    }
    
    for (int i = 0; i < ins; ++i) {
        wait(NULL);
    }
    
    // read from File
    get_num(&num);
    printf("sum = %d\n", num.sum);
    return 0;
}

```





### 2.变量

```c
#include "head.h"

char num_file[] = "./.num";
char lock_file[] = "./.lock";

size_t set_num(int now, int sum) {
    FILE *fp = fopen(num_file, "w");
    char buffer[100] = {0};
    sprintf(buffer,"%d\n%d\n", now, sum);
    size_t nwrite = fwrite(buffer, strlen(buffer), 1, fp);
    fclose(fp);
    return nwrite;
} 

size_t get_num(int *now, int *sum) {
    FILE *fp = fopen(num_file, "r");
    if (fp == NULL) {
        perror("fopen_r()");
        return -1;
    }

    char tmp_now[20] = {0};
    char tmp_sum[20] = {0};
    fgets(tmp_now, sizeof(tmp_now), fp);
    fgets(tmp_sum, sizeof(tmp_sum), fp);
    tmp_now[strlen(tmp_now) - 1] = '\0';
    tmp_sum[strlen(tmp_sum) - 1] = '\0';
    *now = atoi(tmp_now);
    *sum = atoi(tmp_sum);
    fclose(fp);
    return 0;
}

void do_add(int max, int x) {
    int sum = 0, now = 0;
    while (1) {
        FILE *lock = fopen(lock_file, "w");
        flock(lock->_fileno, LOCK_EX);
        if (get_num(&now, &sum) < 0) {
            fclose(lock);
            continue; 
        }
        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\n", x, now, sum);
        if (now > max) {
            flock(lock->_fileno, LOCK_UN);
            break;
        }
        
        sum += now;
        now++;
        set_num(now, sum);
        flock(lock->_fileno, LOCK_UN);
    }
    return ;
}

int main(int argc, char ** argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ins\n", argv[0]);
        exit(1);
    }
    //atoi转译 str 所指的字节字符串中的整数值
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);
    int now = 0;
    int sum = 0;

    //save to File
    set_num(now, sum);

    pid_t pid;
    int x;
    for (int i = 0; i < ins; ++i) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
        
    if (pid == 0) {
        //do add
        do_add(max, x);
        exit(0);
    }
    
    for (int i = 0; i < ins; ++i) {
        wait(NULL);
    }
    
    // read from File
    get_num(&now, &sum);
    printf("sum = %d\n", sum);
    return 0;
}

```

