---
id : A1.os
title : A1.os
typora-root-url : ../
---

# OS

**从系统和硬件上讲**：CPU一次处理数据的能力是32位还是64位，关系着系统需要安装32位还是64位的系统

**64 位CPU理论上的数据处理能力更强**。64 位 CPU 通用寄存器的位宽增加一倍，可以一次性处理 64bit 的整形数据

**64 位CPU的内存寻址能力更强**。32位CPU 地址总线不超过 32，它所能达到的寻址范围，理论上只能使用约 4GB，即不超过2的32次方字节；64 位 CPU，理论上寻址范围可以达到上亿 GB（2 的 64 次方字节）

但普遍来说，32位CPU只能支持4G内存，而 64 位CPU可支持更大内存



### 虚拟内存

#### 虚拟内存的重要性

1.每个进程使用的是一个**一致的地址空间**（从0到2^32-1），降低了程序员对内存管理的复杂性。让操作系统来完成**虚拟地址空间**到**物理地址空间**的转换。（对于程序来说，不需要关心物理地址的变化，最后被分配到哪对程序来说是透明的）

2.每个进程有自己独立的虚拟地址空间，只能访问自己的地址空间，有效地做到进程之间的隔离，保证进程的地址空间不会被其他进程破坏。（从进程角度来看，独占cpu，独占内存有单一的地址空间。）

3.提高物理内存的利用率。



物理内存就是内存条，实实在在的内存，即RAM。

虚拟内存是内存管理中的一个概念。

对于**一个进程**来说，**虚拟内存**是进程运行时**所有内存空间的总和**，包括**共享**的，**非共享**的，存在**物理内存**中，存在**分页内存**中，提交的，未提交的。【进程运行起来以后，**虚拟内存映射=PP物理空间+DP硬盘空间+未使用使用映射的**。】

**操作系统**会为每一个新创建的进程分配一个 4GB 大小的虚拟内存，从0到2^32-1。（这里说的分配4GB的虚拟内存并不是分配4GB的空间，而是创建一个映射表。)

一个系统中，**物理内存空间只有一个，但是虚拟内存空间有很多个（运行着多个进程）**



让这些虚拟内存空间映射到物理内存空间（实实在在的RAM内存条上的空间）。操作系统中页映射表（page table）所做的事情了。**内核会为系统中每一个进程维护一份相互独立的页映射表**。





内存分为**物理内存**和**虚拟内存**，物理内存对应计算机中的内存条，虚拟内存是操作系统内存管理系统假象出来的



### 进程内存空间划分

https://www.cnblogs.com/wnwin/p/10700196.html

https://blog.csdn.net/u014470361/article/details/79297601

https://www.cnblogs.com/lqerio/p/12110482.html

https://blog.csdn.net/laiqun_ai/article/details/8528366

![image-20201019214136540](/Image/A1.os-photo/image-20201019214136540.png)

- 栈区—由编译器自动分配释放，存放**函数形参，局部变量和自动变量**

- 堆区—用于分配由**malloc、realloc、calloc**分配的空间。编译器不会负责它们的释放工作，需要用程序区释放

- 数据区(全局区)—该区又分为**bss段**，**rodata段**和**data段：**

- bss段—保存**未初始化**或者**初始化为0**的**全局变量** 和static修饰的静态变量

- data段(静态数据区)—保存**初始化不为0的全局变量**或者**static修饰的变量**

- rodata段—用于保存**常量**，如全局const修饰的变量，字符串常量”abcde”， 数组的名字，**多个进程间是共享**

- text段代码区—存放函数体的**二进制代码**,代码区是被多个运行该可执行文件的进程所共享的。  

  

  ####  常量数据段(.rodata)

   ro表read only，用于存放不可变修改的常量数据，一旦程序中对其修改将会出现段错误： 
    (1) 程序中的常量不一定就放在rodata中，有的立即数和指令编码放在.text中 
    (2) 对于字符串常量，若程序中存在重复的字符串，编译器会保证只存在一个 
    (3) rodata是在多个进程间共享的 
    (4) 有的嵌入式系统，rodata放在ROM(或者NOR FLASH)中，运行时直接读取无需加载至RAM( [哈佛和冯诺依曼，从STM32的const全局变量说起](http://blog.csdn.net/qq_29344757/article/details/75730054)有所记录) 
  想要将数据放在.rodata只需要加上const属性修饰即可。

  #### 数据区(全局区）静态全局区

  ​	全局变量和静态变量的存储是放在一块的，

  ​    初始化的全局变量和静态变量在一块区域，

  ​    未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 

  全局变量、静态局部变量保存在全局数据区，初始化的和未初始化的分别保存在一起；







Code是程序代码所占的字节，即代码区；
RO-data 代表只读数据，程序中所定义的常量数据和字符串等都位于此处，即常量区；
RW-data 代表已初始化的读写数据，程序中定义并且初始化的全局变量和静态变量位于此处，一部分静态区（全局区）；
ZI-data 代表未初始化的读写数据，程序中定义了但没有初始化的全局变量和静态变量位于此处，另一部分的静态区（全局区）。ZI英语是zero initial，就是程序中用到的变量并且被系统初始化为0的变量的字节数，ke



![memery](/Image/A1.os-photo/20161029171857434)



>  一个可执行程序文件需要在计算机硬件上运行起来，其实质就是静态的文件被加载到内存中的过程，可执行程序文件只是一个程序的载体。那么执行一个应用后，它在内存中是一个怎样的结构。

#### 动&静

一个程序被加载到内存中，这块内存首先就存在两种**属性**：静态分配内存和动态分配内存。 
静态分配内存：是在程序编译和链接时就确定好的内存。 
动态分配内存：是在程序加载、调入、执行的时候分配/回收的内存。

l     BSS区（未初始化数据段）：并不给该段的数据分配空间，仅仅是记录了数据所需空间的大小。

***\*bss类型的全局变量只占运行时的内存空间，而不占文件空间\****

l     DATA（初始化的数据段）：为数据分配空间，数据保存在目标文件中。

**如果数据全是零，为了优化考虑，编译器把它当作bss处理**。通俗的说，**data指那些初始化过（非零）的非const的全局变量**

***\*data类型的全局变量是即占文件空间，又占用运行时内存空间的。\****



#### **3.      \**rodata\**

rodata** 的意义同样明显，ro代表**read only**，即只读数据(const)。关于 **rodata** 类型的数据，要注意以下几点：
l      ***\*常量不一定就放在\**** ***\*rodata\**** 里，有的立即数直接编码在指令里，存放在代码段(.text)中。
l      对于***\*字符串常量\****，编译器会**自动去掉重复的字符串**，保证一个字符串在一个可执行文件(EXE/SO)中只存在一份拷贝。
l      **rodata** 是在**多个进程间是共享**的，这可以提高空间利用率。
l      在有的嵌入式系统中， **rodata** 放在ROM(如norflash)里，**运行时直接读取ROM内存**，无需要加载到RAM内存中。
l      在嵌入式linux系统中，通过一种叫作**XIP**（就地执行）的技术，也可以直接读取，而无需要加载到RAM内存中。

由此可见，把在运行过程中不会改变的数据设为 **rodata** 类型的，是有很多好处的：在多个进程间共享，可以大大提高空间利用率，甚至不占用RAM空间。同时由于 **rodata** 在只读的内存页面(page)中，是受保护的，任何试图对它的修改都会被及时发现，这可以帮助提高程序的稳定性。

#### **4.      变量与关键字**

static关键字用途太多，以致于让新手模糊。不过，总结起来就有两种作用， **改变生命期** 和 **限制作用域** 。如：
l      修饰inline函数：限制作用域
l      修饰普通函数：限制作用域
l      修饰局部变量：改变生命期
l      修饰全局变量：限制作用域

​	注意：静态局部变量和静态全局变量。属于静态存储方式的量不一定就是静态变量。 

​	例如：全局变量虽属于静态存储方式，但不一定是静态变量，

​      必须由 static加以定义后才能成为静态外部变量，或称静态全局变量。

把**局部变量**改变为静态变量后是改变了它的存储方式，即改变了它的生存期。**静态存储，函数结束不释放；**

把**全局变量**改变为静态变量后是改变了它的作用域，限制了它的使用范围。**不可被其他文件使用**





#### const

const 关键字倒是比较明了，用const修饰的全局变量放在 **rodata** 里，局部放在栈里，字符串默认就是常量。对const，注意以下几点就行了。
l     常量指针：指向的数据是常量。如 ***\*const\**** char* p = “abc”; p指向的内容是常量 ，但p本身不是常量，你可以让p再指向”123”。
l      指针常量：指针本身是常量。如：char* **const** **p** = “abc”; p本身就是常量，你不能让p再指向”123”。
l      指针常量 + 常量指针：指针和指针指向的数据都是常量。const char* const p =”abc”; 两者都是常量，不能再修改。

#### const

1、const修饰的量不是常量，仅仅是个只读量。在编译的时候全部替换const变量被赋予的值（这点和C语言的宏相似），在运行的时候该const变量可通过内存进行修改:

1.1）通过内存(指针)可以修改位于栈区的const变量，语法合乎规定，编译运行不会报错，但是在编译的时候所有用到该常量的地方全部被替换成了定义时所赋予的值，然后再运行的时候无法使用通过指针修改后的值。
1.2）通过内存(指针)修改位于静态存储区的的const变量，语法上没有报错，编译不会出错，一旦运行就会报告异常。

注：通过指针修改在全局区上的const变量，编译可通过，运行就会报异常。

c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。

而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。

在c语言中可以通过指针对const局部变量进行修改，而不可以对const全局变量进行修改。因为const全局变量是存储在只读数据段





**violatile关键字通常用来修饰多线程共享的全局变量和IO内存**。告诉编译器，**不要把此类变量优化到寄存器中**，每次都要**老老实实的从内存中读取**，因为它们随时都可能变化。这个关键字可能比较生僻，但千万不要忘了它，否则一个错误让你调试好几天也得不到一点线索。





**表1 栈和堆的对比**

|                      | 栈                       | 堆                       |
| -------------------- | ------------------------ | ------------------------ |
| 存储内容             | 局部变量                 | 变量                     |
| 作用域               | 函数作用域、语句块作用域 | 函数作用域、语句块作用域 |
| 编译期间大小是否确定 | 是                       | 否                       |
| 大小                 | 1MB                      | 4GB                      |
| 内存分配方式         | 地址由高向低减少         | 地址由低向高增加         |
| 内容是否可以修改     | 是                       | 是                       |

 

**表2 全局/静态存储区和常量存储区的对比**

|                      | 全局/静态存储区    | 常量存储区 |
| -------------------- | ------------------ | ---------- |
| 存储内容             | 全局变量、静态变量 | 常量       |
| 编译期间大小是否确定 | 是                 | 是         |
| 内容是否可以修改     | 是                 | 否         |



```c
 	cint i2 = 20; //全局区
	int i3;     //BSS段
 	int* p1 = (int*)malloc(sizeof(int));//堆区
	const int i4 = 40;//只读常量区
    har* str = "good";//只读常量区
    char strs[] = "good";//栈区
```



**1、一条进程在内存中的映射**

  假设现在有一个程序，它的函数调用顺序如下：

**main(...) ->; func_1(...) ->; func_2(...) ->; func_3(...)**，即：主函数main调用函数func_1; 函数func_1调用函数func_2; 函数func_2调用函数func_3。

当一个程序被操作系统调入内存运行, 其对应的进程在内存中的映射如下图所示：

 

![img](http://hi.csdn.net/attachment/201202/21/0_1329798989zO3K.gif)

注意：

l     随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的；

l     随着进程中函数调用层数的减少（即各函数调用的返回），栈帧会一块块地被遗弃而向内存的高址方向回缩；

l     各函数的栈帧大小随着函数的性质的不同而不等, 由函数的局部变量的数目决定。















### 内核态,用户态

1、linux进程有4GB地址空间，如图所示：

![img](/Image/A1.os-photo/20180721092710523)

3G-4G大部分是共享的，是内核态的地址空间。这里存放整个内核的代码和所有的内核模块以及内核所维护的数据。

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级;

当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。如要执行文件操作、网络数据发送等操作必须通过write、send等系统调用；

用户态的程序就不能随意操作内核地址空间。保护模式指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

用户态切换到内核态的3种方式

（1）系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。

（2）异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。



（3）外围设备的中断