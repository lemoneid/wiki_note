---
id : B1.HZOJ
title : B1.HZOJ
typora-root-url : ../
---



# HZOJ



## 大数

```cpp
/*************************************************************************
	> File Name: 41-2.cpp
	> Author: 
	> Mail: 
	> Created Time: 日  4/26 20:51:48 2020
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;
#define MAX_N 1000

struct BigInt: public vector<int> {
    BigInt(int x = 0) {
        push_back(x);
        normal();
    }    
    
    BigInt operator*(int x) {
        BigInt ret(*this);
        for (int i = 0; i < ret.size(); i++) ret[i] *= x;
        ret.normal();
        return ret;
    }

    BigInt operator+(const BigInt &a) {
        BigInt ret(*this);
        for (int i = 0; i < a.size(); i++) {
            if (i < ret.size()) ret[i] += a[i];
            else ret.push_back(a[i]);
        }
        ret.normal();
        return ret;
    }

    void normal() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};

BigInt f[MAX_N + 5];

ostream &operator<<(ostream &out, const BigInt &a) {
    for (int i = a.size() - 1; i >= 0; --i) {
        out << a[i];
    }
    return out;
}

int main() {
    int n, k;
    cin >> n >> k;
    f[1] = k;
    f[2] = (k - 1) * k;
    f[3] = k * (k - 1) * (k - 2);
    for (int i = 4; i <= n; i++) {
        f[i] = f[i - 1] * (k - 2) + f[i - 2] * (k - 1);
    }
    cout << f[n] << endl;
    return 0;
}
```

```c
struct BigInt : vector<int>{
    BigInt(int x) {
        push_back(x);
        normal();
    }
    BigInt operator+(const BigInt &b) {
        BigInt ret = (*this);
        for (int i = 0; i < b.size(); i++) {
            if (i < ret.size()) {
                ret[i] += b[i];
            } else {
                ret.push_back(b[i]);
            }
        }
        ret.normal();
        return ret;
    } 
    void normal() {
        for (int i = 0; i < size(); i++) {
            if (at(i) < 10) continue;
            if (i + 1 == size()) push_back(0);
            at(i + 1) += at(i) / 10;
            at(i) %= 10;
        }
        return ;
    }
};

ostream &operator<<(ostream &out, const BigInt &a) {
    for (int i = a.size() - 1; i >= 0; i--) {
        out << a[i];
    }
    return out;
}

int main() {
    int n;
    BigInt a = 1, b = 1, c = 0;
    cin >> n;
    while (n--) {
        c = a + b;
        a = b;
        b = c;
    }
    cout << a << endl;
    return 0;
}
```



#### HZOJ-474. 四级考试

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <deque>
using namespace std;

struct BigFloat {
    BigFloat(int x) {
        lpart.push_back(x);
        process_digit();
    }
    void trim() {
        while (lpart.size() > 1 && lpart[0] == 0) lpart.pop_front();
        while (rpart.size() && rpart[rpart.size() - 1] == 0) rpart.pop_back();
        return;
    }
    void operator>>=(int x) {
        while (x--) {
            if (lpart.size()) {
                rpart.push_front(lpart.back());
                lpart.pop_back();
            } else {
                rpart.push_front(0);
            }
        }
        if (!lpart.size()) lpart.push_back(0);
        trim();
    }
    void process_digit() {
        for (int i = rpart.size() - 1; i >= 0; i--) {
            if (rpart[i] < 10) continue;
            if (i == 0) lpart[lpart.size() - 1] += rpart[i] / 10;
            else rpart[i - 1] += rpart[i] / 10;
            rpart[i] %= 10;
        }
        for (int i = lpart.size() - 1; i >= 0; i--) {
            if (lpart[i] < 10) continue;
            if (i == 0) lpart.push_front(0), i++;
            lpart[i - 1] += lpart[i] / 10;
            lpart[i] %= 10;
        }
        trim();
    }

    void operator*=(int x) {
        for (int i = rpart.size() - 1; i >= 0; i--) {
            rpart[i] *= x;
        }
        for (int i = lpart.size() - 1; i >= 0; i--) {
            lpart[i] *= x;
        }
        process_digit();
    }

    deque<int> lpart, rpart;
};

ostream &operator<<(ostream &out, const BigFloat &obj) {
    for (int i = 0; i < obj.lpart.size(); i++) {
        out << obj.lpart[i];
    }
    if (!obj.rpart.size()) return out;
    out << ".";
    for (int i = 0; i < obj.rpart.size(); i++) {
        out << obj.rpart[i];
    }
    return out;
}

int main() {
    int n, p[4];
    string str;
    cin >> n >> str;
    BigFloat ans = 1;
    for (int i = 0; i < n; i++) {
        char ch;
        for (int j = 0; j < 4; j++) {
            cin >> p[j] >> ch;
        }
        ans *= p[str[i] - 'A'];
        ans >>= 2;
    }
    cout << ans << endl;
    return 0;
}

```







## 栈

#### 括号画家

```c++
int main() {
    map<char, char> mmap = {{')', '('}, {']','['}, {'}', '{'}};
    stack<int> stk;
    string s;
    cin >> s;
    int ans = 0;
    for (int i = 0; s[i]; i++) {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
            stk.push(i);
            //cout << "push <- " << s[i] << endl;
        } else {
            if (!stk.empty() && mmap[s[i]] == s[stk.top()]) {
                stk.pop();
                //cout << "pop -> " << s[i] << endl;
                int ind = stk.empty() ? -1 : stk.top();
                ans = max(ans, i - ind); 
            } else {
                stk.push(i);
            }
        }
    }

    cout << ans << endl;
    return 0;
}
```







## 队列

####  270. 最大子序和

 输入一个长度为 𝑛 的整数序列，从中找出一段不超过 𝑀 的连续子序列，使得整个序列的和最大。

 例如 1，−3,5,1，−2,3：

 当 𝑚=4 时，𝑆=5+1−2+3=7；

 当 𝑚=2 或 𝑚=3 时，𝑆=5+1=6。
 第一行两个数 𝑛,𝑚。

 第二行有 𝑛 个数，要求在 𝑛 个数找到最大子序和。



```cpp
   for (int i = 1; i <= n; i++) {
        cin >> arr[i];
        arr[i] += arr[i - 1];
    }
    head = 0;
    tail = -1;
    int ans = 0;
    que[++tail] = 0;
    for (int i = 1; i <= n; i++) {
        while (tail >= head && arr[i] <= arr[que[tail]]) tail--;
        que[++tail] = i;
        ans = max(ans, arr[i] - arr[que[head]]);
        if (que[head] + m == i) head++;
    }

```





## 进制

任意进制转换+大数

```c
    int len = strlen(tmp), l = strlen(tmp), mmax = 0;

    cout << s1 << " " << tmp << endl << s2  << " ";

    for (int i = 0; l; ++i) {
        int k = 0;
        for (int j = len - l; j < len; j++) {
            k  = k * s1 + to_10[tmp[j]];
            tmp[j] = to_62[k / s2];

            k %= s2;
        }
        ans[i] = to_62[k];
        while (l > 0 && tmp[len - l] == '0') {
            --l;
        }
        mmax = i;
    }

```



## 位运算

```c
//offset小于且最接近PAGE_SIZE的倍数
//得是2的倍数???
pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
```





### 取最后一个1的位权

```cpp
int k = res & (~res + 1);
int k = res & (-res);
```

**数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的**

最终所有的元素异或的结果就是res = x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1，对应的x，y一个为1，一个为0

 **应用二 数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的。**



### 消去x最后一位的1

```cpp
x&(x-1)
```

比如: 十进制数`10`的二进制为`1010`,`9`的二进制数为`1001`,那么`(1010)&(1001)=1000`，现在`10`的二进制中最后一位的`1`已经被消去

用途:

1. **可以用来检测一个数是不是2的幂次。**

   如果一个数`x`是2的幂次，那么`x>0`且`x`的二进制中只有一个1,用`x&(x-1)`把1消去，应该返回`0`，

2. **计算一个整数二进制中1的个数**

   不断的通过`x&(x-1)`这个操作消去1，最后的值变成0

3. **如果将整数`A`转换成整数`B`,需要改变多少个比特位.**

   如果A和B在第i（0<=i<32）个位上相等，则不需要改变这个BIT位，如果在第i位上不相等，则需要改变这个BIT位。所以问题转化为了A和B有多少个BIT位不相同。联想到位运算有一个异或操作，相同为0，相异为1，所以问题转变成了计算**A异或B之后这个数中1的个数**

### 左移右移

1. 最大int：(1 << 31) - 1; 0x7fffffff
2. 最小的int值:1 << 31
3. 最大的long: ((unsigned long) -1) >> 1

### 判断一个数的奇偶性

判断奇偶性，实质是判断最后一位是否是1.

```cpp
/*
	判断一个数的奇偶性.返回1，为奇数;返回0，为偶数
	n&1
*/
```

### 交换两个数(不借助第三变量)

不用第三个变量交换两个数的方法也有几种，例如a = a + b;  b = a - b; a = a - b。下面这种方法可以实现的基础是一个数m与另一个数n异或，再与n异或，得到的结果是m.

```cpp
	a = a ^ b
	b = b ^ a
	a = a ^ b
```

### 求一个数的绝对值

下面的方法实现的基础是将n右移31位，可以获得n的符号。

```cpp
/*
	取绝对值
	n右移31位，可以获得n的符号。若n为正数，得到0；若n为负数，得到 -1
*/

	return (n ^ n >> 31) - (n >> 31);
```

### 求两个数的平均值

```cpp
/*
	求m和n的平均数
*/
	return (m + n) >> 1;

/*
	求m和n的平均数
	(m ^ n) >> 1 -> 获得m和n两个数中一个数的某些位为1的值的一半
	m & n -> 获得m和n两个数中都为1的某些位
*/
	return ((m ^ n) >> 1) + (m & n);

```

### 求解倒数第m位相关问题

```cpp
/*

	获取n的倒数第m位的值（从1开始计数）
*/
	return (n >> (m - 1)) & 1;

/*
	将n的倒数第m位设为1
*/
	return n | (1 << (m - 1));


/*
	将n的倒数第m位设为0
*/
	return n & ~(1 << (m - 1));
```



其他常用操作:

| 功能                  | 示例                   | 位运算                  |
| --------------------- | ---------------------- | ----------------------- |
| 去掉最后一位          | (101101->10110)        | x shr 1                 |
| 在最后加一个0         | (101101->1011010)      | x shl 1                 |
| 在最后加一个1         | (101101->1011011)      | x shl 1+1               |
| 把最后一位变成1       | (101100->101101)       | x or 1                  |
| 把最后一位变成0       | (101101->101100)       | x or 1-1                |
| 最后一位取反          | (101101->101100)       | x xor 1                 |
| 把右数第k位变成1      | (101001->101101,k=3)   | x or (1 shl (k-1))      |
| 把右数第k位变成0      | (101101->101001,k=3)   | x and not (1 shl (k-1)) |
| 右数第k位取反         | (101001->101101,k=3)   | x xor (1 shl (k-1))     |
| 取末三位              | (1101101->101)         | x and 7                 |
| 取末k位               | (1101101->1101,k=5)    | x and (1 shl k-1)       |
| 取右数第k位           | (1101101->1,k=4)       | x shr (k-1) and 1       |
| 把末k位变成1          | (101001->101111,k=4)   | x or (1 shl k-1)        |
| 末k位取反             | (101001->100110,k=4)   | x xor (1 shl k-1)       |
| 把右边连续的1变成0    | (100101111->100100000) | x and (x+1)             |
| 把右起第一个0变成1    | (100101111->100111111) | x or (x+1)              |
| 把右边连续的0变成1    | (11011000->11011111)   | x or (x-1)              |
| 取右边连续的1         | (100101111->1111)      | (x xor (x+1)) shr 1     |
| 去掉右起第一个1的左边 | (100101000->1000)      | x and (x xor (x-1))     |

### 利用二进制来枚举子集

#### **应用.给定一个含不同整数的集合，返回其所有的子集**

##### **样例**

如果 S = [1,2,3]，有如下的解：
[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2] ]

#### **思路**

思路就是使用一个正整数二进制表示的第i位是1还是0，代表集合的第i个数取或者不取。所以从0到2n-1总共2n个整数，正好对应集合的2^n个子集。

```
S = {1,2,3}
N bit Combination
0 000 {}
1 001 {1}
2 010 {2}
3 011 {1,2}
4 100 {3}
5 101 {1,3}
6 110 {2,3}
7 111 {1,2,3}
```

[blog-位运算](https://blog.csdn.net/zouliping123/article/details/8995373)





## 枚举

#### 519. 优雅数

 给定两个数 *𝐿*,*𝑅*L,R，求 *𝐿*,*𝑅*L,R 之间（含）有多少个“优雅数”。

 优雅数的定义：把一个数看做一个长度为 *𝑛*n 的字符串（没有前导零），*𝑛*n 个字符中 *𝑛*−1n−1 个全相同，有且仅有一个字符不同。例如 33323,11933323,119 都是优雅的，99999,233299999,2332 都是不优雅的。



```cpp
int getLen(long long val) {
    return floor(log10(val)) + 1;
}

int main() {
    long long l, r;
    int ans = 0;
    cin >> l >> r;
    int len_a = getLen(l);
    int len_b = getLen(r);
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            if (i == j) continue;
            for (int k = len_a; k <= len_b; k++) {
                for (int ind = 1; ind <= k; ind++) {
                    if (i == 0 && ind != 1) break;
                    if (j == 0 && ind == 1) continue;
                    long long num = 0;
                    for (int m = 1; m <= k; m++) {
                        if (m == ind) {
                            num = num * 10 + j;
                        } else {
                            num = num * 10 + i;
                        }
                    }
                    if (num >= l && num <= r) ans++;
                }
            }
        }
    }
    cout << ans << endl;
    return 0;
}

```







## 二分



## 数学

#### 快速幂

```cpp
int mul(int a, int b, int p) {
    int ans = 0;
    if (b > a) swap(a, b);
    while (b) {
        if (b & 1) ans = (ans + a) % p;
        a = 2 * a % p;
        b >>= 1;
    }
    return ans % p;
}

int calc(int a, int b, int p) {
    int ans  = 1;
    while (b) {
        if (b & 1) ans = mul(a, ans, p);
        a = mul(a, a, p);
        b >>= 1;
    }
    return ans % p;
}

```





#### 和为n的连续子序列

**3. 利用规律s\*k <= n而设计的算法 (nlnn)**

我们知道，s是目标子数列的第一个元素，也是最小的元素，所以必然有sum(s,k) >= s*k， 也就是n>=s*k, 也就是k <= n/s，于是算法可以写成：

for s = 1 to n
　　for k = 1 to n/s
　　　　if sum(s, k) == n
output(s, k);

此处，其复杂度并不是显而易见，但稍加分析：

复杂度 = n + n/2 + n/3 + n/4 + ... + n/n = n (1 + 1/2 + 1/3 + 1/4 + .. + 1/n)，可以注意到，括号中的部分是一个调和级数，其和为lnn。

于是，此算法的复杂度为 O(nlnn)

**4. 利用规律s\*k = n-k(k-1)/2而设计的算法(sqrt(n))**

我们知道，对于子数列求和，其公式为：

n = k(s+ (s+k-1))/2 = s*k + k(k-1)/2

得出：s*k = n - k(k-1)/2

由这个公式我们可以得到两点信息：

- 1*k <= s*k = n-k(k-1)/2，推出n-k(k-1)/2 >= k
- 如果n-k(k-1)/2能够整除k，则k是目标子数列的长度，而起始点可以由公式算出：s = (n-k(k-1)/2)/k

于是，算法就可以以k为变量递增，以n-k(k-1)/2 >= k为限制条件：

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

long long n;
int main(){
    cin >> n;
    for (int k = sqrt(2 * n); k > 0; --k) {
        long long temp = n - k * (k - 1) / 2;
        if ( temp % k == 0) {
            temp /= k;
            for (int s = temp; s < temp + k; s++) {
                s != temp && cout << " ";
                cout << s;
            }
            return 0;
        }
    }
    return 0;
}

```

#### 螺旋矩阵

①计算圈数：

可以把整个矩阵从中心分成四份，分别是左上，右上，左下，右下

可以把其他三个小矩阵对称到左上矩阵去，因为从(1,1)开始使得其$x,y$坐标符合 $min(x,y)=$圈数

第1圈数字个数  第2圈数字个数   第3圈数字个数　　...　　第$x$圈数字个数

$4(n-1)$　　　　$4(n-3)$　　　　$4(n-5)$    ...　 $4(n-2x+1)$

再观察每一圈第一个位置 $(1,1) \ ,\ (2,2) \ ,\ (3,3),....$

可以观察到每一圈的前$1/2$个(上半部分) 随着螺旋矩阵后一个数，$(x+y)$增加$1$，如图

![img](/Image/B1.HZOJ-photo/1659203-20190904184652942-1721871890-1623675339918.png)

所以在上半部分第$q$圈第$num$个也就是从$1$到$(i,j)$个的值,因为圈数是等差数列，所以利用等差数列求和公式可以得到

前面有外面的圈数+这一圈的$num=y+x-2*q+1$个数,就是 $\frac{(4(n-1)+4(n-2(q-1)+1))(q-1)}{2}+num$

在下部分随着螺旋矩阵方向,$(x+y)$逐渐减$1$,

所以，前$q-1$圈的总数+$num=$第$q$圈$-(x+y-2*q)+1$

就是$\frac{(4(n-1)+4(n-2q+1))q}{2}-num$



```cpp
 1 #include<bits/stdc++.h>
 2 using namespace std;
 3 const int maxn=1e4+5;
 4 int main()
 5 {
 6     int n,x,y;
 7     while(cin>>n>>x>>y)
 8     {
 9         int q=min(min(x,y),min(n-x+1,n-y+1));///圈数
10 
11         int num;
12         if(x==y==q)
13             num=1;
14         else if(y>x)///上半部分
15             num=y+x-2*q+1;
16         else///下半部分 
17             num=4*(n-2*q+1)-(x+y-2*q)+1;
18         cout<<2*((n-1)+(n-2*(q-1)+1))*(q-1)+num<<endl;
19     }
20 }
```



1    2   3     4     5

16  1   2     3    6

15  8   1    4    7

14  7    6    5   8

13 12  11  10  9

如果要求第二层的某个数，只需要将他的上一层(第一层)的(2,1)位置的这个数加上


```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

int calc(int n, int i, int j) {
    if (i == 1) return j;
    if (j == n) return n - 1 + i;
    if (i == n) return n * 3 -j - 1;
    if (j == 1) return 4 * n - i - 2;
    return 4 * (n - 1) + calc(n - 2, i - 1, j - 1);
}

int main(){
    int x, y, n;
    cin >> n >> x >> y;
    cout << calc(n, x, y) << endl;
    return 0;
}

```



#### 字母组合

字母 A,B,C 的所有可能的组合按照字典序排序后是：

```asciiarmor
1   A
2   AB
3   ABC
4   AC
5   B
6   BC
7   C
```

判断他是否属于前n个还是后n-1个

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define MAXN 4000000

int n, k, ans_cnt, cnt;
char ans[30];
int sum[26] = {1, 1};



int main(){
    cin >> n >> k;
    for (int i = 2; i  < 27; ++i) {
        sum[i] = sum[i - 1] << 1;
    }
    char s = 'A';
    while (k > 0) {
        if (k <= sum[n]) {
            putchar(s);
            k--;;
        }
         else k -= sum[n];
        s++;
        n--;
    }
    return 0;
}

```



## 递归

#### 235. 递归实现指数型枚举

 从 1−*𝑛*1−n 这 *𝑛*n 个整数中随机选取任意多个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。

```cpp
void p() {
    for (int i = 0; i < cnt; i++) {
        i && cout << " ";
        cout << num[i];
    }
    cout << endl;
}

int func(int start) {
    for (int i = start; i <= n; i++) {
        num[cnt++] = i;
        p();
        func(i + 1);
        cnt--;
    }
}
```

####  236. 递归实现组合型枚举

 从 1−*𝑛*1−n 这 *𝑛*n 个整数中随机选取 *𝑚*m 个，每种方案里的数从小到大排列，按字典序输出所有可能的选择方案。

------

 样例输入

```
3 2
```

样例输出

```
1 2
1 3
2 3
```

```cpp
void p() {
    for (int i = 0; i < m; i++) {
        i && cout << " ";
        cout << num[i];
    }
    cout << endl;
    return ;
}

void func(int start, int left) {
    if (left == 0) {
        p();
        return ;
    }
    for (int i = start; i <= n - left + 1; i++) {
        num[cnt++] = i;
        func(i + 1, left - 1);
        cnt--;
    }
}
```

#### 37. 递归实现排列型枚举

 从 1−*𝑛*1−n 这 *𝑛*n 个整数排成一排并打乱次序，按字典序输出所有可能的选择方案。

------

样例输入

```
3
```

样例输出

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

```cpp
void p() {
    for (int i = 1; i <= n; ++i) {
        i != 1 && cout << " ";
        cout << num[i];
    }
    cout << endl;
}


void func(int left) {
    if (left == 0) {
        p();
        return ;
    }
    for (int i = 1; i <= n; ++i) {
        if (mark[i] == 0) {
            mark[i] = 1;
            num[cnt++] = i;
            func(left - 1);
            cnt--;
            mark[i] = 0;
        }
    }
}
```





#### 打印图形

```c
#include <iostream>
#include <algorithm>
using namespace std;

int n, num[15], cnt = 1;

void p() {
    for (int i = 1; i < cnt; ++i) {
        if (i != 1) {
            cout << " ";
        }
        cout << num[i];
    }
    cout << endl;
    return ;
}

void func(int start) {
    for (int i = start; i <= n; ++i) {
        num[cnt++] = i;
        p();
        func(i + 1);
        cnt--;
    }
    return ;
}

int main() {
    cin >> n;
    func(1);
    return 0;
}

```



#### 240. 图形打印四

当 *𝑛*n 为 11 时，图形如下图：

```
X
```

 当 *𝑛*n 为 22 时，图形如下图：

```
X X X X X
```

 当 *𝑛*≥2n≥2 时，图形规律如下：

```
图形n-1    图形n-1
    图形n-1
图形n-1    图形n-1
```

 给定 *𝑛*n 组数据，输出每组数据对应的图形。

```cpp
int print(int x, int y, int n) {
    if (n == 1) {
        mmap[x][y] = 'X';
        return 0;
    }
    int len = pow(3, n - 2);
    print(x, y, n - 1);
    print(x, y + 2 * len, n - 1);
    print(x + 2 * len, y, n - 1);
    print(x + 2 * len, y + 2 * len, n - 1);
    print(x + len, y + len, n - 1);
    return 1;
}

int main() {
    print(1, 1, 7);
    int n = 0;
    while (cin >> n && n != -1) {
        for (int i = 1, I = pow(3, n - 1); i <= I; i++) {
            for (int j = 1; j <= I; j++) {
                cout << (mmap[i][j] == 'X' ? "X" : " ");
            }
            cout << endl;
        }
        cout << "-" << endl;
    }
    return 0;
}

```





## 深搜

#### 229. 开门

 有一个带有机关的门，机关上有一个 4∗44∗4 的矩阵，矩阵的每个位置上有一个字符（只能为 ++ 或 −−），可以选定矩阵上的一点进行变换，变换时这一点所在的行和列上的所有点都会跟着变换（++ 变成 −−，−− 变成 ++），只有当矩阵的所有位置的字符均为 −− 时，门才会打开。求最短需要变换几次才能开门。

```cpp
int num[4][4];
struct Data {
    int num, step;
};
int check[MAX_N + 5];
void init() {
    for (int i = 0; i < 16; i++) {
        num[i / 4][i % 4] = 1 << i;
    }
}
int main() {
    init();
    queue<Data> que;
    char ch;
    int start = 0;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            cin >> ch;
            if (ch == '+') start += num[i][j];
        }
    }
    check[start] = 1;
    que.push({start, 0});
    while (!que.empty()) {
        Data cur = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                int temp = cur.num;
                if (temp & num[i][j]) {
                    temp -= num[i][j];
                } else {
                    temp += num[i][j];
                }
                for (int k = 0; k < 4; k++) {
                    if (temp & num[i][k]) {
                        temp -= num[i][k];
                    } else {
                        temp += num[i][k];
                    }
                    if (temp & num[k][j]) {
                        temp -= num[k][j];
                    } else {
                        temp += num[k][j];
                    }
                }
                if (temp == 0) {
                    cout << cur.step + 1 << endl;
                    return 0;
                }
                if (check[temp] == 1) continue;
                check[temp] = 1;
                que.push({temp, cur.step + 1});
            }
        }
    }
    cout << "false" << endl;
    return 0;
}

```



#### HZOJ-297.导弹拦截系统



### 生日礼物

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, cost, num[45], set[2][3000005], cnt[2];

void func(int set_num, int start, int end, int sum) {
    if (sum > cost) return ;
    for (int i = start; i < end; i++) {
        sum += num[i];
        set[set_num][cnt[set_num]] = sum;
        cnt[set_num]++;
        func(set_num, i + 1, end, sum);
        sum -= num[i];
    }
}

int main() {
    while (cin >> n >> cost) {
        cnt[0] = cnt[1] = 1;
        for (int i = 0; i < n; i++) {
            cin >> num[i];
        }
        func(0, 0, n / 2, 0);
        func(1, n / 2, n, 0);
        sort(set[1], set[1] + cnt[1]);
        int f = 0;
        for (int i = 0; i < cnt[0]; i++) {
            int target = cost - set[0][i];
            int l = 0, r = cnt[1] - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (set[1][mid] == target) {
                    cout << "YES" << endl;
                    f = 1;
                    break;
                }
                if (set[1][mid] < target) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            if (f == 1) break;
        }
        if (f == 0) {
            cout << "NO" << endl;
        }
    }
    return 0;
}
```

### 门票问题

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int l, c, cnt, ans_cnt, ycnt, fcnt;
char let[30], ans[30];

int func(int s, int left) {
    if (left == 0) {
        if (!(ycnt >= 1 && fcnt >= 2)) return 0;
        for (int i = 0; i < l; i++) {
            cout << ans[i];
        }
        cout << endl;
        cnt++;
        if (cnt == 25000) return -1;
        return 0;
    }
    for (int i = s; i < c; i++) {
        ans[ans_cnt++] = let[i];
        int flag = 0;
        if (let[i] == 'a' ||
            let[i] == 'e' ||
            let[i] == 'o' ||
            let[i] == 'i' ||
            let[i] == 'u') {
            ycnt++;    
        } else {
            fcnt++;
            flag = 1;
        }
        if (func(i + 1, left - 1) == -1) {
            return -1;
        }
        if (flag == 1) {
            fcnt--;
        } else {
            ycnt--;
        }
        ans_cnt--;
    }
}

int main() {
    cin >> l >> c;
    for (int i = 0; i < c; i++) {
        cin >> let[i];
    }
    sort(let, let + c);
    func(0, l);
    return 0;
}
```

### 连通块

### 黑色区域

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAX_N = 100;

char mmap[MAX_N + 5][MAX_N + 5];
int n, m, ans, cnt;
int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };

void dfs(int row, int col) {
    for (int i = 0; i < 4; ++i) {
        int x = row + dir[i][0];
        int y = col + dir[i][1];
        if (mmap[x][y] == '1') {
            cnt++;
            mmap[x][y] = '0';
            dfs(x, y);
        }
    }
}

int main() {
    int id = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> mmap[i][j];
        }
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (mmap[i][j] == '1') {
                mmap[i][j] = '0';
                cnt = 1;
                dfs(i, j);
                ans = max(ans, cnt);
            }
        }
    }

cout << ans;
return 0;
}

```

#### 83. N 分

 给定一个正整数 *𝑛*n，把它用正整数分成 *𝑚*m 份，求有多少种不同的分法。

```cpp
int dfs(int cur, int sum, int left) {
    if (left == 1 || left == 0) {
        return 1;
    }
    int cnt = 0;
    for (int i = cur; i <= sum / left; i++) {
        cnt += dfs(i, sum - i, left - 1);
    }
    return cnt;
}

int main() {
    int n, m;
    cin >> n >> m;
    int cnt = 0;
    for (int i = 1; i <= n / m; i++) {
        cnt += dfs(i, n - i, m - 1);
    }
    cout << cnt << endl;
  
```





## 广搜

#### 81. 小明回家

 小明看完了电影，是时候回家了，可是这时他突然得知小米之家的小米9现货开卖了，这款手机小明已经想了一个多月，知道这个消息后的他十分兴奋，一定要在回家之前先去小米之家买手机（城市中有一个或多个小米之家），请计算小明从电影院到任意一个小米之家买手机后回家的最短距离（只能朝上下左右四个方向行走，除了障碍物外，其他地方都可以通过），数据保证可以买完手机后回家。

```cpp
 while (!que.empty()) {
        Data cur = que.front();
        que.pop();
        for (int i = 0; i < 4; i++) {
            int x = cur.x + dir[i][0];
            int y = cur.y + dir[i][1];
            if (cur.flag == 1 && grid[x][y] == 'T') {
                cout << cur.step + 1 << endl;
                return 0;
            }
            if (grid[x][y] == 'P' && (check[x][y] & 2) == 0) {
                check[x][y] |= 2;
                que.push({x, y, cur.step + 1, 1});
            }
            if (grid[x][y] == 'S' 
                || grid[x][y] == '.' 
                || grid[x][y] == 'T'
                || grid[x][y] == 'P') {
                    if (cur.flag == 0 && (check[x][y] & 1) == 0) {
                        check[x][y] |= 1;
                        que.push({x, y, cur.step + 1, 0});
                    } else if (cur.flag == 1 && (check[x][y] & 2) == 0){
                        check[x][y] |= 2;
                        que.push({x, y, cur.step + 1, 1});
                    }
            }
        }
    }


```







#### oj-306. 字串变换

```cpp
unordered_map<string, int> check;
string dir[7][2];
struct Data {
    string str;
    int step;
};

int main() {
    string start, end;
    cin >> start >> end;
    int n = 0;
    while (cin >> dir[n][0] >> dir[n][1]) n++;
    queue<Data> que;
    que.push({start, 0});
    check[start] = 1;
    while (!que.empty()) {
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (1) {
                Data cur = que.front();
                long long x = cur.str.find(dir[i][0], j);
                j  = x + 1;
                if (x != string::npos) {
                    cur.str.replace(x, dir[i][0].size(), dir[i][1]);
                    cur.step++;
                    if (cur.str == end) {
                        cout << cur.step << endl;
                        return 0;
                    }
                    //cout << "1-5 : <" << cur.step << "> : " << cur.str << endl;
                    if (cur.step > 5) continue;
                    if (check[cur.str]) continue;
                    check[cur.str] = cur.step;
                    que.push(cur);
                } else {
                    break;
                }
            }
        }
        que.pop();
    }
    que.push({end, 0});
    check[end] = -1;
    while (!que.empty()) {
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (1) {
                Data cur = que.front();
                long long x = cur.str.find(dir[i][1], j);
                j  = x + 1;
                if (x != string::npos) {
                    cur.str.replace(x, dir[i][1].size(), dir[i][0]);
                    cur.step++;
                    if (cur.step > 5) continue;
                    //cout << "5-10 : <" << cur.step << "> : " << cur.str << endl;
                    if (check[cur.str] > 0) {
                        cout << check[cur.str] + cur.step<< endl;
                        return 0;
                    } 
                    check[cur.str] = -cur.step;
                    que.push(cur);
                } else {
                    break;
                }
            }
        }
        que.pop();
    }

    cout << "NO ANSWER!" << endl;


    return 0;
}

```



#### 530. 警察找车

 年轻的拉尔夫开玩笑地从一个小镇上偷走一辆车，但他没想到的是那车属于警察局。并且车上装有用于发射车子移动路线的装置。那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。

 通过使用一张小镇的地图，帮助警察局找到那车。表示出该车最终所有可能的位置。

 小镇的地图是矩形的，上面的符号用来标明那儿可以行车和那儿不行。“.”“.” 表示小镇上那块地方是可以行车的，符号 “*𝑋*”“X” 表示此处不能行车。拉尔夫所开小车的初始位置，用字符的 “∗”“∗”，表示，且汽车能从初始位置通过。汽车能向四个方向移动：向北（上），南（下），西（左），东（右）；拉尔夫所开小车的行动路线是通过一组给定的方向来描述的，在每个给定的方向，拉尔夫驾驶小车通过小镇上的一个或更多的可行车地点。



```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
using namespace std;
#define MAX_N 50
#define MAX_M 1000
char matrix[MAX_N + 5][MAX_N + 5];
int check[MAX_N + 5][MAX_N + 5];
char str[20];
int op[MAX_M + 5];
int dir[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
int n, m, k;
struct Data {
    int x, y, step;
};

int main() {
    cin >> n >> m;
    queue<Data> que;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> matrix[i][j];
            if (matrix[i][j] == '*') {
                que.push({i, j, 0});
                matrix[i][j] = '.';
            }
        }
    }
    cin >> k;
    for (int i = 0; i < k; i++) {
        cin >> str;
        if (str[0] == 'N') op[i] = 0; 
        else if (str[0] == 'S') op[i] = 1;
        else if (str[0] == 'W') op[i] = 2;
        else op[i] = 3;
    }
    for (int i = 0; i < k; i++) {
        memset(check, 0, sizeof(check));
        int size = que.size();
        while (size--) {
            Data cur = que.front();
            que.pop();
            for (int j = 1; ;j++) {
                int x = cur.x + j * dir[op[i]][0];
                int y = cur.y + j * dir[op[i]][1];
                if (matrix[x][y] != '.') break;
                if (check[x][y] == 0) {
                    check[x][y] = 1;
                    que.push({x, y});
                }
            }
        }
    }
    while (!que.empty()) {
        Data cur = que.front();
        que.pop();
        matrix[cur.x][cur.y] = '*';
    }
    for (int i = 1; i <= n; i++) {
        cout << matrix[i] + 1 << endl;
    }
    return 0;
}

```



####  531. 奇怪的电视

现在帮助小明计算，从给定的状态到只有按钮3工作，而其他按钮都被释放这个最终状态所需按下的按钮序列的最短长度。

 第一行一个整数 *𝑁*N，表示按钮数。（3≤*𝑁*≤20）（3≤N≤20）

 第二行包含 *𝑁*N 个数，表示各按钮的初始状态。00 表示相应的按钮是释放的，11 表示相应的按钮是按下的。

 接下来的 *𝑁*N 行，表示按下某个按钮时将有那些按钮被释放。第 *𝑀*+2M+2 行由数字 *𝐾*K 开头，紧跟着 *𝐾*K 个数字（按升序排列），表示当按下按钮 *𝑀*M 时被释放的按钮数及按钮号码（按钮号码用数字 1∼*𝑀*1∼M 表示）。每个按钮不能释放其本身，也可能不释放任何按钮。

 输出一个数，表示从给定的状态到只有按钮3工作而其他按钮都被释放这个最终状态所需按下的按钮序列的最短长度。

------

####

```
5
1 1 0 0 1
4 2 3 4 5
4 1 3 4 5
2 2 4
0
4 1 2 3 4
```

重点在状态转移

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;
#define MAX_N 20
int digit[MAX_N + 5];
int arr[MAX_N + 5];
int check[21000000];
int n, start;
struct Data {
    int status, step;
};

void init() {
    digit[0] = 1;
    for (int i = 1; i < 22; i++) {
        digit[i] = digit[i - 1] * 2;
    }
}

int main() {
    init();
    cin >> n;
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        start += x == 1 ? digit[i] : 0;
    }

    for (int i = 1, op, x; i <= n; i++) {
        cin >> op;
        while (op--) {
            cin >> x;
            arr[i] += digit[x];
        }

    }
    queue<Data> que;
    que.push({start, 0});
    check[start] = 1;
    while (!que.empty()) {
        Data cur = que.front();
        que.pop();
        if (cur.status  == digit[3]) {
            cout << cur.step << endl;
            return 0;
        }
        for (int i = 1; i <= n; i++) {
            int x = cur.status;
            if (x & digit[i]) continue;
            x += digit[i];
            x &= ~arr[i];
            if (check[x]) continue;
            que.push({x, cur.step + 1});
            check[x] = 1;
        }
    }
    cout << -1 << endl;
    return 0;
}

```





## 图

#### 290. 可达性统计



 给定一张有 *𝑁*N 个点 *𝑀*M 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。

------

输入

 第一行输入两个整数 *𝑁*,*𝑀*N,M。（1≤*𝑁*,*𝑀*≤30000）（1≤N,M≤30000）

 接下来 *𝑀*M 行，每行两个数 *𝑥*,*𝑦*x,y，表示有一条从 *𝑥*x 点到 *𝑦*y 点的有向边。

输出

 输出共 *𝑁*N 行，每行一个数，第 *𝑖*i 行的数表示从编号为 *𝑖*i 的点出发能够到达的点的数量。

```cpp
#include <queue>
#include <bitset>
#include <iostream>
using namespace std;

int num[30005], ans[30005];
vector<int> e[30005], a;
bitset<30005> b[30005];
queue<int> q;

int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		e[x].push_back(y);
		num[y]++;
		b[x][y] = 1;
	}
	for (int i = 1; i <= n; i++) {
        if (!num[i]) {
            q.push(i);
        }
    }
	while (!q.empty()) {
		int x = q.front();
		q.pop();
		a.push_back(x);
		for (int i = 0; i < e[x].size(); i++) {
			int y = e[x][i];
            num[y]--;
			if (num[y] == 0) q.push(y);
		}
	}
	for (int i = 1; i <= n; i++) {
        b[i][i] = 1;
    }
	for (int i = a.size() - 1; i >= 0; i--) {
		int x = a[i];
		for (int j = 0; j < e[x].size(); j++) {
			b[x] |= b[e[x][j]];
        }
		ans[x] = b[x].count();
	}
	for (int i = 1; i <= n; i++) {
        cout << ans[i] << endl;
    }
	return 0;
}
 
```







## 贪心

#### 508. 两人过河

 有 *𝑛*n 个人希望在晚上通过一座桥。在任何时刻，最多只能有两个人在桥上，并且必须要带着手电筒才能过桥。现在只有一个手电筒，所以必须安排某种顺序，使得手电筒可以被带回去让更多的人过桥。每个人都有不同的过桥时间，两个人一起过桥所用的时间等于其中较慢的一个人的过桥时间。现求所有人过桥的最短时间。

一种：手电效率优先：让最慢的两人去，最快的两人会来

一种：手电传递优先：由最快的人送最慢的两人







### HZOJ-256-国王游戏

进行数学化表示，排序策略（微扰的思考方式），随意假设一种顺序，能够交换更优；

```cpp
/*************************************************************************
   > File Name: 256.cpp
   > Author: hug
   > Mail:   hug@haizeix.com
   > Created Time: 日  2/16 20:24:13 2020
 ************************************************************************/

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
#define MAX_N 1000
int a[MAX_N + 5], b[MAX_N + 5];
int ind[MAX_N + 5];

bool cmp(int i, int j) {
    return a[i] * b[i] < a[j] * b[j];
}

struct BigInt {
    BigInt(int x) {
        num.push_back(x);
        proccess_digit();
    }
    BigInt(vector<int> ret) : num(ret) {}
    BigInt operator/(int x) {
        int temp = 0, i = num.size() - 1;
        while (i >= 0 && temp * 10 + num[i] < x) temp = temp * 10 + num[i--];
        if (i < 0) return BigInt(0);
        vector<int> ret(i + 1);
        while (i >= 0) {
            temp = temp * 10 + num[i];
            ret[i] = temp / x;
            temp %= x;
            i--;
        }
        return ret;
    }
    bool operator>(BigInt &obj) {
        if (num.size() - obj.num.size()) return num.size() > obj.num.size();
        for (int i = num.size() - 1; i >= 0; i--) {
            if (num[i] - obj.num[i]) return num[i] > obj.num[i];
        }
        return false;
    }
    void operator*=(int x) {
        for (int i = 0; i < num.size(); i++) num[i] *= x;
        proccess_digit();
        return ;
    }
    void proccess_digit() {
        for (int i = 0; i < num.size(); i++) {
            if (num[i] < 10) continue;
            if (i + 1 == num.size()) num.push_back(0);
            num[i + 1] += num[i] / 10;
            num[i] %= 10;
        }
        return ;
    }
    vector<int> num;
};

ostream &operator<<(ostream &out, const BigInt &obj) {
    for (int i = obj.num.size() - 1; i >= 0; i--) {
        out << obj.num[i];
    }
    return out;
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i <= n; i++) cin >> a[i] >> b[i], ind[i] = i;
    sort(ind + 1, ind + 1 + n, cmp);
    
    BigInt p = a[ind[0]], ans = 0;
    for (int i = 1; i <= n; i++) {
        BigInt temp = p / b[ind[i]];
        if (temp > ans) ans = temp;
        p *= a[ind[i]];
    }
    cout << ans << endl;
    return 0;
}
```

### 最大子阵和

一维问题:最大子段和问题:通过前缀和数组:maxside = sum - pre;当前sum-前面最小sum

二维问题:通过枚举i行到j行;可以确定高度为i-j;通过每一列的和值,(压缩某列i行到j行为一个和值),转化为一维问题,求最大值;

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
#define MAX_N 100
int arr[MAX_N + 5][MAX_N + 5];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cin >> arr[i][j];
            arr[i][j] += arr[i - 1][j];
        }
    }
    int ans = 0x80000000;
    for (int i = 1; i <= n; ++i) {
        for (int j = i;  j <= n; ++j) {
            int pre = 0, sum = 0, temp, val = 0x80000000;
            for (int  k = 1; k <= n; ++k) {
                sum += arr[j][k] - arr[i - 1][k];
                val = max(val, sum - pre);
                pre = min(pre, sum);
            }
            ans = max(ans, val);
        }
    }
    cout << ans << endl;

    return 0;
}

```



#### 504. 删数

 输入一个高精度的正整数 *𝑛*n（长度不大于 240240 位），去掉其中任意 *𝑠*s 个数字后剩下的数字按原左右次序将组成一个新的正整数，现求一种方案，使得新的正整数数值最小。



```cpp
int main() {
    string num;
    int cnt = 0;
    cin >> num >> cnt;
    char que[250];
    int head = 0, tail = -1;
    for (int i = 0; num[i]; i++) {
        while (cnt && tail >= 0 && num[i] < que[tail]) tail--, cnt--;
        que[++tail] = num[i];
    }
    while (tail >= head && que[head] == '0') head++;
    for (int i = head; i <= tail - cnt; i++) {
        cout << que[i]; 
    }
    cout << endl;
    return 0;
}

```





## 递推

#### 233. 最高的奶牛

 *𝑁*N 头牛站成一行。两头牛能够相互看见，当且仅当它们中间的牛身高都比它们矮。现在，我们只知道其中最高的牛是第 *𝑃*P 头，它的身高是 *𝐻*H ，不知道剩余 *𝑁*−1N−1 头牛的身高。但是，我们还知道 *𝑀*M 对关系，每对关系都指明了某两头牛 *𝐴**𝑖*,*𝐵**𝑖*Ai,Bi 可以相互看见。求每头牛的身高最大可能是多少。

```cpp
for (int i = 1; i <= n; i++) {
        arr[i] = h;
    }
    while (m--) {
        int a, b;
        cin >> a >> b;
        if (a > b) swap(a, b);
        int x = min(arr[a], arr[b]), flag = 1;
        for (int j = a + 1; j < b; j++) {
            if (arr[j] < x) continue;
            flag = 0;
        }
        if (!flag) {
            for (int j = a + 1; j < b; j++) {
                arr[j] -= 1;
            }
        }
    }

```





## dp动归

#### 231. 奇怪的汉诺塔

 解出 *𝑛*n 个盘子 44 座塔的汉诺塔问题最少需要多少步。

------

```cpp
    int f[15] = {0, 1}, ans[15];
    for (int i = 2; i < 14; ++i) {
        f[i] = 2 * f[i - 1] + 1;
    }
    memset(ans, 0x3F, sizeof(ans));
    ans[0] = 0;
    ans[1] = 1;
    for (int i = 2; i < 13; ++i) {
        for (int j = 1; j < i; ++j) {
            ans[i] = min(ans[i], ans[j] * 2 + f[i - j]);
        }
    }

```





### 核电站

用s[i][0]和s[i][1]来表示第i个核电站不放或放且不爆炸的总方案数

$s[i][0]=s[i-1][0]+s[i-1][1](1≤i≤n)$

$s[i][1]=\begin{Bmatrix}s[i-1][0]+s[i-1][1]&(i<m)\cr s[i-1][0]+s[i-1][1]-1&(i=m)\cr s[i-1][0]+s[i-1][1]-s[i-m][0]&(i>m)\cr\end{Bmatrix}$

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
#define MAX_N 50

long long f[MAX_N + 5];

int main() {
    int n, m;
    cin >> n >> m;
    f[0] =  1;
    for (int i = 1; i < m; i++) {
        f[i] = 2 * f[i - 1];
    }
    f[m] = 2 * f[m - 1] - 1;
    for (int i = m + 1; i <= n; ++i) {
        f[i] = 2 * f[i - 1] - f[i - m - 1];
    }
    cout << f[n] << endl;
    return 0;
}

```



### 最长上升子序列

导弹拦截

Dilworth定理：对于一个偏序集，最少链划分等于最长反链长度。
Dilworth定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度。
 **也就是说把一个数列划分成最少的最长不升子序列的数目就等于这个数列的最长上升子序列的长度。**

　先来说一下nlogn的求解思想，令f[i]代表长度为i的所有最长不下降子序列的最后一位的最小值是多少。为什么要记录最小是多少那？因为我们想要这个序列最长，那么只有末尾最小才能有更多的数接到它的后面构成一个更长的序列。这时我们就能得到一个性质：f数组是递增的。证明：f[i]代表的是长度为i的最长不下降子序列的结尾最小的数，如果它后面来了一个比它大的数，那么这个数一定能构成至少长度为i+1的最长不下降子序列，所以在f数组里一定不会比它的位置靠前。

　　所以开一个变量len来记当前找到的最长不下降子序列有多长了，如果a[i]>=f[len]，那么直接放到f[len]后面,并且len++,但是如果a[i]<len,就要a[i]放到f数组里，这是我们用到二分，在f数组里找出大于a[i]的第一个数并且用i把它替换掉。原理：假设f[x]是大于a[i]的第一个数，那么x之前的所有数都不必a[i]大，那么把a[i]一定可以构成一个长度为x的最长不下降子序列，并且由于a[i]比f[x]更小，所以a[i]一定不会比f[x]不优。

　　有一个值得说明的点是f数组只是用来记录结尾的数的，f数组连起来并不是一个最长不下降子序列

　二分用的2个stl分别是lower_bound和upper_bound，第一个是求大于等于一个数的第一个数的位置，第二个是求大于一个数的第一个数的位置。

```cpp
//求长度可用 	

for (int i = 0; i < n; ++i) cin >> num[i];
    dp[0][len1] = dp[1][len2] = num[0];
    for (int i = 1; i < n; ++i) {
      if (num[i] <= dp[0][len1]) {
        dp[0][++len1] = num[i];
      } else {
        int x = binary_search_1(0, num[i], len1);
        dp[0][x] = num[i];
      }
    }

//字典序最小，最长单调递增子序列
	//val[len] -- 单增长度为len的最小值。
	//dp[i] -- 表示下标为i对应序列值   的最长单增长度
	//end -- 求得最长长度，最小序列值的下标
	val[0] = arr[0];
    dp[0] = 1;
    for (int i = 0; i < n; ++i) {
        int id = lower_bound(val, val + len, arr[i]) - val;
        if (id == len) {
            val[len++] = arr[i];
            dp[i] = len; 
            end = i;
        } else {
            val[id] = arr[i];
            dp[i] = id + 1;
            if (dp[i] == len) end = i;
        }
    }
	//逆序求，想明白为什么
	//dp[i] == dp[end] - 1 条件就可以保证字典序最小
	// 是否每个长度为len的序列都是一个单调不增的    
	//单独arr[i] < arr[end]不可， 4  3  1 3 2 1 4
	int l = len;
    ans[--l] = arr[end];
    for (int i = end; i >= 0; --i) {
        if (arr[i] < arr[end] && dp[i] == dp[end] - 1) {
            ans[--l] = arr[i];
            end = i;
        }
    }

```





### HZOJ-50-扔鸡蛋

![image-20201026184141903](/Image/B1.HZOJ-photo/image-20201026184141903-1623675365851.png)



j和k，楼层高度和测的次数正相关

![image-20201026184230552](/Image/B1.HZOJ-photo/image-20201026184230552-1623675365851.png)

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <map>
using namespace std;
#define MAX_N 32
#define MAX_M 655536
long long dp[MAX_N + 5][MAX_M + 5];

int main() {
    long long n, m;
    cin >> n >> m;
    if (n == 1) {
        cout <<  m << endl;
        return 0;
    }

    for (int i = 2; i <= n; ++i) {
        for (int j = 1; dp[i][j - 1] < m; ++j) {
            long long val1;
            if (i - 1 == 1) val1 = j - 1;
            else val1 = dp[i - 1][j - 1];
            dp[i][j] = val1 + dp[i][j - 1] + 1;
        }
    }
    
    int k = 1;
    while (dp[n][k] < m) k++;
    cout << k << endl;

    return 0;
}

```











## 背包问题

### 01背包问题

声明一个 大小为  m\[n][c] 的二维数组，m**\[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为  j 时所能获得的最大价值** ，那么我们可以很容易分析得出 m\[i][j] 的计算方法，

（1）. j < w[i] 的情况，这时候背包容量不足以放下第 i 件物品，只能选择不拿

m\[i][ j ] = m\[ i-1 ][ j ]

（2）. j>=w[i] 的情况，这时背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。

如果拿取，m\[ i ][ j ]=m\[ i-1 ][ j-w[ i ] ] + v[ i ]。 这里的m\[ i-1 ][ j-w[ i ] ]指的就是考虑了i-1件物品，背包容量为j-w[i]时的最大价值，也是相当于为第i件物品腾出了w[i]的空间。

如果不拿，m\[ i ][ j ] = m\[ i-1 ][ j ] , 同（1）

究竟是拿还是不拿，自然是比较这两种情况那种价值最大

```c
if(j>=w[i])
    m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]);
else
    m[i][j]=m[i-1][j];
```

```c++
for (int i = 0; i < n; ++ i) {
    cin >> v >> w;
    for (int j = m; j >= v; --j) {
        dp[j] = max(dp[j], dp[j - v] + w);
    }
}
```

| 第i层                                                        | dp[1]   | ...  | dp[m - 1] | dp[m] |
| ------------------------------------------------------------ | ------- | ---- | --------- | ----- |
| 这就是上一层副$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + p[i]) $,依赖于上一层的$j - w[i]$处的值，所以倒叙,未更新的$dp[]$代表上一层，更新代表本层的$dp[]$; | 未更新  |      | 更新      | 更新  |
|                                                              | i - 1层 |      | i层       | i层   |

####  购物单

> ## 描述
>
>   王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 
>  
>
> | 主件   | 附件           |
> | ------ | -------------- |
> | 电脑   | 打印机，扫描仪 |
> | 书柜   | 图书           |
> | 书桌   | 台灯，文具     |
> | 工作椅 | 无             |
>
>   如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 **~** 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 
>
> ​    设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为： 
>
>   v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号） 
>
> ​    请你帮助王强设计一个满足要求的购物单。 

在背包问题中，设`dp[i][j]`表示在钱数不超过j的条件下，对于前i件产品的选择所能获取的最大价值。
动态方程可以表示为
如果`j>price[i]` ， `dp[i][j]=max(dp[i][j-price[i]]+value[i],dp[i-1][j])`
否则 `dp[i][j]=dp[i-1][j])`
那么如何处理附件,我们知道，这里的编号都是主件，所以在每一主件之后可以增加对附件的判断
`dp[i][j]=`max(主件，主件+附件1，主件+附件2，主件+附件3，不买主件)

```cpp
int main() {
    int n, m;
    cin >> m >> n;
    m /= 10;
    vector<vector<int>> price(n + 1,vector<int>(3, 0));
    vector<vector<int>> value(n + 1,vector<int>(3, 0));
    for (int i = 1, v, p, q; i <= n; i++) {
        cin >> v >> p >> q;
        v /= 10;
        if (q == 0) {
            price[i][0] = v;
            value[i][0] = v * p;
        } else {
            if (price[q][1] == 0) {
                price[q][1] = v;
                value[q][1] = v * p;
            } else {
                price[q][2] = v;
                value[q][2] = v * p;
            }
        }
    }
    
    vector<int> dp(m + 1, 0);
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= price[i][0]; j--) {
            int p = price[i][0], v = value[i][0];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][1], v = value[i][0] + value[i][1];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][2], v = value[i][0] + value[i][2];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
            p = price[i][0] + price[i][1] + price[i][2], v = value[i][0] + value[i][1] + value[i][2];
            if (j >= p) {
                dp[j] = max(dp[j], dp[j - p] + v);
            }
        }
        cout << dp[m] << endl;
    }
    cout << dp[m] * 10 << endl;    
    return 0;
}

```





### 完全背包问题

```c++
for (int i = 0; i < n; ++ i) {
    cin >> v >> w;
    for (int j = v; j <= m; ++j) {
        dp[j] = max(dp[j], dp[j - v] + w);
    }
}
```

| 第i层                                                        | dp[1] | ...  | dp[m - 1] | dp[m]  |
| ------------------------------------------------------------ | ----- | ---- | --------- | ------ |
| 这就是上一层和本层；$dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + p[i]) $依赖于本层的$j - w[i]$处的值，所以正序本层的dp[]; | 更新  |      | 未更新    | 未更新 |
|                                                              | i 层  |      | i层       | i层    |






### 多重背包问题

##### 转化为01背包

个数为s；当成s个物品；

```c++
for (int i = 1; i <= n; ++i) {
        cin >> v >> w >> s;
        while (s--) {
            for (int j = m; j >= v; --j) {
                f[j] = max(f[j], f[j - v] + w);
            }
        }
    }
```



##### 二进制拆分法

例如17，拆为1，2， 4， 8,  2；这五个数可以合成任意x(s <= 17);

```c++
 for (int i = 1; i <= n; ++i) {
        cin >> v >> w >> s;
        for (int k = 1; s > 0; s -= k, k *= 2) {
            k = min(s, k);
            for (int j = m; j >= k * v; --j) {
                f[j] = max(f[j], f[j - k * v] + k * w);
            }
        }
    }
```

##### 单调队列

https://blog.csdn.net/belous_zxy/article/details/80357450?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

```cpp
int dp[MAX_V + 5];
typedef pair<int, int> PII;
deque<PII> que;
int main() {
    int mostv, n;
    cin >> mostv >> n;
    for (int i = 0, v, w, s; i < n; ++i) {
        cin >> v >> w >> s;
        if (s * v > mostv) s = mostv / v; 
        for (int ind = 0; ind < v; ++ind) {
            que.clear();
            for (int jnd = 0; jnd <= (mostv - ind) / v; ++jnd) {
                int res = dp[ind + jnd * v] - jnd * w;
                while (!que.empty() && que.front().first < jnd - s) que.pop_front();
                while (!que.empty() && que.back().second <= res) que.pop_back();
                que.push_back(PII(jnd, res));
                dp[ind + jnd * v] = que.front().second + jnd * w;
            }
        }
    }
    cout << dp[mostv] << endl;
    return 0;
}

```

