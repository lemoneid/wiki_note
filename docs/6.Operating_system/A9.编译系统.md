---
id : A9.编译系统
title : A9.编译系统
typora-root-url : ../
---

# 编译系统

### 装入的三种方式 

#### 绝对装入

在编译时，如果知道程序将放在内存的哪个位置，编译程序将产生绝对地址的目标代码，装入程序将按照转入模块中的地址，将程序和数据装入内存。

这个方式只是适用于单道程序的环境，程序中使用的绝对地址，可以在编译或者汇编时给出，也可由程序员直接赋予。最后装入模块直接使用的就是这个绝对地址在内存中操作。

#### 静态重定位 

![静态重定位](/Image/A9.编译系统-photo/内存管理_基础知识_静态装入.png) 

指令中的地址、数据存放，都是相对起始地址而言的逻辑地址，转入时重定位为装入的物理起实地址 + 逻辑地址。所有的地址变换都是在装入时一次性完成。

#### 动态重定位

动态装入，即动态运行时装入。编译、链接后装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把转换工作推迟到程序真正运行的时候才执行。因此装入内存后，依旧所有的地址依旧是逻辑地址。这个方式需要一个重定位寄存器。 

![动态装入](/Image/A9.编译系统-photo/内存管理_基础知识_动态装入.png) 

这个方式便于实现内存的不连续不分配

#### 接

![链接](/Image/A9.编译系统-photo/内存管理_基础知识_链接三种方式.png) 

可以采用重定位寄存器（又叫做基址寄存器）和界地址寄存器（又名限长寄存器）进行越界检测。重定位寄存器中存放的是进程的起实物理地址，界地址寄存器存放的是进程的最大逻辑地址寄存器



## 编译系统

以下是一个 hello.c 程序：

```cpp
include <stdio.h>int main(){    printf("hello, world\n");    return 0;}
```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```shell
gcc -o hello hello.c
```

这个过程大致如下：

 [![img](https://camo.githubusercontent.com/b106110f7870e9d6faef1e5831e1ed97b94076cfbb9929cd006606f9adeb41ce/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62333936643732362d623735662d346133322d383961322d3033613762366531396636662e6a7067)](https://camo.githubusercontent.com/b106110f7870e9d6faef1e5831e1ed97b94076cfbb9929cd006606f9adeb41ce/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62333936643732362d623735662d346133322d383961322d3033613762366531396636662e6a7067) 



- 预处理阶段：处理以  开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。

## 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

 [![img](https://camo.githubusercontent.com/b5a16d3176db7f213f470c2d877c08b75e8fcc43ef1cc6f930b340320f2c8e9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34376439383538332d386262302d343563632d383132642d3437656566613061346134302e6a7067)](https://camo.githubusercontent.com/b5a16d3176db7f213f470c2d877c08b75e8fcc43ef1cc6f930b340320f2c8e9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34376439383538332d386262302d343563632d383132642d3437656566613061346134302e6a7067) 

## 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

## 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

 [![img](/Image/A9.编译系统-photo/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37366463373736392d316161632d343838382d396265612d3036346631636161386537372e6a7067)](https://camo.githubusercontent.com/e4bd3c0074bc832f7b8f4d7dda678b26a51185668d5afc2f14af14198051d1eb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37366463373736392d316161632d343838382d396265612d3036346631636161386537372e6a7067) 



