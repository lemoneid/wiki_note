---
id : D1.CSAPP
title : D1.CSAPP
typora-root-url : ../
---



# CSAPP

> ORG:更多地强调了对程序员的影响。例如 ,要反过来考虑数据表示对C语言程序的数据类型 和操作的影响
> ORG+:强调硬件对应用程序性能,代码优化和改进C语言程序的内存性能
> ICS+:系统级网络编程和并发编程

# 章1 计算机系统漫游

## 信息就是位 +上下文

大部分的现代计算机系统都使用ASCII标准来表示文本字符

程序实际上就是一个由值**0和1组成的位（又称为比特）序**由 ASCII 字 符构成的文件称为**文本文件** , 所有其他文件都称为**二进制文件**

系统中所有的信息包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据,都是**由一串比特表示的**。区分不同数据对象的唯一方法是我们读到这些数据对象时的**上下文**。比如,在不同的上下文中,一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

#### 预编译

在预编译的过程中，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有的编译器指令。

#### 编译

在预处理结束后，进行的是编译。编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码。

#### 汇编

汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取。每一条汇编语句都会产生一句机器语言。

#### 链接

由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。所有这些问题，都需要经链接程序的处理方能得以解决。链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体




缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。

存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。
学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果

### 系统的硬件组成

1. 总线
   贯穿整个系统的是一组**电子管道**,称作总线,通常总线中传输的是**固定长度的字节块**，也就是字（word）。字中的字节数（字长）是一个基本的**系统参数**。不同系统字长不同。比如32位系统的字长为4个字节，64位系统的字长为8个字节。
   
2. I/O设备
   I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。
   
   每个IO设备都通过一个控制器或适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。
   
3. 主存
   主存是一个**临时存储设备**，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器（DRAM）芯片**组成的。从逻辑上来说，存储器是一个**线性的字节数组**，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。
   ![img](/Image/D1.CSAPP-photo/524145fafb3b5ef5d3e8467095c2b7d2.png)

4. 中央处理单元(CPU),简称处理器执行存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，**PC都指向主存中的某条机器语言指令**（即含有该条指令的地址）。


### 运行hello程序

 shell读取到我们从键盘输入的“./hello”后，计算机中的信息流向如下图红线所示：
  键盘->USB控制器->I/O总线->I/O桥->系统总线->寄存器
  寄存器->系统总线->I/O桥->内存总线->主存
  shell程序需要把用户输入的内容作为一个变量使用，而这个变量一定在内存中有个地址，所以它最终会到达内存。
![image-20201019191356753](/Image/D1.CSAPP-photo/01714d7eda5842d81cd05533055db343.png)
键盘上敲回车键时， shell程序就知道我们已经结東了命令的输入。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“ hello,wor1d\n”。信息流向如下所示。

  磁盘->磁盘控制器->I/O总线->I/O桥->内存总线->主存

  这种访问数据的方式数据不会经过CPU，而是直接从磁盘到主存，这种方式称为DMA。DMA（直接存储器访问）有利于减轻CPU的负荷，使CPU可以在数据转移的同时做其它任务。

![image-20201019191522808](/Image/D1.CSAPP-photo/a2d8089d98ab7a1070cb1d263eef1168.png)

载完hello文件后，CPU将会开始从hello程序的主函数处执行指令。这些指令将“hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。信息流向如下图所示。

  主存->寄存器->系统总线->I/O桥->I/O总线->图形适配器->显示器

![image-20201019191644207](/Image/D1.CSAPP-photo/6a23f0268bf5cf1118a90f88ada3cb6b.png)

## 高速缓存

指令和数据需要多次在寄存器、主存、磁盘之间来回复制，这些复制其实就是开销，减慢了程序工作的速度。这个时候我们就需要**高速缓存存储器**（cache memory）来解决这个问题。

![image-20201019195237101](/Image/D1.CSAPP-photo/0a12af5439845e488bdbae618c869fd3.png)

L1高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。

L2高速缓存容量为数十万到数百万字节，通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5~10倍。

L1和L2高速缓存是用一种叫做 静态随机访问存储器（SRAM） 的硬件技术实现的。

高速缓存局部性原理：程序具有访问局部区域中的数据和代码的趋势。因此，高速缓存存储器作为暂时的集结区域，存放处理器近期可能会需要的信息。

### 存储设备的层次结构

![image-20210524151153886](/Image/D1.CSAPP-photo/image-20210524151153886.png)

存储器层次结构的主要思想是**上一层的存储器作为低一层存储器的高速缓存**。

## 操作系统管理硬件

​       操作系统是应用程序和硬件之间插入的一层软件。所有应用程序对硬件的操作尝试都必须通过操作系统。

  操作系统有两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

  操作系统通过几个基本的抽象概念（进程、虛拟内存和文件）来实现这两个功能：文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。
![image-20201019201009252](/Image/D1.CSAPP-photo/a7c57406f53f011508db3831ae53a3fb.png)

## 进程&线程

​        进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另个进程的指令是交错执行的。

  上下文：操作系统保持和跟踪进程运行所需的所有状态信息（PC值，主存的内容等）。

  上下文切换：操作系统通过控制处理器在进程间切换以达到交错执行的目的。

    从一个进程到另一个进程的转换是由操作系统内核（ kernel）管理的。内核是操作系统代码常驻主存的部分。内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

![image-20201019203213287](/Image/D1.CSAPP-photo/图1-12_进程的上下文切换.png)

一个进程由多个称为线程的执行单元组成，**每个线程都运行在进程的上下文中，并共享同样的代码和全局数据**。多线程比多进程更容易共享数据，而且线程间切换所有的开销要远小于进程切换。

## 虚拟内存

虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即**每个进程都在独占地使用主存**。每个**进程看到的内存都是一致的**，称为虚拟地址空间。

基本思想是把一个进程虚拟内存的内容存储在磁盘上,然后用主存作为磁盘的高速缓存



内存分为**物理内存**和**虚拟内存**，物理内存对应计算机中的内存条RAM，虚拟内存是操作系统内存管理系统假象出来的

对于**一个进程**来说，**虚拟内存**是进程运行时**所有内存空间的总和**，包括**共享**的，**非共享**的，存在**物理内存**中，存在**分页内存**中，提交的，未提交的。【进程运行起来以后，**虚拟内存映射=PP物理空间+DP硬盘空间+未使用使用映射的**。】

**操作系统**会为每一个新创建的进程分配一个 4GB 大小的虚拟内存，从0到2^32-1。（这里说的分配4GB的虚拟内存并不是分配4GB的空间，而是创建一个映射表。)

一个系统中，**物理内存空间只有一个，但是虚拟内存空间有很多个（运行着多个进程）**

让这些虚拟内存空间映射到物理内存空间（实实在在的RAM内存条上的空间）。操作系统中页映射表（page table）所做的事情了。**内核会为系统中每一个进程维护一份相互独立的页映射表**。



![image-20201019203450101](/Image/D1.CSAPP-photo/图1-13_进程的虚拟地址空间.png)

- **内核虚拟内存:** 地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。对于一个64位的操作系统来说，用户空间为0-3G,内核空间为3G-4G。

- **栈区**—由编译器自动分配释放，存放**函数形参，局部变量和自动变量**
- **共享库:** 用于存放C语言库函数的代码和数据。本例中即`printf`的代码和数据。
- **堆区**—用于分配由**malloc、realloc、calloc**分配的空间。编译器不会负责它们的释放工作，需要用程序区释放
- **数据区(全局区)**—该区又分为**bss段**，**rodata段**和**data段：**
- **bss段**—保存**未初始化**或者**初始化为0**的**全局变量** 和static修饰的静态变量
- **data段**(静态数据区)—保存**初始化不为0的全局变量**或者**static修饰的变量**
- **rodata段**—用于保存**常量**，如全局const修饰的变量，字符串常量”abcde”， 数组的名字，**多个进程间是共享**
- **text段代码区**—存放函数体的**二进制代码**,代码区是被多个运行该可执行文件的进程所共享的。  

####  常量数据段(.rodata)

   ro表read only，用于存放不可变修改的常量数据，一旦程序中对其修改将会出现段错误： 
    (1) 程序中的常量不一定就放在rodata中，有的立即数和指令编码放在.text中 
    (2) 对于字符串常量，若程序中存在重复的字符串，编译器会保证只存在一个 
    (3) rodata是在多个进程间共享的 
    (4) 有的嵌入式系统，rodata放在ROM(或者NOR FLASH)中，运行时直接读取无需加载至RAM
  想要将数据放在.rodata只需要加上const属性修饰即可。

#### 数据区(全局区）静态全局区

全局变量和静态变量的存储是放在一块的，

初始化的全局变量和静态变量在一块区域，

未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 

全局变量、静态局部变量保存在全局数据区，初始化的和未初始化的分别保存在一起；



### 虚拟内存的重要性

1. 每个进程使用的是一个**一致的地址空间**（从0到2^32-1），降低了程序员对内存管理的复杂性。让操作系统来完成**虚拟地址空间**到**物理地址空间**的转换。（对于程序来说，不需要关心物理地址的变化，最后被分配到哪对程序来说是透明的）

2. 每个进程有自己独立的虚拟地址空间，只能访问自己的地址空间，有效地做到进程之间的隔离，保证进程的地址空间不会被其他进程破坏。（从进程角度来看，独占cpu，独占内存有单一的地址空间。）

3. 提高物理内存的利用率。





Code是程序代码所占的字节，即代码区；
RO-data 代表只读数据，程序中所定义的常量数据和字符串等都位于此处，即常量区；
RW-data 代表已初始化的读写数据，程序中定义并且初始化的全局变量和静态变量位于此处，一部分静态区（全局区）；
ZI-data 代表未初始化的读写数据，程序中定义了但没有初始化的全局变量和静态变量位于此处，另一部分的静态区（全局区）。ZI英语是zero initial，就是程序中用到的变量并且被系统初始化为0的变量的字节数，ke



![memery](/Image/D1.CSAPP-photo/20161029171857434)



>  一个可执行程序文件需要在计算机硬件上运行起来，其实质就是静态的文件被加载到内存中的过程，可执行程序文件只是一个程序的载体。那么执行一个应用后，它在内存中是一个怎样的结构。

#### **4.      变量与关键字**

static关键字用途太多，以致于让新手模糊。不过，总结起来就有两种作用， **改变生命期** 和 **限制作用域** 。如：
l      修饰inline函数：限制作用域
l      修饰普通函数：限制作用域
l      修饰局部变量：改变生命期
l      修饰全局变量：限制作用域

​	注意：静态局部变量和静态全局变量。属于静态存储方式的量不一定就是静态变量。 

​	例如：全局变量虽属于静态存储方式，但不一定是静态变量，

​      必须由 static加以定义后才能成为静态外部变量，或称静态全局变量。

把**局部变量**改变为静态变量后是改变了它的存储方式，即改变了它的生存期。**静态存储，函数结束不释放；**

把**全局变量**改变为静态变量后是改变了它的作用域，限制了它的使用范围。**不可被其他文件使用**



### 文件

文件就是字节序列,每个I/O设备,包括磁盘、键盘、显示器,甚至网络,都可以看成是文件。

系统中的所有输人输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。
文件向应用程序提供了一个统一的视图,来看待系统中可能含有的所有各式各样的I/O设备。

### Amdahl 定律

$$
\begin{aligned}
\alpha : &提升部分占总执行时间的比例\\
k : &提升部分性能提升比例\\
T_{new} &= (1 - \alpha)T_{old} + (\alpha T_{old})/k \\
&= T_{old}[(1 - \alpha) + \alpha / k]\\
加速比S &=\frac{ T_{old}}{T_{new}}\\
&=\frac{1}{(1 - \alpha) + \alpha / k}
\end{aligned}
$$

## 并发和并行

  并行：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

![img](/Image/D1.CSAPP-photo/981010bf15918b3ec46df96bf6d068d2.png)

  并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。

![img](/Image/D1.CSAPP-photo/5ce54735e7039f873bfcd7ce5305b087.png)

## 多核处理器&多线程

 **多核处理器**：多核处理器是将多个CPU(称为“核”)集成到一个集成电路芯片上。如下图所示，微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中的L1高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。

![image-20201019212750093](/Image/D1.CSAPP-photo/图1-17_多核处理器二等组织结构.png)

1. 线程级并发

2. 指令级并行

3. 单指令、多数据并行

![image-20210524174907583](/Image/D1.CSAPP-photo/image-20210524174907583.png)

**超线程**：超线程，有时称为同时多线程（ simultaneous multi-threading），是一项**允许一个CPU执行多个控制流的技术**。举个例子，Intel Core i7处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行地执行8个线程。

### 小结

​	计算机系统是由硬件和系统软件组成的,它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位,它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式,开始时是ASCII文本,然后被编译器和链接器翻译成二进制可执行文件。
​	处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和
CPU寄存器之间复制数据,所以将系统中的存储设备划分成层次结构-CPU寄存器在顶部,接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。在层次模型中,位于更高层的存储设备比低层的
存储设备要更快,单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速
缓存。通过理解和运用这种存储层次结构的知识,程序员可以优化C程序的性能。
​	操作系统内核是应用程序和硬件之间的媒介。

它提供三个基本的抽象:

1)文件是对I/O设备的抽象。
2)虚拟内存是对主存和磁盘的抽象;
3)进程是处理器、主存和
最后,网络提供了计算机系统之间通信的手段。从特殊系统的角度来看,网络就是一种I/O设备。

# 第一部分 程序结构和执行

# 章2 信息的表示和处理

#### 为什么会有二进制？二进制有什么含义和优势？

当构造存储和处理信息的机器时，二进制值工作得更好。**二值信号能够很容易地被表示、存储和传输**，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠。

**当把位组合在一起，再加上某种解释，即赋予不同的可能位模式以含意**，我们就能够表示任何有限集合的元素。比如，使用一个二进制数字系统，我们能够**用位组来编码非负数**。通过使用标准的字符码我们能够**对文档中的字母和符号进行编码**。

#### 计算机的三种编码方式

无符号：无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。

补码：补码（two’ s-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。

浮点数：浮点数（ floating-point）编码是表示实数的科学记数法的以2为基数的版本。

#### 整数&浮点数

在计算机中，整数的运算符合运算符的交换律和结合律，溢出的结果会表示为负数。整数的编码范围比较小，但是其结果表示是精确的。

浮点数的运算是不可结合的，并且其溢出会产生特殊的值——正无穷。浮点数的编码范围大，但是其结果表示是近似的。

造成上述不同的原因主要是因为计算机对于整数和浮点数的编码格式不同。
## 2.1 信息存储

### 虚拟内存&虚拟地址空间

大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（ virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（ virtual address space）。

指针是由数据类型和指针值构成的，它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。C语言中任何一个类型的指针值对应的都是一个虚拟地址。C语言编译器可以根据不同类型的指针值生成不同的机器码来访问存储在指针所指向位置处的值。但是它生成的实际机器级程序并不包含关于数据类型的信息。

程序对象（program object), 即程序数据、指令和控制信息。



#### 虚拟地址的范围

每台计算机都有一个字长（ word size），指明指针数据的标称大小（ nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

```shell
16位字长机器的地址范围：0~65535(FFFF)
32位字长机器的地址范围：0~4294967296（FFFFFFFF,4GB）
64位字长机器的地址范围：0~18446744073709551616（1999999999999998,16EB）
32位编译指令：gcc -m32 main.c
64位编译指令：gcc -m64 main.c
```
#### 二进制&十进制&十六进制

Gamma公式展示 

设$x$为$2$的非负整数$n$次幂时，也就是 $x = 2^n$
$$
2^n=2^{(i+j)}=2^i\underbrace{0\cdots0}_j(hex)
$$


十进制转十六进制还可以使用另一种方法：辗转相除法。反过来，十六进制转十进制可以用相应的16的幂乘以每个十六进制数字。



### 寻址和字节顺序

#### 大小端字节顺序

> 假设变量 x 的 类型为 int 位于地址 $0x100$ 处 ，它的十六进制值为 $0x01234567$

| 地址   | $0x100$ | $0x101$ | $0x102$ | $0x103$ | $0x104$ |
| ------ | ------- | ------- | ------- | ------- | ------- |
| 大端法 | $01$    | $23$    | $45$    | $67$    |         |
| 小端法 | $67$    | $45$    | $23$    | $01$    |         |

> 注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67。
>
> 记忆方式：
>
> 大端==高尾端，即尾端（67）放在高地址（0x103）。
>
> 小端==低尾端，即尾端（67）放在低地址（0x100）。

### 

1. **不同设备的数据传输**
   首先是在不同类型的机器之间通过网络传送二进制数据时
2. **当阅读表示整数数据的字节序列时**
   阅读反汇编代码
3. **编写符合各种系统的通用程序**
   当编写规避正常的类型系统的程序时，以通过使用强制类型转换（cast)或联合（union)来允许以一种数据类型引用一个对象而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。

### 2.1.5 代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。

### 2.1.6 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系。因此也称为布尔代数（Boolean algebra).布尔注意到通过将逻辑值TRUE(真）和 FASE（假）编码为二进制值1和0，能够设计出一种代数，以研究逻辑推理的基本原则。

| 符号 | 计算机 | 命题逻辑     | 符号        |
| ---- | ------ | ------------ | ----------- |
| ~    | 非     | NOT          | $\lnot$     |
| &    | 与     | AND          | $\and$      |
| \|   | 或     | OR           | $\or$       |
| ^​​    | 异或   | EXCLUSIVE-OR | $\bigoplus$ |

当考虑长度为 w 的位向量上的 ^ 和 & 和 ~运算时，会得到一种不同的数学形式，我们称为布尔环（Boolean ring)

位向量一个很有用的应用就是表示有限集合。

使用这种编码集合的方法，布尔运算 | 和 & 分别对应于集合的并和交，而~对应于于集合的补。

^为异或运算符，有一个重要的性质：a ^ a = 0，a ^ 0= a。即任何数和其自身异或结果为0，和0异或结果仍为原来的数。

逻辑运算符&& 和||还有一个短路求值的性质

#### 左移&右移

1. 逻辑左移（SHL）和算数左移(SAL)，规则相同，右边统一添0
2. 逻辑右移(SHR)，左边统一添0
3. 算数右移(SAR)，左边添加的数和符号有关 (正数补0，负数补1)

C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，算术右移或者逻辑右移都可以。不幸地，这就意味着遇到可移植性问题。实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

与 C 相比，Java 对于如何进行右移有明确的定义。表达是 `x>>k` 会将 x 算术右移 $k$ 位置，而 `x>>k` 会对 x 做逻辑右移

对于一个由 $w$ 位组成的数据类型，C语言标准移位指令只考虑位移量的低 $\log_2w$​ 位。

另一方面，Java 特别要求位移数量应该按求模的方法来计算。

### 整数表示

约定一些术语如下所示

| 符号     | 类型 | 含义                | 符号    | 类型 | 含义         |
| -------- | ---- | ------------------- | ------- | ---- | ------------ |
| $B2T_w$  | 函数 | 二进制$\to$补码     | $+_w^t$ | 操作 | 补码加法     |
| $B2U_w$  | 函数 | 二进制$\to$无符号数 | $+_u^w$​ | 操作 | 无符号数加法 |
| $U2B_w$  | 函数 | 无符号数$\to$二进制 | $*_t^w$ | 操作 | 补码乘法     |
| $U2T_w$  | 函数 | 无符号数$\to$补码   | $*_u^w$ | 操作 | 无符号数乘法 |
| $T2B_w$  | 函数 | 补码$\to$二进制     | $-_t^w$ | 操作 | 补码取反     |
| $T2U_w$  | 函数 | 补码$\to$无符号数   | $-_u^w$ | 操作 | 无符号数取反 |
| $TMin_w$ | 常数 | 最小补码值          |         |      |              |
| $TMax_w$ | 常数 | 最大补码值          |         |      |              |
| $UMax_w$ | 常数 | 最大无符号数        |         |      |              |

##### 扩展：当移动位数大于实际位数时该怎么办？

许多机器上，当移动一个$w$位的值时，移位指令只考虑位移量的低 $[\log_2w]$位，因此实际上位移量就是通过计算$k mod w$得到的。



# 章3 程序的机器级表示

## 3.2  机器级代码

#### 计算机的抽象模型

对于机器级编程来说，其中**两种抽象尤为重要**。第一种是由**指令集体系结构或指令集架构**（ Instruction Set Architecture,ISA）来定义机器级程序的格式和行为，它定义了**处理器状态**、**指令的格式**，以及**每条指令对状态的影响**。大多数ISA，包括x86-64，将程序的行为描述成**好像每条指令都是按顺序执行的**，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。第二种抽象是，**机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组**。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。

#### 汇编代码中的寄存器

- 程序计数器（通常称为"PC”，在x86-64中用表示）给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息“它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。



**机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。**



操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
  一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。

链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了 `callq`指令调用函数 mult2 需要使用的地址（反汇编代码第 4 行）。

链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是

多了两行代码(`nop`）。 这两条指令对程序没有影响，因为它们出现在返回指令（`retq`）后面。 插入这些指令是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能更好地放置下一个代码块。

### 3.4 访问信息

大多数指令有一个或多个操作数（operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

1. 立即数（immediate), 用来表示常数值。`$`+`标准C整数`
2. 寄存器（register)，它表示某个寄存器的内容，$r_a$表示任意寄存器 , 用引用 $R[r_a]$来表示它的值
3. 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。$M_b[Addr]$ 表示对存储在内存
   中从地址 $Addr$ 开始的 $b$ 个字节值的引用。（通常省去下标 $b$）
   $Imm(r_b, r_i, s)$ —— 立即数偏移$Imm$；基址寄存器
   $r_b$；变址寄存器$r_i$；比例因子$s$,

![image-20210816113319261](/Image/D1.CSAPP-photo/image-20210816113319261.png)

​            

### 3.4.2 数据传送指令

| mov指令 | 操作数据大小 /字节 |
| ------- | ------------------ |
| movb    | 1                  |
| movw    | 2                  |
| movl    | 4                  |
| movq    | 8                  |

![image-20210816203226442](/Image/D1.CSAPP-photo/image-20210816203226442.png)

![image-20210816203258432](/Image/D1.CSAPP-photo/image-20210816203258432.png)

