---
id : A1.os
title : A1.os
typora-root-url : ../
---

# OS

**从系统和硬件上讲**：CPU一次处理数据的能力是32位还是64位，关系着系统需要安装32位还是64位的系统

**64 位CPU理论上的数据处理能力更强**。64 位 CPU 通用寄存器的位宽增加一倍，可以一次性处理 64bit 的整形数据

**64 位CPU的内存寻址能力更强**。32位CPU 地址总线不超过 32，它所能达到的寻址范围，理论上只能使用约 4GB，即不超过2的32次方字节；64 位 CPU，理论上寻址范围可以达到上亿 GB（2 的 64 次方字节）

但普遍来说，32位CPU只能支持4G内存，而 64 位CPU可支持更大内存



### 虚拟内存



### 进程内存空间划分

https://www.cnblogs.com/wnwin/p/10700196.html

https://blog.csdn.net/u014470361/article/details/79297601

https://www.cnblogs.com/lqerio/p/12110482.html

https://blog.csdn.net/laiqun_ai/article/details/8528366

![image-20201019214136540](/Image/A1.os-photo/image-20201019214136540.png)

- 






#### const

const 关键字倒是比较明了，用const修饰的全局变量放在 **rodata** 里，局部放在栈里，字符串默认就是常量。对const，注意以下几点就行了。
l     常量指针：指向的数据是常量。如 ***\*const\**** char* p = “abc”; p指向的内容是常量 ，但p本身不是常量，你可以让p再指向”123”。
l      指针常量：指针本身是常量。如：char* **const** **p** = “abc”; p本身就是常量，你不能让p再指向”123”。
l      指针常量 + 常量指针：指针和指针指向的数据都是常量。const char* const p =”abc”; 两者都是常量，不能再修改。

#### const

1、const修饰的量不是常量，仅仅是个只读量。在编译的时候全部替换const变量被赋予的值（这点和C语言的宏相似），在运行的时候该const变量可通过内存进行修改:

1.1）通过内存(指针)可以修改位于栈区的const变量，语法合乎规定，编译运行不会报错，但是在编译的时候所有用到该常量的地方全部被替换成了定义时所赋予的值，然后再运行的时候无法使用通过指针修改后的值。
1.2）通过内存(指针)修改位于静态存储区的的const变量，语法上没有报错，编译不会出错，一旦运行就会报告异常。

注：通过指针修改在全局区上的const变量，编译可通过，运行就会报异常。

c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。

而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。

在c语言中可以通过指针对const局部变量进行修改，而不可以对const全局变量进行修改。因为const全局变量是存储在只读数据段





**violatile关键字通常用来修饰多线程共享的全局变量和IO内存**。告诉编译器，**不要把此类变量优化到寄存器中**，每次都要**老老实实的从内存中读取**，因为它们随时都可能变化。这个关键字可能比较生僻，但千万不要忘了它，否则一个错误让你调试好几天也得不到一点线索。





**表1 栈和堆的对比**

|                      | 栈                       | 堆                       |
| -------------------- | ------------------------ | ------------------------ |
| 存储内容             | 局部变量                 | 变量                     |
| 作用域               | 函数作用域、语句块作用域 | 函数作用域、语句块作用域 |
| 编译期间大小是否确定 | 是                       | 否                       |
| 大小                 | 1MB                      | 4GB                      |
| 内存分配方式         | 地址由高向低减少         | 地址由低向高增加         |
| 内容是否可以修改     | 是                       | 是                       |

 

**表2 全局/静态存储区和常量存储区的对比**

|                      | 全局/静态存储区    | 常量存储区 |
| -------------------- | ------------------ | ---------- |
| 存储内容             | 全局变量、静态变量 | 常量       |
| 编译期间大小是否确定 | 是                 | 是         |
| 内容是否可以修改     | 是                 | 否         |



```c
 	cint i2 = 20; //全局区
	int i3;     //BSS段
 	int* p1 = (int*)malloc(sizeof(int));//堆区
	const int i4 = 40;//只读常量区
    har* str = "good";//只读常量区
    char strs[] = "good";//栈区
```



**1、一条进程在内存中的映射**

  假设现在有一个程序，它的函数调用顺序如下：

**main(...) ->; func_1(...) ->; func_2(...) ->; func_3(...)**，即：主函数main调用函数func_1; 函数func_1调用函数func_2; 函数func_2调用函数func_3。

当一个程序被操作系统调入内存运行, 其对应的进程在内存中的映射如下图所示：

 

注意：

l     随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的；

l     随着进程中函数调用层数的减少（即各函数调用的返回），栈帧会一块块地被遗弃而向内存的高址方向回缩；

l     各函数的栈帧大小随着函数的性质的不同而不等, 由函数的局部变量的数目决定。















### 内核态,用户态

1、linux进程有4GB地址空间，如图所示：

![img](/Image/A1.os-photo/20180721092710523)

3G-4G大部分是共享的，是内核态的地址空间。这里存放整个内核的代码和所有的内核模块以及内核所维护的数据。

当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级;

当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。如要执行文件操作、网络数据发送等操作必须通过write、send等系统调用；

用户态的程序就不能随意操作内核地址空间。保护模式指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

用户态切换到内核态的3种方式

（1）系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如fork（）就是执行了一个创建新进程的系统调用。系统调用的机制和新是使用了操作系统为用户特别开放的一个中断来实现，如Linux的int 80h中断。

（2）异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。



（3）外围设备的中断







### 存、栈、堆

一般应用程序内存空间有如下区域：

- 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文
- 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域
- 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里
- 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据

#### 栈

栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：

- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 保存上下文：包括函数调用前后需要保持不变的寄存器



#### 堆

堆分配算法：

- 空闲链表（Free List）
- 位图（Bitmap）
- 对象池



#### “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”

典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。

普遍原因：

- 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针
- 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针



### 编译链接



#### 各平台文件格式

| 平台       | 可执行文件 | 目标文件 | 动态库/共享对象       | 静态库       |
| ---------- | ---------- | -------- | --------------------- | ------------ |
| Windows    | exe        | obj      | dll                   | lib          |
| Unix/Linux | ELF、out   | o        | so                    | a            |
| Mac        | Mach-O     | o        | dylib、tbd、framework | a、framework |

#### 编译链接过程

1. 预编译（预编译器处理如 `#include`、`#define` 等预编译指令，生成 `.i` 或 `.ii` 文件）
2. 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 `.s` 文件）
3. 汇编（汇编器把汇编码翻译成机器码，生成 `.o` 文件）
4. 链接（连接器进行地址和空间分配、符号决议、重定位，生成 `.out` 文件）

> 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld

> MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin



#### 目标文件

编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。

> 可执行文件（Windows 的 `.exe` 和 Linux 的 `ELF`）、动态链接库（Windows 的 `.dll` 和 Linux 的 `.so`）、静态链接库（Windows 的 `.lib` 和 Linux 的 `.a`）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）

##### 目标文件格式

- Windows 的 PE（Portable Executable），或称为 PE-COFF，`.obj` 格式
- Linux 的 ELF（Executable Linkable Format），`.o` 格式
- Intel/Microsoft 的 OMF（Object Module Format）
- Unix 的 `a.out` 格式
- MS-DOS 的 `.COM` 格式

> PE 和 ELF 都是 COFF（Common File Format）的变种



##### 目标文件存储结构

| 段                      | 功能                                                         |
| ----------------------- | ------------------------------------------------------------ |
| File Header             | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等） |
| .text section           | 代码段，执行语句编译成的机器代码                             |
| .data section           | 数据段，已初始化的全局变量和局部静态变量                     |
| .bss section            | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间） |
| .rodata section         | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量 |
| .comment section        | 注释信息段，存放编译器版本信息                               |
| .note.GNU-stack section | 堆栈提示段                                                   |

> 其他段略



#### 链接的接口————符号

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

如下符号表（Symbol Table）：

| Symbol（符号名） | Symbol Value （地址） |
| ---------------- | --------------------- |
| main             | 0x100                 |
| Add              | 0x123                 |
| ...              | ...                   |



### Linux 的共享库（Shared Library）

Linux 下的共享库就是普通的 ELF 共享对象。

共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容

#### 

#### 命名

```
libname.so.x.y.z
```

- x：主版本号，不同主版本号的库之间不兼容，需要重新编译
- y：次版本号，高版本号向后兼容低版本号
- z：发布版本号，不对接口进行更改，完全兼容



#### 路径

大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。

- `/lib`：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等
- `/usr/lib`：存放非系统运行时所需要的关键性的库，主要是开发库
- `/usr/local/lib`：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库

> 动态链接器会在 `/lib`、`/usr/lib` 和由 `/etc/ld.so.conf` 配置文件指定的，目录中查找共享库



#### 环境变量

- `LD_LIBRARY_PATH`：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序
- `LD_PRELOAD`：指定预先装载的一些共享库甚至是目标文件
- `LD_DEBUG`：打开动态链接器的调试功能