---
id : A2.OS概述
title : A2.OS概述
typora-root-url : ../
---

# OS概述

## 基本特征

### 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序,同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

### 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。



### 计算密集任务和IO密集任务

* 计算密集型任务
  * 特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。
  * 虽然可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

* IO密集型任务
  * 涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。
  * 对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

### 单核CPU/多核CPU/多CPU

> * 都是一个CPU，不同的是每个CPU上的核心数。
> * 多核CPU是多个CPU的替代方案，同时也减少了功耗。
> * 一个核心只能同时执行一个线程。

* 单核CPU
  * 一个CPU中只有一个核心处理器
* 多核CPU
  * 一个CPU有多个核心处理器，处理器之间通过**CPU内部总线**进行通讯
* 多CPU
  * 简单的多个CPU工作在同一个系统上，多个CPU之间通过**主板上的总线**进行通讯

## 基本功能

### 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 程序的局部性原理

### 基本概念

程序倾向于引用临近于其他最近引用过的数据项的数据项，或最近引用过的数据项本身，这种倾向性被称为局部性原理。

* 时间局部性
  * 良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用
* 空间局部性
  * 良好空间局部性的程序中，一个内存位置被引用，程序很可能在不远的将来引用其附近的一个内存位置 

### 从硬件和操作系统层面看如何利用局部性

* 硬件层
  * 局部性原理允许硬件引入高速缓存存储器这种小而快速的存储器来存储最近被引用的指令和数据，从而提高对主存的访问速度
* 操作系统
  * 允许系统使用主存作为虚拟地址空间作为最近被引用块的高速缓存

### [从存储结构看如何利用局部性](https://www.jianshu.com/p/5c9b28c95c64)

存储器层次结构的中心思想是，对于每个 k，位于 k 层的更快更小的存储设备作为位于 k + 1 层的更大更慢的存储设备的缓存。

* 时间局部性
  * 同一数据对象可能被多次使用。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中的快很多。 
* 空间局部性
  * 块通常包含多个数据对象。我们会期望后面对该块中其他对象的访问能补偿不命中后复制该块的花费。 



## 用户态和内核态

### 概念

> * 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。
> * 用户态拥有最低的特权级，内核态拥有较高的特权级。
> * 运行在用户态的程序不能直接访问操作系统内核数据结构和程序
> * 操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的。
>   * 分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性。
>   * 分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。

### [用户态和内核态可以通过指针传递数据吗？](http://blog.chinaunix.net/uid-26611973-id-3190018.html)

* 用户态不能访问内核态的指针
  * 为了实现内存的保护，防止越界访问而造成受保护内存的被非法修改，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的。
* 内核态可以访问用户态的指针(有前提)
  * 必须保证用户态虚拟空间的指针（虚拟空间的地址），已经分配物理地址，否则指针传入内核态中将不会引发缺页异常而报错
* [内核中访问用户进程的地址的时候用copy_from_user，而不是用memcpy直接拷贝(或者说使用用户态指针)](https://blog.csdn.net/u014089131/article/details/56272892)
  * copy_from_user主要是这个函数提供了两个功能
    * 对用户进程传过来的地址范围进行合法性检查；
    * 当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行； 
    * 对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表。这个过程对于用户进程是完全透明的。但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误
  * 直接使用memcpy时为什么没有出现异常
    * 只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常。 

### 两种状态转换

* 系统调用
  * 用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作 
* 异常
  * 当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。 
* 外围设备中断
  * 当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序 
  * 比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等 



## 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

 [![img](https://camo.githubusercontent.com/e6e9338fcb2f8c849b5ed9798862d27937d80c94721948dd87c5dec1e739c2c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e706e67)](https://camo.githubusercontent.com/e6e9338fcb2f8c849b5ed9798862d27937d80c94721948dd87c5dec1e739c2c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f74475056302e706e67) 



Linux 的系统调用主要有以下这些：

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

## [库函数和系统调用的区别](https://www.cnblogs.com/liwei0526vip/p/8998751.html)

### 概念

* 库函数调用是语言或应用程序的一部分，而系统调用是操作系统的一部分，跨平台技术的原理就是通过库函数实现的，库函数可以理解为是对系统调用的一层封装，但库函数不是必须包含系统调用。
* 库函数有可能包含有一个系统调用，有可能有好几个系统调用，当然也有可能没有系统调用，比如有些操作不需要涉及内核的功能。

### 区别

> * 所有 C 函数库是相同的，而各个操作系统的系统调用是不同的。
> * 函数库调用是调用函数库中的一个程序，而系统调用是调用系统内核的服务。
> * 函数库调用是与用户程序相联系，而系统调用是操作系统的一个进入点
> * 函数库调用是在用户地址空间执行，而系统调用是在内核地址空间执行
> * 函数库调用的运行时间属于「用户」时间，而系统调用的运行时间属于「系统」时间
> * 函数库调用属于过程调用，开销较小，而系统调用需要切换到内核上下文环境然后切换回来，开销较大
> * 在C函数库libc中大约 300 个程序，在 UNIX 中大约有 90 个系统调用
> * 函数库典型的 C 函数：system, fprintf, malloc，而典型的系统调用：chdir, fork, write, brk

### 为什么不直接用函数调用

* 因为读写文件通常是大量的数据（相对于底层驱动的系统调用所实现的数据操作单位），这时，使用库函数可以大大减少系统调用的次数。这是因为**缓冲区技术**，在用户空间和内核空间对文件操作都使用了缓冲区。当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓存区。同理，内核缓冲区满或写结束时，才将内核缓冲区内容写到文件对应的硬件媒介。
* 为了保证可移植性

### [库函数的缓冲区](https://blog.csdn.net/it_liuwei/article/details/45022671)

* 对于库函数，如果标准输出连到终端设备(直接输出到屏幕)，则它是行缓冲的（遇到回车换行符或者是缓冲区满了才输出）；否则（输出到文件）是全缓冲的（缓冲区填满或者是程序运行结束了才输出）。
* 程序运行结束时，会刷新所有的缓冲区。

由于上面的缓冲机制，也给我们编写程序时带来了一些奇怪的问题。解决办法有如下两种：

* 任何时候我们都可以使用fflush(stdout)来刷新标准输出缓冲区。
* 使用不带缓冲的系统调用write替代printf输出。

### 系统调用底层原理

* 每个系统调用函数都有一个系统调用号
* 首先找到系统调用对应的中断号（Linux下是int 0x80），然后在中断向量表中找到对应的中断处理函数，再根据系统调用号，在中断处理函数找到对应系统调用函数进行执行。

## [跨平台技术实现原理](https://segmentfault.com/q/1010000005178192)

现有跨平台技术就是通过库函数调用实现的，不使用系统函数调用。

* Qt如何识别不同系统
  *  Qt各个操作系统都有特定的宏，然后代码里面根据不同的宏调用不同平台的API



## 宏内核和微内核

### 1. 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

 [![img](/Image/A2.OS概述-photo/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067)](https://camo.githubusercontent.com/e244b7965823da98c230d7b71038b8ee11dcb2e30b5e8fb1272dcd76008a889f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f325f31345f6d6963726f6b65726e656c4172636869746563747572652e6a7067) 

## 中断分类 

![缺页中断机构](/Image/A2.OS概述-photo/内存管理_虚拟内存_缺页中断_2.png) 

 

### 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

### 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

### 3. 陷入

在用户程序中使用系统调用。

### 中断

+ 当中断发生时，CPU会立即进入内核态。实际上，用户态和内核态之间的切换也是依靠中断完成的
+ 当中断发生，当前运行的进程会暂停运作，并且交由操作系统内核对中断进行处理
+ 对于不同的中断，会进行不同的处理

发生了中断，就说明需要操作系统介入，开展管理工作。而操作系统的管理工作（比如进程切换，分配I/O设备等）需要特权指令，因此使用CPU要从内核态转入内核态。故而，**中断可以使得用户态转为内核态，使得操作系统获得计算机的控制权**。

用户态与内核态是通过寄存器`psw`来标志的：

+ 用户态--> 内核态：是通过而且只能通过中断的方式
+ 内核态--> 用户态：只是需要将`psw`设置为用户态



